// ============================================================
// Expanded D&D 5e Example
//
// Goal: model a meaningful slice of 5e beyond basic melee combat.
// This file doubles as a language stress test — comments marked
// PAIN POINT or MISSING FEATURE flag places where the DSL is
// awkward or insufficient. Items marked RESOLVED show where
// recent language additions have closed gaps.
// ============================================================

system "D&D 5e Expanded" {

    // ========================================================
    //  ENUMS
    // ========================================================

    enum Ability { STR, DEX, CON, INT, WIS, CHA }

    enum Skill {
        acrobatics, animal_handling, arcana, athletics,
        deception, history, insight, intimidation,
        investigation, medicine, nature, perception,
        performance, persuasion, religion, sleight_of_hand,
        stealth, survival
    }

    enum RollMode { normal, advantage, disadvantage, auto_fail, auto_succeed }

    enum DamageType {
        slashing, piercing, bludgeoning,
        fire, cold, lightning, thunder, poison,
        acid, necrotic, radiant, psychic, force
    }

    enum WeaponProperty {
        light, heavy, finesse, thrown, versatile,
        reach, two_handed, loading, ammunition
    }

    // PAIN POINT: No way to express "ranged vs melee" at the type level.
    // A weapon is either melee or ranged (or both for thrown), but the
    // enum approach forces us to use a bool or a separate enum, neither
    // of which composes well with the property set.
    enum WeaponCategory { simple_melee, simple_ranged, martial_melee, martial_ranged }

    enum ArmorCategory { light_armor, medium_armor, heavy_armor, shield }

    enum Size ordered { tiny, small, medium, large, huge, gargantuan }

    // RESOLVED: Union types for entity refs use groups + `entity`.    [ttrpg_dsl-q5l]
    // For entity unions: `entity with Combatant` accepts any entity
    // with the group. For non-entity unions, enum payloads work:
    enum DamageSource {
        weapon(name: string, damage_dice: DiceExpr),
        spell(name: string, school: SpellSchool),
        environment(description: string)
    }

    enum ResolvedDamage {
        miss,
        hit(amount: int)
    }

    enum SaveResult {
        success,
        failure
    }

    // RESOLVED: Parameterized conditions now support Exhaustion levels:
    //     condition Exhaustion(level: int) on bearer: Character { ... }
    // Apply with: apply_condition(target, Exhaustion(level: 3), dur)

    // PAIN POINT: Enums can't have associated data beyond variant payloads.
    // Each Skill has a corresponding Ability — the derive approach works
    // but is verbose (see skill_ability below).

    enum SpellSchool {
        abjuration, conjuration, divination, enchantment,
        evocation, illusion, necromancy, transmutation
    }

    // MISSING FEATURE: No integer range or "level" type.             [ttrpg_dsl-3v8]
    // Spell slots are keyed by level 1-9, but we can't express
    // `int(1..9)` as a type. We just use plain int.

    enum RestType { short_rest, long_rest }

    enum CoverType { no_cover, half_cover, three_quarters_cover, full_cover }

    // RESOLVED: Duration is now a ruleset-customizable enum.          [ttrpg_dsl-d3r]
    // The builtin only provides `indefinite`; rulesets define the
    // variants they need. This covers "indefinite / until removed"
    // (Grappled, Prone) and time-based durations (rounds, minutes).
    //
    // Remaining gap: no "until next use" (Help action grants advantage
    // on the NEXT roll only) and no "until a save is made" (many spell
    // effects). These would need additional Duration variants with
    // host-side interpretation.
    enum Duration {
        end_of_turn,
        start_of_next_turn,
        rounds(count: int),
        minutes(count: int),
        hours(count: int),
        indefinite
    }


    // ========================================================
    //  TAGS
    // ========================================================

    // RESOLVED: Tags and selector-targeted modify clauses allow     [ttrpg_dsl-wus]
    // conditions to target classes of functions rather than listing
    // each one by name. Declare tags here, apply to mechanics below.
    tag d20_roll      // any mechanic that resolves a d20 check
    tag attack        // attack resolution mechanics (melee/ranged/spell)


    // ========================================================
    //  STRUCTS
    // ========================================================

    struct TurnBudget {
        actions: int
        bonus_actions: int
        reactions: int
        movement: int
        free_interactions: int
    }

    struct DamageSpec {
        dice: DiceExpr
        type: DamageType
    }

    // RESOLVED: For-loops now handle list iteration.                  [ttrpg_dsl-dz3]
    // Multi-damage-type spells can iterate over a list<DamageSpec>:
    //     for spec in damage_list {
    //         let applied = apply_resistances(target, roll(spec.dice).total, spec.type)
    //         target.HP -= applied
    //     }

    struct SpellInfo {
        name: string
        level: int          // 0 = cantrip
        school: SpellSchool
        range: int
        // PAIN POINT: No way to express complex spell targeting.
        // Some spells target a point (AoE), some target a creature,
        // some target self. Would want:
        //     targeting: TargetSelf | TargetCreature(count: int) | TargetPoint(radius: int)
        // Enum payloads could work but can't be used as types for
        // action parameters without unwrapping boilerplate.           [ttrpg_dsl-q5l]
        save_ability: option<Ability>  // none = no save (auto-hit or attack roll)
        damage: option<DamageSpec>     // none = non-damage spell
        healing: option<DiceExpr>      // none = non-healing spell
        concentration: bool
    }

    // PAIN POINT: No struct update syntax.                            [ttrpg_dsl-kmy]
    // Can't write: let upcast = spell { damage: new_damage, ..spell }
    // Must reconstruct the entire struct to change one field.


    // ========================================================
    //  ENTITIES
    // ========================================================

    entity Weapon {
        name: string
        category: WeaponCategory
        damage: DamageSpec
        ability: Ability
        properties: set<WeaponProperty>
        range: int             // normal range in feet
        long_range: option<int>
    }

    entity Armor {
        name: string
        category: ArmorCategory
        base_AC: int
        max_dex_bonus: option<int>  // none = no cap (light armor)
        stealth_disadvantage: bool
        strength_requirement: option<int>
    }

    entity Character {
        name: string
        level: int = 1

        // Core attributes
        abilities: map<Ability, int>
        proficiency_skills: set<Skill>
        proficient_saves: set<Ability>
        size: Size = medium

        // Defense
        AC: int
        HP: resource(0..=max_HP)
        max_HP: int
        temp_HP: int = 0
        // PAIN POINT: Temporary HP in 5e doesn't stack — you pick
        // the higher value. This is a policy rule, not expressible
        // in the type system. We'd need a custom setter or
        // "no-stack resource" type.

        // Movement
        speed: int = 30
        position: Position

        // Equipment
        // PAIN POINT: No way to express "list of equipped weapons"
        // or "loadout slots" (main hand / off hand). Two-weapon
        // fighting needs main_hand + off_hand fields.
        equipped_weapon: Weapon
        equipped_armor: option<Armor>
        shield_equipped: bool = false

        // RESOLVED: Optional groups replace boolean flags.            [ttrpg_dsl-s43]
        // Class-specific fields live in groups granted at spawn time.
        // A Fighter gets `grant char.FighterFeatures { ... }`,
        // a Wizard gets `grant char.Spellcasting { ... }`.
        // Non-casters don't carry spellcasting fields at all.

        optional Spellcasting {
            spellcasting_ability: Ability
            spell_save_DC: int
            spell_attack_bonus: int
            // RESOLVED: Resource-valued maps replace 9 separate fields. [ttrpg_dsl-5yt]
            // map<int, resource(0..=9)> gives clamped, per-level slots.
            spell_slots: map<int, resource(0..=9)>
            known_spells: list<SpellInfo>
            concentrating_on: option<string>
        }

        optional FighterFeatures {
            has_extra_attack: bool = false
            action_surge_uses: int = 0
            second_wind_uses: int = 0
        }

        optional RogueFeatures {
            sneak_attack_dice: DiceExpr = 0d6
            // RESOLVED: 0d6 now works as a DiceExpr default.          [ttrpg_dsl-46i]
            // RESOLVED: has_cunning_action removed — Cunning Action   [ttrpg_dsl-xh9]
            // is now a condition with cost overrides, granted via
            // apply_condition(rogue, CunningAction, Duration.indefinite)
        }

        // Death saves (tracked on all characters; 5e uses 3 successes/failures)
        death_save_successes: int = 0
        death_save_failures: int = 0

        // Misc
        conditions: set<Condition>
        resistances: set<DamageType>
        immunities: set<DamageType>
        vulnerabilities: set<DamageType>
    }

    // The entity is now much leaner — class-specific fields are in
    // optional groups, not carried by every Character.
    // RESOLVED: Top-level group declarations + `include` make groups   [ttrpg_dsl-zzx4]
    // cross-entity composable. A `group CoreStats { ... }` can be
    // shared across Character, Monster, NPC via `include CoreStats`
    // (required) or `optional CoreStats` (grantable).


    // ========================================================
    //  DERIVES (pure computations)
    // ========================================================

    derive modifier(score: int) -> int {
        floor((score - 10) / 2)
    }

    derive proficiency_bonus(level: int) -> int {
        floor((level - 1) / 4) + 2
    }

    derive initial_budget(actor: Character) -> TurnBudget {
        TurnBudget {
            actions: 1,
            bonus_actions: 1,
            reactions: 1,
            movement: actor.speed,
            free_interactions: 1
        }
    }

    derive apply_resistances(
        target: Character,
        raw_damage: int,
        damage_type: DamageType
    ) -> int {
        match {
            damage_type in target.immunities      => 0,
            damage_type in target.resistances     => floor(raw_damage / 2),
            damage_type in target.vulnerabilities => raw_damage * 2,
            _ => raw_damage
        }
    }

    // Map each skill to its governing ability.
    // PAIN POINT: This is a 18-branch match for what is essentially   [ttrpg_dsl-8tu]
    // static data. No way to express a lookup table or associated
    // enum data.
    derive skill_ability(skill: Skill) -> Ability {
        match skill {
            athletics       => STR,
            acrobatics      => DEX,
            sleight_of_hand => DEX,
            stealth         => DEX,
            arcana          => INT,
            history         => INT,
            investigation   => INT,
            nature          => INT,
            religion        => INT,
            animal_handling => WIS,
            insight         => WIS,
            medicine        => WIS,
            perception      => WIS,
            survival        => WIS,
            deception       => CHA,
            intimidation    => CHA,
            performance     => CHA,
            persuasion      => CHA
        }
    }

    // Armor class calculation
    // PAIN POINT: 5e AC depends on armor type, DEX modifier, shield,
    // spells, magic items, class features (Unarmored Defense), etc.
    // Deeply polymorphic — the formula depends on class, equipment,
    // and features. For now, AC is a flat field set at creation time.

    derive compute_AC(char: Character) -> int {
        let dex_mod = modifier(char.abilities[DEX])
        let base = match char.equipped_armor {
            none => 10 + dex_mod,
            some(armor) => {
                // RESOLVED: if-let simplifies nested option handling.  [ttrpg_dsl-ccr]
                let dex_bonus = if let some(cap) = armor.max_dex_bonus {
                    if dex_mod < cap { dex_mod } else { cap }
                } else {
                    dex_mod
                }
                armor.base_AC + dex_bonus
            }
        }
        if char.shield_equipped { base + 2 } else { base }
    }

    // Cover bonus
    derive cover_AC_bonus(cover: CoverType) -> int {
        match cover {
            no_cover            => 0,
            half_cover          => 2,
            three_quarters_cover => 5,
            full_cover          => 0  // can't be targeted at all
        }
    }

    derive cover_save_bonus(cover: CoverType) -> int {
        match cover {
            no_cover            => 0,
            half_cover          => 2,
            three_quarters_cover => 5,
            full_cover          => 0
        }
    }

    // PAIN POINT: These two derives have identical bodies. No way
    // to alias a derive. The semantic distinction (AC vs save) matters
    // for the condition/modify system, so we need both.


    // ========================================================
    //  MECHANICS (can roll dice, no mutation)
    // ========================================================

    mechanic d20_expr(
        score: int,
        proficiency: int = 0,
        bonus: int = 0,
        mode: RollMode = normal
    ) -> DiceExpr {
        let base: DiceExpr = match mode {
            normal       => 1d20,
            advantage    => 2d20kh1,
            disadvantage => 2d20kl1
        }
        base + modifier(score) + proficiency + bonus
    }

    mechanic choose_attack_ability(
        attacker: Character,
        weapon: Weapon
    ) -> Ability {
        if finesse in weapon.properties {
            let str_mod = modifier(attacker.abilities[STR])
            let dex_mod = modifier(attacker.abilities[DEX])
            if dex_mod > str_mod { DEX } else { weapon.ability }
        } else {
            weapon.ability
        }
    }

    // --- Attack rolls ---

    mechanic attack_roll(
        attacker: Character,
        target: Character,
        weapon: Weapon,
        mode: RollMode = normal,
        bonus: int = 0      // situational bonuses (cover, etc.)
    ) -> RollResult #d20_roll #attack {
        let ability = choose_attack_ability(attacker, weapon)
        let expr = d20_expr(
            score: attacker.abilities[ability],
            proficiency: proficiency_bonus(attacker.level),
            bonus: bonus,
            mode: mode
        )
        roll(expr)
    }

    mechanic spell_attack_roll(
        caster: Character,
        target: Character,
        mode: RollMode = normal,
        bonus: int = 0
    ) -> RollResult #d20_roll {
        // RESOLVED: With optional groups, spell_attack_bonus lives in
        // the Spellcasting group. We check with `has` since mechanics
        // can't use `with` constraints (that's actions only).         [ttrpg_dsl-s43]
        let spell_bonus = if caster has Spellcasting as sc {
            caster.sc.spell_attack_bonus
        } else {
            0
        }
        let expr: DiceExpr = match mode {
            normal       => 1d20,
            advantage    => 2d20kh1,
            disadvantage => 2d20kl1
        }
        roll(expr + spell_bonus + bonus)
    }

    // --- Damage rolls ---

    mechanic damage_expr(
        attacker: Character,
        weapon: Weapon,
        critical: bool = false
    ) -> DiceExpr {
        let ability = choose_attack_ability(attacker, weapon)
        let dice: DiceExpr = if critical {
            multiply_dice(weapon.damage.dice, 2)
        } else {
            weapon.damage.dice
        }
        dice + modifier(attacker.abilities[ability])
    }

    mechanic resolve_melee_attack(
        attacker: Character,
        target: Character,
        weapon: Weapon,
        mode: RollMode = normal,
        attack_bonus: int = 0
    ) -> ResolvedDamage {
        let atk: RollResult = attack_roll(
            attacker, target, weapon, mode, attack_bonus
        )
        match {
            atk.unmodified == 1 => ResolvedDamage.miss,
            atk.unmodified == 20 => {
                let dmg: RollResult = roll(damage_expr(attacker, weapon, critical: true))
                let final_dmg = apply_resistances(target, dmg.total, weapon.damage.type)
                ResolvedDamage.hit(final_dmg)
            },
            atk >= target.AC => {
                let dmg: RollResult = roll(damage_expr(attacker, weapon, critical: false))
                let final_dmg = apply_resistances(target, dmg.total, weapon.damage.type)
                ResolvedDamage.hit(final_dmg)
            },
            _ => ResolvedDamage.miss
        }
    }

    // --- Saving throws ---

    mechanic saving_throw(
        target: Character,
        ability: Ability,
        DC: int,
        mode: RollMode = normal,
        bonus: int = 0
    ) -> SaveResult #d20_roll {
        match mode {
            auto_fail    => SaveResult.failure,
            auto_succeed => SaveResult.success,
            _ => {
                let prof = if ability in target.proficient_saves {
                    proficiency_bonus(target.level)
                } else {
                    0
                }
                let expr = d20_expr(
                    score: target.abilities[ability],
                    proficiency: prof,
                    bonus: bonus,
                    mode: mode
                )
                let result = roll(expr)
                if result >= DC { SaveResult.success } else { SaveResult.failure }
            }
        }
    }

    // --- Skill checks ---

    mechanic skill_check(
        actor: Character,
        skill: Skill,
        DC: int,
        mode: RollMode = normal
    ) -> SaveResult #d20_roll {
        let ability = skill_ability(skill)
        let prof = if skill in actor.proficiency_skills {
            proficiency_bonus(actor.level)
        } else {
            0
        }
        // PAIN POINT: No "expertise" (double proficiency). Would need
        // a proficiency_level: map<Skill, ProficiencyLevel> field and
        // a multiplier derive.
        let expr = d20_expr(
            score: actor.abilities[ability],
            proficiency: prof,
            mode: mode
        )
        let result = roll(expr)
        if result >= DC { SaveResult.success } else { SaveResult.failure }
    }

    // --- Contested checks ---

    // PAIN POINT: No tuple type. Would love:                          [ttrpg_dsl-q5l]
    //     -> (attacker_roll: RollResult, defender_roll: RollResult, winner: bool)
    mechanic contested_check(
        actor: Character,
        actor_skill: Skill,
        target: Character,
        target_skill: Skill
    ) -> bool {
        let actor_ability = skill_ability(actor_skill)
        let actor_prof = if actor_skill in actor.proficiency_skills {
            proficiency_bonus(actor.level)
        } else {
            0
        }
        let target_ability = skill_ability(target_skill)
        let target_prof = if target_skill in target.proficiency_skills {
            proficiency_bonus(target.level)
        } else {
            0
        }
        let actor_roll = roll(d20_expr(
            score: actor.abilities[actor_ability],
            proficiency: actor_prof
        ))
        let target_roll = roll(d20_expr(
            score: target.abilities[target_ability],
            proficiency: target_prof
        ))
        actor_roll >= target_roll
    }

    // --- Initiative ---

    mechanic initiative_roll(combatant: Character) -> RollResult #d20_roll {
        let expr = d20_expr(score: combatant.abilities[DEX])
        roll(expr)
    }

    // MISSING FEATURE: No list sorting / map / reduce.               [ttrpg_dsl-4km]
    // The host must sort combatants by initiative. For-loops help
    // iterate but don't produce ordered collections.

    // --- Concentration ---

    mechanic concentration_check_DC(damage_taken: int) -> int {
        let half = floor(damage_taken / 2)
        if half > 10 { half } else { 10 }
    }


    // ========================================================
    //  PROMPTS (human decision points)
    // ========================================================

    prompt choose(chooser: Character, options: list<string>) -> string {
        hint: "The player or GM selects one option from the list"
    }

    prompt gm_decides(context: string) -> string {
        hint: "The GM determines the outcome based on the fiction"
    }

    // RESOLVED: Typed prompts now carry return type and named params   [ttrpg_dsl-ctc]
    // through the effect system. The host knows exactly what type to
    // return, and receives named parameter bindings for context.

    // Entity-typed prompt: host returns a Character, not a string.
    // The interpreter validates the response matches the declared type.
    prompt choose_target(chooser: Character, candidates: list<Character>) -> Character {
        hint: "Choose a target creature"
        suggest: candidates[0]
    }

    // Enum-typed prompt for defender skill selection in contested checks.
    prompt choose_contest_skill(defender: Character, allowed: list<Skill>) -> Skill {
        hint: "Choose which skill to use for the contested check"
        suggest: allowed[0]
    }

    // Shove outcome choice: typed enum instead of string matching.
    enum ShoveChoice { knock_prone, push_away }

    prompt choose_shove_outcome(shover: Character) -> ShoveChoice {
        hint: "Knock the target prone, or push them 5 feet away?"
        suggest: ShoveChoice.knock_prone
    }


    // ========================================================
    //  ACTIONS (can roll + mutate)
    // ========================================================

    // --- Basic melee attack ---

    action Attack on attacker: Character (target: Character, weapon: Weapon) {
        cost { action }
        requires { distance(attacker.position, target.position) <= weapon.range }

        resolve {
            let result = resolve_melee_attack(attacker, target, weapon)
            match result {
                hit(amount) => {
                    target.HP -= amount
                    // RESOLVED: emit statement fires events from DSL code.  [ttrpg_dsl-wbic]
                    // The host no longer needs to manually fire takes_damage.
                    emit takes_damage(
                        reactor: target,
                        source: attacker,
                        amount: amount,
                        damage_type: weapon.damage.type
                    )
                },
                miss => {}
            }
        }
    }

    // RESOLVED: For-loops replace hard-coded multi-attack actions.    [ttrpg_dsl-dz3]
    // The old AttackWithExtraAttack took exactly 2 targets and
    // hard-coded 2 attacks. Now we accept a list of targets and
    // iterate over them — works for 2 attacks (level 5), 3 (level 11),
    // or 4 (level 20). The host enforces list length.

    action AttackMultiple on attacker: Character with FighterFeatures as ff (
        targets: list<Character>,
        weapon: Weapon
    ) {
        cost { action }
        requires { attacker.ff.has_extra_attack }

        resolve {
            for target in targets {
                if distance(attacker.position, target.position) <= weapon.range {
                    let result = resolve_melee_attack(attacker, target, weapon)
                    match result {
                        hit(amount) => {
                            target.HP -= amount
                            emit takes_damage(
                                reactor: target,
                                source: attacker,
                                amount: amount,
                                damage_type: weapon.damage.type
                            )
                        },
                        miss => {}
                    }
                }
            }
        }
    }

    // --- Dash, Dodge, Disengage ---

    action Dash on actor: Character () {
        cost { action }
        resolve {
            turn.movement += actor.speed
        }
    }

    action Dodge on actor: Character () {
        cost { action }
        resolve {
            apply_condition(actor, Dodging, Duration.start_of_next_turn)
        }
    }

    action Disengage on actor: Character () {
        cost { action }
        resolve {
            apply_condition(actor, Disengaging, Duration.end_of_turn)
        }
    }

    // --- Help action ---

    action Help on helper: Character (target: Character) {
        cost { action }
        requires { distance(helper.position, target.position) <= 5 }
        resolve {
            // PAIN POINT: Help grants advantage on the target's NEXT     [ttrpg_dsl-rh4]
            // ability check or attack roll — a "next use" duration.
            // Our Duration enum doesn't have a "next_use" variant;
            // we approximate with start_of_next_turn.
            apply_condition(target, Helped, Duration.start_of_next_turn)
        }
    }

    // --- Grapple (contested check as an action) ---

    action Grapple on grappler: Character (target: Character) {
        cost { action }
        // RESOLVED: Ordered enums + ordinal/from_ordinal enable size   [ttrpg_dsl-hpg]
        // comparison. target.size <= grappler.size + 1 means "at most
        // one size category larger than the grappler".
        requires {
            distance(grappler.position, target.position) <= 5
            && ordinal(target.size) <= ordinal(grappler.size) + 1
        }

        resolve {
            // RESOLVED: Typed prompt lets the defender choose their   [ttrpg_dsl-ctc]
            // contest skill. The host receives a Skill-typed prompt
            // and validates the response is actually a Skill value.
            let defender_skill = choose_contest_skill(
                target, [athletics, acrobatics]
            )
            let success = contested_check(
                grappler, athletics,
                target, defender_skill
            )
            if success {
                // RESOLVED: Duration.indefinite now works.            [ttrpg_dsl-d3r]
                apply_condition(target, Grappled, Duration.indefinite)
            }
        }
    }

    // --- Shove ---

    action Shove on shover: Character (target: Character) {
        cost { action }
        requires { distance(shover.position, target.position) <= 5 }

        resolve {
            // RESOLVED: Defender chooses contest skill via typed prompt [ttrpg_dsl-ctc]
            let defender_skill = choose_contest_skill(
                target, [athletics, acrobatics]
            )
            let success = contested_check(
                shover, athletics,
                target, defender_skill
            )
            if success {
                // RESOLVED: Typed enum prompt replaces string matching [ttrpg_dsl-ctc]
                let choice = choose_shove_outcome(shover)
                match choice {
                    knock_prone => {
                        apply_condition(target, Prone, Duration.indefinite)
                    },
                    push_away => {
                        // PAIN POINT: No position arithmetic.         [ttrpg_dsl-586]
                        // Can't express "move target 5 feet away from shover".
                    }
                }
            }
        }
    }

    // --- Healing (Cure Wounds) ---
    // RESOLVED: `with Spellcasting` constraint ensures only casters   [ttrpg_dsl-s43]
    // can use this action. dice() replaces the per-level match.       [ttrpg_dsl-7fv]

    action CureWounds on caster: Character with Spellcasting as sc (
        target: Character,
        slot_level: int
    ) {
        cost { action }
        requires { distance(caster.position, target.position) <= 5 && slot_level >= 1 }

        resolve {
            // RESOLVED: dice(count, sides) constructs dice dynamically.
            // No more 6-branch match for base dice.
            let healing_dice: DiceExpr = dice(slot_level, 8)
            // Spellcasting fields accessed directly via the group alias —
            // no more option<Ability> unwrapping needed.
            let spell_mod = modifier(
                caster.abilities[caster.sc.spellcasting_ability]
            )
            let healing = roll(healing_dice + spell_mod)
            target.HP += healing.total

            // RESOLVED: Resource-valued map replaces 9-branch match.   [ttrpg_dsl-5yt]
            caster.sc.spell_slots[slot_level] -= 1
        }
    }

    // --- Fireball (area damage spell) ---
    // RESOLVED: Three major improvements:
    //   - dice() replaces 7-branch match for base dice                [ttrpg_dsl-7fv]
    //   - for-loop applies damage to all targets (roll once, iterate) [ttrpg_dsl-dz3]
    //   - `with Spellcasting` ensures only casters can cast           [ttrpg_dsl-s43]
    //
    // The host (VTT) determines targets by AoE geometry and passes
    // the list. No DSL-level area targeting yet, but the "roll once,
    // apply many" pattern now works naturally with for-loops.

    action Fireball on caster: Character with Spellcasting as sc (
        targets: list<Character>,
        slot_level: int
    ) {
        cost { action }
        requires { slot_level >= 3 }

        resolve {
            let base_dice: DiceExpr = dice(5 + slot_level, 6)
            let damage_roll: RollResult = roll(base_dice)

            for target in targets {
                let save = saving_throw(
                    target, DEX, caster.sc.spell_save_DC
                )
                let raw_damage = match save {
                    success => floor(damage_roll.total / 2),
                    failure => damage_roll.total
                }
                let final_damage = apply_resistances(target, raw_damage, fire)
                target.HP -= final_damage
                emit takes_damage(
                    reactor: target,
                    source: caster,
                    amount: final_damage,
                    damage_type: fire
                )
            }

            // RESOLVED: Resource-valued map replaces 7-branch match.   [ttrpg_dsl-5yt]
            caster.sc.spell_slots[slot_level] -= 1
        }
    }

    // --- Second Wind (Fighter feature) ---
    // RESOLVED: `with FighterFeatures` replaces boolean flag check.   [ttrpg_dsl-s43]

    action SecondWind on fighter: Character with FighterFeatures as ff () {
        cost { bonus_action }
        requires { fighter.ff.second_wind_uses > 0 }

        resolve {
            let healing = roll(1d10 + fighter.level)
            fighter.HP += healing.total
            fighter.ff.second_wind_uses -= 1
        }
    }

    // --- Action Surge (Fighter feature) ---
    // RESOLVED: `cost free` explicitly declares no cost.              [ttrpg_dsl-xh9]
    // Previously omitting cost was ambiguous — now it's a clear signal.

    action ActionSurge on fighter: Character with FighterFeatures as ff () {
        cost free
        requires { fighter.ff.action_surge_uses > 0 }

        resolve {
            turn.actions += 1
            fighter.ff.action_surge_uses -= 1
        }
    }

    // --- Hide (used by Cunning Action below) ---

    action Hide on actor: Character () {
        cost { action }
        resolve {
            // PAIN POINT: Stealth check DC depends on observer perception —
            // simplified here as a state flag.
            apply_condition(actor, Hidden, Duration.indefinite)
        }
    }


    // ========================================================
    //  EVENTS
    // ========================================================

    // RESOLVED: turn_start / turn_end events enable hooks.            [ttrpg_dsl-pzy]
    event turn_start(actor: Character) {}

    event turn_end(actor: Character) {}

    event entity_leaves_reach(reactor: Character) {
        entity: Character
        from_position: Position
        to_position: Position
    }

    // RESOLVED: With emit, event params are passed directly from DSL code,
    // so data fields move from body to header for emit compatibility.
    event takes_damage(
        reactor: Character,
        source: Character,
        amount: int,
        damage_type: DamageType
    ) {}

    // PARTIALLY RESOLVED: `emit` statement lets DSL code fire events  [ttrpg_dsl-clo]
    // inline (see Attack/Fireball above). The host no longer needs to
    // fire takes_damage manually. Remaining gap: HP mutations don't
    // auto-emit events — the DSL author must write `emit` explicitly.


    // ========================================================
    //  HOOKS (automatic turn-phase triggers)
    // ========================================================

    // RESOLVED: Hooks replace the awkward DeathSave action.           [ttrpg_dsl-pzy]
    // Death saves now fire automatically at turn start for any
    // character at 0 HP — no need to spend an action.

    hook DeathSaveCheck on dying: Character (
        trigger: turn_start(actor: dying)
    ) {
        if dying.HP == 0 {
            let result = roll(1d20)
            match {
                result.total == 20 => {
                    // Nat 20: regain 1 HP, reset counters
                    dying.HP += 1
                    dying.death_save_successes = 0
                    dying.death_save_failures = 0
                },
                result.total >= 10 => {
                    dying.death_save_successes += 1
                    if dying.death_save_successes >= 3 {
                        apply_condition(dying, Stable, Duration.indefinite)
                    }
                },
                result.total == 1 => {
                    // Nat 1: two failures
                    dying.death_save_failures += 2
                },
                _ => {
                    dying.death_save_failures += 1
                }
            }
            // 3 failures = death
            // PAIN POINT: "Death" is permanent removal of the entity.  [ttrpg_dsl-bcc]
            // The DSL has no concept of destroying entities.
            //     if dying.death_save_failures >= 3 { destroy(dying) }
        }
    }


    // ========================================================
    //  REACTIONS
    // ========================================================

    reaction OpportunityAttack on reactor: Character (
        trigger: entity_leaves_reach(reactor: reactor)
    ) {
        cost { reaction }

        resolve {
            let result = resolve_melee_attack(
                reactor, trigger.entity, reactor.equipped_weapon
            )
            match result {
                hit(amount) => {
                    trigger.entity.HP -= amount
                    // NOTE: emit is only allowed in action context, so reactions
                    // still rely on the host to fire takes_damage events.
                },
                miss => {}
            }
        }
    }

    // Concentration check when taking damage
    reaction ConcentrationCheck on caster: Character (
        trigger: takes_damage(reactor: caster)
    ) {
        // RESOLVED: option checking now possible with if-let.         [ttrpg_dsl-zq1]
        // Could write: requires { if let some(_) = caster.Spellcasting.concentrating_on { true } else { false } }
        // With optional groups, concentration lives in Spellcasting —
        // this reaction only makes sense for casters.
        cost { reaction }

        resolve {
            // Only check if actually concentrating
            if caster has Spellcasting as sc {
                if let some(_) = caster.sc.concentrating_on {
                    let dc = concentration_check_DC(trigger.amount)
                    let save = saving_throw(caster, CON, dc)
                    match save {
                        failure => {
                            caster.sc.concentrating_on = none
                            // PAIN POINT: Dropping concentration should remove  [ttrpg_dsl-5kb]
                            // the spell's effects. No "spell instance" concept.
                        },
                        success => {}
                    }
                }
            }
        }
    }


    // ========================================================
    //  CONDITIONS
    // ========================================================

    condition Prone on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = disadvantage
        }
        modify attack_roll(target: bearer) {
            mode = if distance(attacker.position, bearer.position) <= 5 {
                advantage
            } else {
                disadvantage
            }
        }
        modify initial_budget(actor: bearer) {
            result.movement = result.movement - floor(bearer.speed / 2)
        }
    }

    condition Dodging on bearer: Character {
        modify attack_roll(target: bearer) {
            mode = disadvantage
        }
        modify saving_throw(target: bearer, ability: DEX) {
            mode = advantage
        }
    }

    condition Disengaging on bearer: Character {
        suppress entity_leaves_reach(entity: bearer)
    }

    // RESOLVED: Selector-targeted modify replaces per-mechanic listing. [ttrpg_dsl-wus]
    // `modify [#attack]` targets all mechanics tagged #attack. Different
    // parameter names (attacker vs actor) require separate clauses, but
    // adding a new attack mechanic is now automatically covered.
    condition Helped on bearer: Character {
        modify [#attack](attacker: bearer) {
            mode = advantage
        }
        modify skill_check(actor: bearer) {
            mode = advantage
        }
    }

    condition Grappled on bearer: Character {
        modify initial_budget(actor: bearer) {
            result.movement = 0
        }
        // PAIN POINT: Grappled also means the grappler's speed is 0.
        // A condition applies to ONE bearer — would need a simultaneous
        // "Grappling" condition on the grappler.
    }

    condition Frightened(source: Character) on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = disadvantage
        }
        modify skill_check(actor: bearer) {
            mode = disadvantage
        }
        // RESOLVED: Parameterized conditions now allow expressing
        // "can't willingly move closer to the source of fear":
        //     suppress move_toward(entity: bearer, target: source)
        // (Requires move_toward event definition — not yet in this example)
    }

    condition Poisoned on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = disadvantage
        }
        modify skill_check(actor: bearer) {
            mode = disadvantage
        }
    }

    condition Incapacitated on bearer: Character {
        modify initial_budget(actor: bearer) {
            result.actions = 0
            result.bonus_actions = 0
            result.reactions = 0
        }
    }

    condition Blinded on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = disadvantage
        }
        modify attack_roll(target: bearer) {
            mode = advantage
        }
        // PAIN POINT: Blinded also means auto-fail any check requiring
        // sight. "Requires sight" is a narrative concept, not a
        // mechanical tag on skill_check.
    }

    condition Hidden on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = advantage
        }
    }

    condition Invisible on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = advantage
        }
        modify attack_roll(target: bearer) {
            mode = disadvantage
        }
    }

    condition Restrained on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = disadvantage
        }
        modify attack_roll(target: bearer) {
            mode = advantage
        }
        modify saving_throw(target: bearer, ability: DEX) {
            mode = disadvantage
        }
        modify initial_budget(actor: bearer) {
            result.movement = 0
        }
    }

    condition Stunned extends Incapacitated on bearer: Character {
        // RESOLVED: auto_fail bypasses the roll entirely.              [ttrpg_dsl-34x]
        modify attack_roll(target: bearer) {
            mode = advantage
        }
        modify initial_budget(actor: bearer) {
            result.movement = 0
        }
        modify saving_throw(target: bearer, ability: STR) {
            mode = auto_fail
        }
        modify saving_throw(target: bearer, ability: DEX) {
            mode = auto_fail
        }
    }

    // Stable (stabilized at 0 HP, no longer making death saves)
    condition Stable on bearer: Character {
        // PAIN POINT: Stable doesn't modify any mechanics — it's
        // purely a state flag that the turn-start hook checks.
        // A condition with no clauses is valid but feels like misuse.
    }

    // --- Cost overrides ---
    // RESOLVED: modify Action.cost(...) replaces duplicated actions.  [ttrpg_dsl-xh9]
    // CunningAction is now a condition that overrides cost, not three
    // separate CunningDash/CunningDisengage/CunningHide actions.

    condition CunningAction on bearer: Character {
        modify Dash.cost(actor: bearer) {
            cost = bonus_action
        }
        modify Disengage.cost(actor: bearer) {
            cost = bonus_action
        }
        modify Hide.cost(actor: bearer) {
            cost = bonus_action
        }
    }


    // ========================================================
    //  OPTIONS (variant rules)
    // ========================================================

    option flanking extends "D&D 5e Expanded" {
        description: "Melee attackers on opposite sides gain advantage"
        default: off

        when enabled {
            modify [#attack](attacker: _, target: _) {
                // PAIN POINT: Detecting "opposite sides" requires       [ttrpg_dsl-586]
                // geometric Position calculations the DSL can't express.
                mode = advantage
            }
        }
    }

    option critical_fumble extends "D&D 5e Expanded" {
        description: "Natural 1 on attack roll causes a fumble effect"
        default: off

        when enabled {
            // The modify system modifies INPUT parameters, not control
            // flow. Can't add new branches to resolve_melee_attack.
        }
    }


    // ========================================================
    //  PAIN POINT SUMMARY
    // ========================================================
    //
    //  RESOLVED language gaps (no longer pain points):
    //
    //  [RESOLVED] LOOPS / ITERATION                               [ttrpg_dsl-dz3]
    //    - for x in list { ... } and for i in 0..n { ... }
    //    - Extra Attack now uses for-loop over target list
    //    - Fireball rolls once, iterates over targets
    //    - Multi-damage-type spells can iterate DamageSpec lists
    //
    //  [RESOLVED] ENTITY COMPOSITION / OPTIONAL GROUPS            [ttrpg_dsl-s43]
    //    - optional Spellcasting { ... } / FighterFeatures / RogueFeatures
    //    - `with ... as` constraints on actions (only casters can cast)
    //    - `has ... as` checks in mechanics and derives
    //    - `as` aliases shorten repeated group paths (sc, ff, rf)
    //    - grant / revoke for lifecycle management
    //    - Character entity is much leaner
    //
    //  [RESOLVED] DYNAMIC DICE CONSTRUCTION                       [ttrpg_dsl-7fv]
    //    - dice(count, sides) builds DiceExpr at runtime
    //    - CureWounds: dice(slot_level, 8) replaces 6-branch match
    //    - Fireball: dice(5 + slot_level, 6) replaces 7-branch match
    //
    //  [RESOLVED] OPTION<T> SUPPORT                               [ttrpg_dsl-zq1]
    //    - some(x) / none pattern matching
    //    - .unwrap() and .unwrap_or(default) methods
    //    - if let some(x) = expr { ... } else { ... }
    //    - compute_AC uses if-let for nested option handling
    //    - ConcentrationCheck uses if-let for option<string> check
    //
    //  [RESOLVED] DURATION TYPES                                  [ttrpg_dsl-d3r]
    //    - Ruleset-customizable enum with any variants needed
    //    - Duration.indefinite works for Grappled, Prone, Stable
    //    - Duration.rounds(n), Duration.hours(n) etc. available
    //    (Remaining gap: no "next use" or "until save" durations)
    //
    //  [RESOLVED] TURN PHASE HOOKS                                [ttrpg_dsl-pzy]
    //    - hook Name on receiver (trigger: event) { ... }
    //    - DeathSaveCheck fires automatically at turn_start
    //    - No longer need DeathSave as an action costing an action
    //
    //  [RESOLVED] RESOURCE-VALUED MAPS                            [ttrpg_dsl-5yt]
    //    - map<int, resource(0..=9)> replaces 9 separate spell_slots fields
    //    - spell_slots[slot_level] -= 1 replaces 9-branch match
    //    - Resource bounds auto-clamp (can't go below 0 or above 9)
    //
    //  [RESOLVED] ORDERED ENUMS                                  [ttrpg_dsl-hpg]
    //    - `enum Size ordered { ... }` — opt-in declaration-order comparison
    //    - ordinal(variant) -> int, from_ordinal(Type, int) -> variant
    //    - try_from_ordinal(Type, int) -> option<variant> (safe version)
    //    - Grapple requires block uses ordinal() for size comparison
    //
    //  [RESOLVED] Parser / syntax issues:
    //    - `none` is a valid match pattern                        [ttrpg_dsl-efg]
    //    - Wildcard `_` works in modify bindings                  [ttrpg_dsl-9ng]
    //    - Multiline requires/cost blocks work                    [ttrpg_dsl-hwf]
    //    - Comments between cost/requires blocks work             [ttrpg_dsl-c2y]
    //
    //
    //  RESOLVED language gaps (continued):
    //
    //  [RESOLVED] PARAMETERIZED CONDITIONS                        [ttrpg_dsl-iuw]
    //     - Frightened(source: Character), Exhaustion(level: int), etc.
    //     - Condition params accessible in modify/suppress clause bodies
    //     - Targeted removal: remove_condition(target, Frightened(source: x))
    //
    //  [RESOLVED] COST OVERRIDES / FREE ACTIONS                  [ttrpg_dsl-xh9]
    //     - `cost free` explicitly declares no-cost actions (ActionSurge)
    //     - `modify Action.cost(...)` overrides action cost from conditions
    //     - CunningAction condition replaces CunningDash/CunningDisengage duplicates
    //     - Cunning Action: modify Dash.cost / Disengage.cost / Hide.cost
    //
    //  [RESOLVED] TAGS AND SELECTOR-TARGETED MODIFY               [ttrpg_dsl-wus]
    //     - `tag d20_roll` / `tag attack` — named function categories
    //     - `mechanic attack_roll(...) #d20_roll #attack { ... }`
    //     - `modify [#attack](attacker: bearer) { ... }` — target by tag
    //     - `modify [#attack, has attacker](attacker: bearer)` — AND predicates
    //     - Structural selectors: `returns T`, `has param: T`, `has param`
    //     - Checker validates bindings against ALL matched functions
    //     - New attack mechanics automatically covered by existing conditions
    //
    //  [RESOLVED] EMIT STATEMENT FOR INLINE EVENT FIRING          [ttrpg_dsl-wbic]
    //     - `emit EventName(param: expr, ...)` fires events from DSL code
    //     - Matching hooks auto-execute inline at the emit site
    //     - Attack/Fireball now emit takes_damage after HP mutation
    //     - Host no longer needs to manually fire events for actions
    //     (Remaining gap: mutations don't auto-emit — emit is explicit;
    //      emit restricted to action context — reactions still need host)
    //
    //  [RESOLVED] TOP-LEVEL GROUPS AND INCLUDE                    [ttrpg_dsl-zzx4]
    //     - `group Name { ... }` as top-level declaration
    //     - `include GroupName` in entities (required, always-present)
    //     - `optional GroupName` in entities (external reference)
    //     - Cross-entity group sharing (same group on Character + Monster)
    //
    //  [RESOLVED] TYPED PROMPTS                                    [ttrpg_dsl-ctc]
    //     - Prompts carry return_type and named params through effects
    //     - Host knows expected return type (Character, Skill, enum, etc.)
    //     - Interpreter validates response matches declared type
    //     - choose_target -> Character replaces string-based entity selection
    //     - choose_contest_skill -> Skill enables mid-mechanic decisions
    //     - choose_shove_outcome -> ShoveChoice replaces string matching
    //
    //
    //  REMAINING language gaps:
    //
    //  1. [RESOLVED] CONDITION COMPOSITION / INHERITANCE           [ttrpg_dsl-7r4]
    //     - `condition Stunned extends Incapacitated on bearer: Character { ... }`
    //     - Child inherits all modify/suppress clauses from parents
    //
    //  2. NO AUTO-SUCCEED / AUTO-FAIL                             [ttrpg_dsl-34x]
    //     - Stunned auto-fails STR/DEX saves (not just disadvantage)
    //     - "Advantage/disadvantage" is the only roll modifier
    //
    //  3. NO FULLY AUTOMATIC EVENT EMISSION                       [ttrpg_dsl-clo]
    //     - `emit` solves manual host-side firing (see [RESOLVED] above)
    //     - Remaining: HP mutations don't auto-emit — DSL author writes emit
    //     - Would want: `HP: resource(...) { on_decrease => emit ... }`
    //
    //  4. NO POSITION ARITHMETIC                                  [ttrpg_dsl-586]
    //     - Can't compute "5 feet away from X toward Y"
    //     - Can't check "is between A and B" (flanking)
    //     - Position is opaque — only distance() is available
    //
    //  5. [RESOLVED] UNION TYPES                                  [ttrpg_dsl-q5l]
    //     - Entity refs: `entity with GroupName` for constrained polymorphism
    //     - Non-entity: enum payloads (DamageSource { weapon(...), spell(...) })
    //
    //  6. SINGLE REQUIRES BLOCK PER ACTION                        [ttrpg_dsl-mcy]
    //     - Must combine with && (multiline works, but verbose)
    //
    //  7. RESOLVED: DiceExpr fields can use 0d6 default            [ttrpg_dsl-46i]
    //
    //  8. NO STRUCT UPDATE SYNTAX                                 [ttrpg_dsl-kmy]
    //     - Must reconstruct entire struct to change one field
    //
    //  9. NO LIST SORTING / MAP / FILTER / REDUCE                 [ttrpg_dsl-4km]
    //     - Host must sort initiative; no ordered collection output
    //
    // 10. NO ENTITY DESTRUCTION / LIFECYCLE                       [ttrpg_dsl-bcc]
    //     - Can't destroy(dying) — death removes entities permanently
    //
    // 11. NO ENUM-ASSOCIATED DATA / LOOKUP TABLES                 [ttrpg_dsl-8tu]
    //     - skill_ability is 18-branch match for static data
    //
    // 12. NO EVENT-TRIGGERED DURATIONS                            [ttrpg_dsl-rh4]
    //     - "Until next use" (Help) and "until save" (spell effects)
    //
    // 13. NO SPELL INSTANCE / EFFECT TRACKING                     [ttrpg_dsl-5kb]
    //     - Dropping concentration can't auto-remove spell effects
    //
    // 14. NO INTEGER RANGE / BOUNDED INT TYPES                    [ttrpg_dsl-3v8]
    //     - Can't express int(1..9) for spell slot levels
}
