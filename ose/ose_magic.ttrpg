// ============================================================
// OSE Magic & Turn Undead — spell slots and turning mechanics
//
// Spell slots: 2D table lookup (SpellProgression × level → list<int>).
// 9 progression categories × up to 14 levels.
// Each entry is a 6-element list: slots for spell levels 1–6.
//
// Turn undead: algorithmic derive based on cleric_level − undead_rank.
// Follows the diagonal pattern from OSE Reference Booklet p18.
//
// Reference: oag/src/rules/spell.rs (spell progressions),
//            oag/src/rules/turn.rs (turn undead formula).
// ============================================================

use "OSE"

system "OSE Magic" {

    // ========================================================
    //  SPELL SLOT TABLE
    //
    //  2D lookup: (SpellProgression, level) → list<int>
    //  Returns a 6-element list of spell slots for levels 1–6.
    //  A 0 means no spells of that level available.
    //
    //  OSE Reference Booklet p16-17.
    // ========================================================

    table spell_slots(progression: SpellProgression, level: int) -> list<int> {

        // --- NonCaster (Fighter, Thief, etc.) ---
        // No spells at any level.
        [NonCaster, _] => [0, 0, 0, 0, 0, 0],

        // --- Bard: druid spell list, up to 4th level spells ---
        [SpellProgression.Bard, 1]       => [0, 0, 0, 0, 0, 0],
        [SpellProgression.Bard, 2]       => [1, 0, 0, 0, 0, 0],
        [SpellProgression.Bard, 3]       => [2, 0, 0, 0, 0, 0],
        [SpellProgression.Bard, 4]       => [3, 0, 0, 0, 0, 0],
        [SpellProgression.Bard, 5]       => [3, 1, 0, 0, 0, 0],
        [SpellProgression.Bard, 6]       => [3, 2, 0, 0, 0, 0],
        [SpellProgression.Bard, 7]       => [3, 3, 0, 0, 0, 0],
        [SpellProgression.Bard, 8]       => [3, 3, 1, 0, 0, 0],
        [SpellProgression.Bard, 9]       => [3, 3, 2, 0, 0, 0],
        [SpellProgression.Bard, 10]      => [3, 3, 3, 0, 0, 0],
        [SpellProgression.Bard, 11]      => [3, 3, 3, 1, 0, 0],
        [SpellProgression.Bard, 12]      => [3, 3, 3, 2, 0, 0],
        [SpellProgression.Bard, 13]      => [3, 3, 3, 3, 0, 0],
        [SpellProgression.Bard, 14]      => [4, 4, 3, 3, 0, 0],

        // --- Cleric: cleric spell list, up to 5th level spells ---
        [SpellProgression.Cleric, 1]     => [0, 0, 0, 0, 0, 0],
        [SpellProgression.Cleric, 2]     => [1, 0, 0, 0, 0, 0],
        [SpellProgression.Cleric, 3]     => [2, 0, 0, 0, 0, 0],
        [SpellProgression.Cleric, 4]     => [2, 1, 0, 0, 0, 0],
        [SpellProgression.Cleric, 5]     => [2, 2, 0, 0, 0, 0],
        [SpellProgression.Cleric, 6]     => [2, 2, 1, 1, 0, 0],
        [SpellProgression.Cleric, 7]     => [2, 2, 2, 1, 1, 0],
        [SpellProgression.Cleric, 8]     => [3, 3, 2, 2, 1, 0],
        [SpellProgression.Cleric, 9]     => [3, 3, 3, 2, 2, 0],
        [SpellProgression.Cleric, 10]    => [4, 4, 3, 3, 2, 0],
        [SpellProgression.Cleric, 11]    => [4, 4, 4, 3, 3, 0],
        [SpellProgression.Cleric, 12]    => [5, 5, 4, 4, 3, 0],
        [SpellProgression.Cleric, 13]    => [5, 5, 5, 4, 4, 0],
        [SpellProgression.Cleric, 14]    => [6, 5, 5, 5, 4, 0],

        // --- Drow: arcane+divine spell list, up to 5th level spells ---
        [SpellProgression.Drow, 1]       => [1, 0, 0, 0, 0, 0],
        [SpellProgression.Drow, 2]       => [2, 0, 0, 0, 0, 0],
        [SpellProgression.Drow, 3]       => [2, 1, 0, 0, 0, 0],
        [SpellProgression.Drow, 4]       => [2, 2, 0, 0, 0, 0],
        [SpellProgression.Drow, 5]       => [2, 2, 1, 0, 0, 0],
        [SpellProgression.Drow, 6]       => [2, 2, 2, 1, 0, 0],
        [SpellProgression.Drow, 7]       => [3, 3, 2, 2, 1, 0],
        [SpellProgression.Drow, 8]       => [3, 3, 3, 2, 2, 0],
        [SpellProgression.Drow, 9]       => [4, 4, 3, 3, 2, 0],
        [SpellProgression.Drow, 10]      => [4, 4, 4, 3, 3, 0],

        // --- Druid: druid spell list, up to 5th level spells ---
        [SpellProgression.Druid, 1]      => [1, 0, 0, 0, 0, 0],
        [SpellProgression.Druid, 2]      => [2, 0, 0, 0, 0, 0],
        [SpellProgression.Druid, 3]      => [2, 1, 0, 0, 0, 0],
        [SpellProgression.Druid, 4]      => [2, 2, 0, 0, 0, 0],
        [SpellProgression.Druid, 5]      => [2, 2, 1, 1, 0, 0],
        [SpellProgression.Druid, 6]      => [2, 2, 2, 1, 1, 0],
        [SpellProgression.Druid, 7]      => [3, 3, 2, 2, 1, 0],
        [SpellProgression.Druid, 8]      => [3, 3, 3, 2, 2, 0],
        [SpellProgression.Druid, 9]      => [4, 4, 3, 3, 2, 0],
        [SpellProgression.Druid, 10]     => [4, 4, 4, 3, 3, 0],
        [SpellProgression.Druid, 11]     => [5, 5, 4, 4, 3, 0],
        [SpellProgression.Druid, 12]     => [5, 5, 5, 4, 4, 0],
        [SpellProgression.Druid, 13]     => [6, 5, 5, 5, 4, 0],
        [SpellProgression.Druid, 14]     => [6, 6, 5, 5, 5, 0],

        // --- Arcane Full Caster (Elf, Gnome, Illusionist, Magic-User) ---
        // Up to 6th level spells.
        [ArcaneFull, 1]  => [1, 0, 0, 0, 0, 0],
        [ArcaneFull, 2]  => [2, 0, 0, 0, 0, 0],
        [ArcaneFull, 3]  => [2, 1, 0, 0, 0, 0],
        [ArcaneFull, 4]  => [2, 2, 0, 0, 0, 0],
        [ArcaneFull, 5]  => [2, 2, 1, 0, 0, 0],
        [ArcaneFull, 6]  => [2, 2, 2, 0, 0, 0],
        [ArcaneFull, 7]  => [3, 2, 2, 1, 0, 0],
        [ArcaneFull, 8]  => [3, 3, 2, 2, 0, 0],
        [ArcaneFull, 9]  => [3, 3, 3, 2, 1, 0],
        [ArcaneFull, 10] => [3, 3, 3, 3, 2, 0],
        [ArcaneFull, 11] => [4, 3, 3, 3, 2, 1],
        [ArcaneFull, 12] => [4, 4, 3, 3, 3, 2],
        [ArcaneFull, 13] => [4, 4, 4, 3, 3, 3],
        [ArcaneFull, 14] => [4, 4, 4, 4, 3, 3],

        // --- Half-Elf: magic-user spell list, up to 4th level spells ---
        [SpellProgression.HalfElf, 1]   => [0, 0, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 2]   => [1, 0, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 3]   => [2, 0, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 4]   => [2, 0, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 5]   => [2, 1, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 6]   => [2, 2, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 7]   => [2, 2, 0, 0, 0, 0],
        [SpellProgression.HalfElf, 8]   => [2, 2, 1, 0, 0, 0],
        [SpellProgression.HalfElf, 9]   => [3, 2, 1, 0, 0, 0],
        [SpellProgression.HalfElf, 10]  => [3, 2, 2, 0, 0, 0],
        [SpellProgression.HalfElf, 11]  => [3, 2, 2, 1, 0, 0],
        [SpellProgression.HalfElf, 12]  => [3, 3, 2, 1, 0, 0],

        // --- Paladin: cleric spell list, up to 3rd level spells ---
        // No spells until level 9.
        [SpellProgression.Paladin, 1..=8]  => [0, 0, 0, 0, 0, 0],
        [SpellProgression.Paladin, 9]      => [1, 0, 0, 0, 0, 0],
        [SpellProgression.Paladin, 10]     => [2, 0, 0, 0, 0, 0],
        [SpellProgression.Paladin, 11]     => [2, 1, 0, 0, 0, 0],
        [SpellProgression.Paladin, 12]     => [2, 2, 0, 0, 0, 0],
        [SpellProgression.Paladin, 13]     => [2, 2, 1, 0, 0, 0],
        [SpellProgression.Paladin, 14]     => [3, 2, 1, 0, 0, 0],

        // --- Ranger: druid spell list, up to 3rd level spells ---
        // No spells until level 8.
        [SpellProgression.Ranger, 1..=7]   => [0, 0, 0, 0, 0, 0],
        [SpellProgression.Ranger, 8]       => [1, 0, 0, 0, 0, 0],
        [SpellProgression.Ranger, 9]       => [2, 0, 0, 0, 0, 0],
        [SpellProgression.Ranger, 10]      => [2, 1, 0, 0, 0, 0],
        [SpellProgression.Ranger, 11]      => [2, 2, 0, 0, 0, 0],
        [SpellProgression.Ranger, 12]      => [2, 2, 1, 0, 0, 0],
        [SpellProgression.Ranger, 13]      => [3, 2, 1, 0, 0, 0],
        [SpellProgression.Ranger, 14]      => [3, 2, 2, 0, 0, 0]
    }


    // ========================================================
    //  SPELL SLOT DERIVES
    // ========================================================

    // Check if a class has any spell slots at a given level.
    derive can_cast(progression: SpellProgression, level: int) -> bool {
        let slots = spell_slots(progression, level)
        slots[0] > 0 || slots[1] > 0 || slots[2] > 0 ||
        slots[3] > 0 || slots[4] > 0 || slots[5] > 0
    }

    // Total number of spell slots across all spell levels.
    derive total_spell_slots(progression: SpellProgression, level: int) -> int {
        let slots = spell_slots(progression, level)
        slots[0] + slots[1] + slots[2] + slots[3] + slots[4] + slots[5]
    }


    // ========================================================
    //  CASTING RESOURCE DERIVES
    //
    //  DSL-driven casting validation. Abstracts the resource
    //  model so different game systems can use Vancian slots,
    //  spell points, or spontaneous casting.
    //
    //  OSE uses Vancian slots: each cast consumes exactly 1
    //  slot at the spell's level.
    // ========================================================

    // Casting resource types.
    enum CastingResource { vancian_slots, spell_points, spontaneous_slots }

    // Returns the casting resource type for this game system.
    derive casting_resource_type(progression: SpellProgression) -> CastingResource {
        match progression {
            _ => vancian_slots
        }
    }

    // Check if a character can cast a spell at a given spell level,
    // considering their current slot usage vs maximum slots.
    derive can_cast_spell(resource_type: CastingResource, slots_used: list<int>, max_slots: list<int>, spell_level: int) -> bool {
        match resource_type {
            vancian_slots => slots_used[spell_level - 1] < max_slots[spell_level - 1],
            spell_points => slots_used[0] + spell_point_cost(spell_level) <= max_slots[0],
            spontaneous_slots => {
                // Check if any slot at spell_level or higher is available
                let idx = spell_level - 1
                let found = match {
                    idx <= 0 && max_slots[0] > slots_used[0] => true,
                    idx <= 1 && max_slots[1] > slots_used[1] => true,
                    idx <= 2 && max_slots[2] > slots_used[2] => true,
                    idx <= 3 && max_slots[3] > slots_used[3] => true,
                    idx <= 4 && max_slots[4] > slots_used[4] => true,
                    idx <= 5 && max_slots[5] > slots_used[5] => true,
                    _ => false
                }
                found
            }
        }
    }

    // Returns the cost in resources to cast a spell of the given level.
    derive cast_cost(resource_type: CastingResource, spell_level: int) -> int {
        match resource_type {
            vancian_slots => 1,
            spell_points => spell_point_cost(spell_level),
            spontaneous_slots => 1
        }
    }

    // Spell point cost by spell level.
    derive spell_point_cost(spell_level: int) -> int {
        match spell_level {
            1 => 2,
            2 => 3,
            3 => 5,
            4 => 6,
            5 => 7,
            6 => 9,
            _ => 0
        }
    }

    // Rest recovery: determines what happens to casting resources on long rest.
    derive rest_recovery(resource_type: CastingResource) -> bool {
        match resource_type {
            _ => true
        }
    }


    // ========================================================
    //  TURN UNDEAD
    //
    //  Algorithmic: result depends on (cleric_level − undead_rank).
    //  Follows the diagonal pattern from OSE Reference Booklet p18.
    //
    //  Undead ranks (1–9):
    //    1=Skeleton  2=Zombie  3=Ghoul   4=Wight   5=Wraith
    //    6=Mummy     7=Spectre 8=Vampire 9=Infernal (9+ HD)
    //
    //  diff ≤ -3: Impossible
    //  diff = -2: Roll(11) — need 11+ on 2d6
    //  diff = -1: Roll(9)  — need 9+ on 2d6
    //  diff =  0: Roll(7)  — need 7+ on 2d6
    //  diff 1–2:  Turned   — automatic turn
    //  diff ≥ 3:  Destroyed — automatic destroy
    // ========================================================

    // Convert undead Hit Dice to a turn undead rank (1–9).
    // HD 1–8 map directly; HD 9+ all map to rank 9.
    derive undead_rank_from_hd(hd: int) -> int {
        match {
            hd < 1 => 1,
            hd > 9 => 9,
            _      => hd
        }
    }

    // Look up the turn undead result for a given cleric level and undead rank.
    derive turn_undead_result(cleric_level: int, undead_rank: int) -> TurnResult {
        let rank = match {
            undead_rank < 1 => 1,
            undead_rank > 9 => 9,
            _               => undead_rank
        }
        let diff = cleric_level - rank
        match {
            diff <= -3 => TurnResult.Impossible,
            diff == -2 => TurnResult.Roll(11),
            diff == -1 => TurnResult.Roll(9),
            diff == 0  => TurnResult.Roll(7),
            diff <= 2  => TurnResult.Turned,
            _          => TurnResult.Destroyed
        }
    }

    // Orchestrate a full turn undead attempt.
    //
    // Determines undead rank from HD, looks up the turn table result, rolls
    // 2d6 for success if needed, rolls 2d6 for HD affected on success.
    //
    // cleric_level: the cleric's character level (1+)
    // undead_hd:    hit dice of the target undead type (determines rank)
    //
    // Returns TurnAttempt encoding the full outcome so the caller can apply
    // state changes (marking monsters turned/destroyed) and build log messages.
    mechanic turn_undead_attempt(cleric_level: int, undead_hd: int) -> TurnAttempt {
        let rank = undead_rank_from_hd(undead_hd)
        let table = turn_undead_result(cleric_level, rank)
        match table {
            TurnResult.Impossible => TurnAttempt.Impossible,
            Roll(target) => {
                let r = roll(2d6)
                if r.total >= target {
                    let hd = roll(2d6)
                    TurnAttempt.Rolled(r.total, target, hd.total)
                } else {
                    TurnAttempt.Failed(r.total, target)
                }
            },
            TurnResult.Turned => {
                let hd = roll(2d6)
                TurnAttempt.Auto(hd.total)
            },
            TurnResult.Destroyed => {
                let hd = roll(2d6)
                TurnAttempt.Destroy(hd.total)
            }
        }
    }
}
