{"id":"ttrpg_dsl-002","title":"Add .unwrap() / .unwrap_or(default) methods on option values","description":"Allow calling .unwrap() to extract the inner value (runtime error if none) and .unwrap_or(default) to provide a fallback. Useful for cases where match is too verbose.","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:51:26Z","closed_at":"2026-02-22T18:51:26Z","close_reason":"Implemented .unwrap() and .unwrap_or(default) methods on option values"}
{"id":"ttrpg_dsl-04h","title":"Add for-loop tests for side effects and error-path scope cleanup","description":"Existing for-loop tests mostly validate return values. Need tests for: loop body side effects, scope cleanup on body error.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:10Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-09t","title":"Field/group name collisions allowed in optional groups","description":"collect.rs tracks entity fields and optional groups in separate duplicate sets, so an entity can have both a field and an optional group with the same name (e.g. Spellcasting). The checker resolves entity.Spellcasting as an optional group before normal fields, while runtime has/field reads use raw field names — creating ambiguous/incorrect behavior. Fix: make field names and optional-group names disjoint per entity during collection.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:30Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:28:34Z","closed_at":"2026-02-23T04:28:34Z","close_reason":"Added cross-check in collect_entity() to detect field/group name collisions"}
{"id":"ttrpg_dsl-0ch","title":"Resource bound evaluation is fail-open for complex expressions","description":"Bounds parse as full expressions (parser/types.rs:64-66), but runtime fallback only handles bare identifiers (eval.rs:2029). If evaluation fails, resolution returns None via ? (eval.rs:2055-2056) and assignment proceeds without bounds. Checker also does not validate bound expressions (env.rs:178). Bounds like resource(0..max_slots + 1) silently disable clamping.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:53:17Z","closed_at":"2026-02-23T18:53:17Z","close_reason":"Fixed in eval.rs: local-to-entity path now calls resolve_resource_bounds; eval_bound_expr now injects entity fields into temp scope for complex expressions"}
{"id":"ttrpg_dsl-1wn","title":"GameState: auto-initialize missing resource map keys to min","description":"When reading a map\u003cK, resource(min..max)\u003e entry with a missing key, return min instead of erroring. When writing a missing key, auto-create the entry with the operation applied, then clamp. Modify read path (read_field or eval_index) and write path (write_nested) in reference_state.rs. Needs access to the resource min bound expression for the default.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:53Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:23:18Z","closed_at":"2026-02-23T18:23:18Z","close_reason":"Auto-initialization for writes already works via the adapter: compute_field_value defaults missing paths to Int(0), applies the operation, then clamps with resource bounds. With bounds now populated (from m2n), this auto-inits correctly. For reads, missing keys still error — users should initialize maps at spawn time. Test: resource_map_write_to_missing_key_auto_initializes verifies += on absent key creates the entry.","dependencies":[{"issue_id":"ttrpg_dsl-1wn","depends_on_id":"ttrpg_dsl-chb","type":"blocks","created_at":"2026-02-23T09:38:03Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-34x","title":"Language: auto-succeed / auto-fail modifier for rolls","description":"The modify system only supports advantage/disadvantage as roll modifiers. In 5e, several conditions cause auto-failure on certain saves:\n- Stunned: auto-fail STR and DEX saves\n- Paralyzed: auto-fail STR and DEX saves\n- Petrified: auto-fail STR and DEX saves\n\nThe modify clause can set mode=disadvantage but cannot express 'the result is always failure'. Need either:\n- A new RollMode variant: `enum RollMode { normal, advantage, disadvantage, auto_fail, auto_succeed }`\n- Or the ability to override the result directly in a post-call modify:\n    `modify saving_throw(target: bearer) { result = SaveResult.failure }`","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-3v8","title":"Language: integer range / bounded int types","description":"Can't express constrained integer types like int(1..9) for spell slot levels. Plain int accepts any value — no compile-time or runtime range enforcement beyond manual checks. Would help with spell levels, ability scores (typically 1-30), proficiency multipliers, etc.","status":"open","priority":4,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:55Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:55Z"}
{"id":"ttrpg_dsl-46i","title":"Language: no default/zero value for DiceExpr fields","description":"Can't write sneak_attack_dice: DiceExpr = 0d6 because 0d6 isn't a valid dice literal (0 count). There's no 'empty dice expression' value. This forces workarounds like option\u003cDiceExpr\u003e or separate boolean flags for features that may not have dice. See pain point #20 in examples/dnd5e_expanded.ttrpg.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:51:01Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:51:01Z"}
{"id":"ttrpg_dsl-4km","title":"Language: list sorting, map, filter, reduce","description":"The DSL has for-loops for iteration but no way to produce transformed or ordered collections. Initiative sorting, filtering targets by condition, mapping over lists — all must be done by the host. Would need builtins like sort(), filter(), map() or list comprehensions.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:42Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:42Z"}
{"id":"ttrpg_dsl-4qz","title":"Fix for-loop checker: only mark entity-typed bindings as non-local","description":"mark_current_scope_non_local() marks ALL for-loop pattern bindings as non-local, but only entity-typed ones should be non-local. Non-entity loop vars (struct, list elements) can currently bypass the immutable-local guard in action/reaction contexts.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:06Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-4zi","title":"Value + State + Effects: parameterize runtime types","description":"Change Value::Condition from tuple to struct with args map. Add params to ActiveCondition. Add params to ApplyCondition/RemoveCondition effects. Update all pattern-match sites.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-4zi","depends_on_id":"ttrpg_dsl-62f","type":"blocks","created_at":"2026-02-23T11:23:00Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-586","title":"Language: position arithmetic and spatial queries","description":"Position is opaque — only `distance(a, b) -\u003e int` is available. Can't express:\n- 'Move target 5 feet away from shover' (Shove action)\n- 'Is attacker on the opposite side of target from ally?' (Flanking)\n- 'All creatures within 20 feet of a point' (AoE targeting)\n- Direction vectors, line-of-sight, adjacency\n\nWould need builtins like:\n    direction(from: Position, to: Position) -\u003e Direction\n    move_toward(pos: Position, target: Position, distance: int) -\u003e Position\n    move_away(pos: Position, source: Position, distance: int) -\u003e Position\n    creatures_within(center: Position, radius: int) -\u003e list\u003cCharacter\u003e","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:59Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:59Z","labels":["builtins","language-design"]}
{"id":"ttrpg_dsl-59o","title":"Validate condition parameter declarations (defaults, duplicates)","description":"collect_condition (collect.rs:723) doesn't check for duplicate param names, and check_condition (check.rs:349) doesn't validate default expression types against declared param types. condition Foo(x: int = \"oops\") and condition Foo(x: int, x: int) both pass silently. Fix: add duplicate-name check in collect, and type-check default expressions in check_condition.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:07:41Z","closed_at":"2026-02-23T20:07:41Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-5a2","title":"Bound extraction does not traverse struct field segments","description":"extract_resource_bounds_from_type only handles Index through map/list (eval.rs:2005-2008). Paths like actor.stats.spell_slots[1] where stats is a named struct type won't resolve bounds, so resource-map clamping is skipped for nested struct access patterns.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:38Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:01:47Z","closed_at":"2026-02-23T19:01:47Z","close_reason":"extract_resource_bounds_from_type now traverses Named struct types via find_struct_field"}
{"id":"ttrpg_dsl-5ho","title":"Interpreter: runtime optional group support","description":"Runtime support for optional groups:\n- Extend StateProvider trait: is_group_active(), read_group_field()\n- Extend WritableState trait: grant_group(), revoke_group()\n- Add active_groups: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e to EntityState in reference_state.rs\n- Implement grant_group: validate group not already active, store fields, return Result\n- Implement revoke_group: remove group and discard field values, return Result\n- Evaluate ExprKind::Has: call state.is_group_active()\n- Evaluate namespaced field access: actor.Group.field reads from active_groups\n- Execute grant/revoke statements: evaluate field exprs, call state methods\n- Add GrantGroup/RevokeGroup to Effect enum if using effect-based mutation path\n- Handle namespaced field writes in actions (actor.Group.field -= 1)\nDepends on checker changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:23:49Z","closed_at":"2026-02-23T01:23:49Z","close_reason":"Implemented runtime optional group support: Has expression (read_field-based), Grant/Revoke statements emitting GrantGroup/RevokeGroup effects, remove_field on WritableState, adapter + CLI handler support","dependencies":[{"issue_id":"ttrpg_dsl-5ho","depends_on_id":"ttrpg_dsl-8j9","type":"blocks","created_at":"2026-02-22T16:32:58Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-5kb","title":"Language: spell instance / effect source tracking","description":"When a caster drops concentration, the spell's effects (conditions, ongoing damage, etc.) should be removed. But there is no concept of a 'spell instance' that links applied conditions back to their source spell. Dropping concentration sets concentrating_on to none but can't automatically clean up the conditions the spell applied. Would need effect provenance tracking.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:53Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:53Z"}
{"id":"ttrpg_dsl-5yt","title":"Language: indexed resources / map of resources","description":"Spell slots in 5e are a resource indexed by level (1-9). The DSL forces 9 separate fields:\n    spell_slots_1: int = 0\n    spell_slots_2: int = 0\n    ...\n    spell_slots_9: int = 0\n\nIdeally: `spell_slots: map\u003cint, resource(0..max_slots)\u003e`\nBut resource types cannot be values in a map. There is also no way to use a runtime int to select a field (no computed field access like `entity.spell_slots[level]`).","design":"## Design: map\u003cK, resource(min..max)\u003e\n\n### Two-Step Approach\n1. **Ship now (Option B):** resource as map value type with uniform bounds\n2. **Design for next (F-lite):** key-aware bounds resolver as extension\n\n### Type System Changes\n- Accept resource(...) as valid map value type (TypeExpr::Map already supports nesting)\n- Resolve map[key] to Ty::Resource when map's value type is resource\n- Bounds storage: keep on AST TypeExpr (adapter looks up field declarations, unwraps map value type to find resource bounds) — no Ty::Resource refactor needed\n\n### Missing Key Policy\n- Read missing key → return min (no mutation, matches resource-starts-at-minimum semantics)\n- Write missing key → auto-create entry, apply operation, clamp to [min, max]\n\n### Mutation Path\nPath like entity.spell_slots[3] -= 1 yields [Field(\"spell_slots\"), Index(Int(3))]:\n1. Adapter resolves field declaration for spell_slots\n2. Sees map\u003cint, resource(0..max)\u003e, extracts bound exprs from inner resource type\n3. Evaluates bounds in entity context (max could be a derive)\n4. Applies operation, clamps result to [min, max]\nSteps 2-4 are new work; path walking already exists in write_nested.\n\n### Initialization\n- Map literal syntax: spell_slots = { 1: 4, 2: 3, 3: 3, ... }\n- Values clamped on init too\n\n### Uniform bounds only (for now)\n- resource(0..9) means every key shares the same min/max\n- F-lite extension later adds key-parameterized bounds: resource(0..max_slots(key))\n\n### What it looks like\n```\noptional Spellcasting {\n    spell_slots: map\u003cint, resource(0..9)\u003e\n}\naction CastSpell(caster, spell_name, spell_level) {\n    require caster.Spellcasting.spell_slots[spell_level] \u003e 0\n    caster.Spellcasting.spell_slots[spell_level] -= 1\n}\n```\n\n### Rejected alternatives\n- Option C (computed field names): fragile, untyped\n- Option E (plain maps, no resource): defeats resource safety purpose\n- Option D (fixed-size arrays): future sugar after map-resource is solid","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:02Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:40:51Z","closed_at":"2026-02-23T18:40:51Z","close_reason":"Migrated dnd5e_expanded to use map\u003cint, resource(0..9)\u003e for spell_slots. Replaced 9 spell_slots_N fields with single resource-valued map. Replaced 9-branch matches in CureWounds and Fireball with spell_slots[slot_level] -= 1. Updated pain point comments and summary. File loads and type-checks cleanly.","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-5z0","title":"Spec: document hook declaration syntax and semantics","description":"Update spec/v0/ files to document the new hook declaration type. Add hook row to permission table in 02_scoping.ttrpg, add grammar rule in 03_canonical_grammar.ttrpg, add examples in 04_full_example.ttrpg. Hook is a mandatory triggered action (like reaction minus cost). Uses same trigger syntax as reactions, fires automatically on event match. See plan: .claude/plans/staged-rolling-raccoon.md Step 8.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:35Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:27:40Z","closed_at":"2026-02-23T06:27:40Z","close_reason":"Added hook documentation to all three spec files: permission table and description in 02_scoping, grammar rule in 03_canonical_grammar, worked example in 04_full_example"}
{"id":"ttrpg_dsl-62f","title":"AST + Parser: add params to ConditionDecl and parse them","description":"Add params: Vec\u003cParam\u003e field to ConditionDecl in ttrpg_ast. Update parser to parse optional (params) between condition name and 'on' keyword.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:48Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh"}
{"id":"ttrpg_dsl-671","title":"spawn is not atomic when inline optional groups are present","description":"runner.rs:444 creates the entity and binds the handle before inline-group validation/application at :449. Any later error (unknown group field, missing required field, default-eval error) returns Err but leaves partially created state behind. Fix: validate inline optional groups before mutating state, or roll back on error.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:33Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:34:10Z","closed_at":"2026-02-23T04:34:10Z","close_reason":"Reordered cmd_spawn to validate+prepare inline groups before mutating state"}
{"id":"ttrpg_dsl-6ee","title":"Parser: implement parse_hook_decl","description":"Add parse_hook_decl() to ttrpg_parser/src/decl.rs. Wire 'hook' soft keyword in dispatch. Reuse parse_trigger_param() and parse_with_groups(). Body is a bare block (no cost/resolve wrappers). See plan: .claude/plans/staged-rolling-raccoon.md Step 2.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:37Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:08:08Z","closed_at":"2026-02-23T06:08:08Z","close_reason":"Added parse_hook_decl() to decl.rs and wired 'hook' soft keyword in parse_decl dispatch. Reuses parse_trigger_param(), parse_with_groups(), and parse_block() for bare body.","dependencies":[{"issue_id":"ttrpg_dsl-6ee","depends_on_id":"ttrpg_dsl-jkl","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6o0","title":"Enforce with-group constraints on condition call arguments","description":"Function calls enforce with_groups on params (check_expr.rs:969), but condition calls (check_expr.rs:798) skip this check entirely. condition Frightened(source: Character with Spellcasting) called as Frightened(actor) where actor is plain Character emits no diagnostic. Fix: add with-group enforcement parallel to what function calls do.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:43Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:07:41Z","closed_at":"2026-02-23T20:07:41Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-6o0","depends_on_id":"ttrpg_dsl-czr","type":"blocks","created_at":"2026-02-23T11:54:46Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6p8","title":"Checker: type-check condition params and calls","description":"Add params to ConditionInfo. Register in collect_condition. Handle condition calls in check_call. Error on bare use of parameterized conditions. Bind params in modify/suppress clause scopes.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:51Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-6p8","depends_on_id":"ttrpg_dsl-4zi","type":"blocks","created_at":"2026-02-23T11:23:01Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-6p8","depends_on_id":"ttrpg_dsl-62f","type":"blocks","created_at":"2026-02-23T11:23:01Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6su","title":"Implement some(x) pattern matching for option\u003cT\u003e","description":"Add some(x) pattern to match expressions, fix none pattern bug (doesn't match Value::Option(None)), update dnd5e_expanded example","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:21:15Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:27:37Z","closed_at":"2026-02-22T18:27:37Z","close_reason":"Implemented some(x) pattern matching, fixed none bug, added tests, updated dnd5e example"}
{"id":"ttrpg_dsl-7ch","title":"Transparent option-as-index: use option\u003cAbility\u003e to index into abilities[]","description":"Allow option\u003cT\u003e to be used where T is expected for indexing operations, with a runtime error if none. E.g. abilities[spellcasting_ability] where spellcasting_ability: option\u003cAbility\u003e.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:20Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:26:20Z"}
{"id":"ttrpg_dsl-7fv","title":"Language: dynamic dice construction","description":"DiceExpr literals are compile-time only. There is no way to construct a dice expression from runtime values. This means upcast spells need a match per slot level:\n    match slot_level { 1 =\u003e 1d8, 2 =\u003e 2d8, 3 =\u003e 3d8, ... }\n\nNeed something like:\n    dice(count: slot_level, sides: 8)  // -\u003e DiceExpr\nor a builtin:\n    make_dice(slot_level, 8) -\u003e DiceExpr\n\nAlso: there is no zero/empty DiceExpr value, so DiceExpr fields cannot have defaults.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:19Z","created_by":"Theodore Gast","updated_at":"2026-02-23T15:50:49Z","closed_at":"2026-02-23T15:50:49Z","close_reason":"Implemented dice(count, sides) builtin","labels":["language-design"]}
{"id":"ttrpg_dsl-7r4","title":"Language: condition composition / inheritance","description":"Many 5e conditions include effects of other conditions:\n- Stunned includes Incapacitated (can't take actions/reactions)\n- Unconscious includes Prone + Incapacitated\n- Paralyzed includes Incapacitated + auto-fail STR/DEX saves\n\nCurrently all effects must be duplicated in each condition. Would like:\n    condition Stunned extends Incapacitated on bearer: Character { ... }\nor:\n    condition Stunned on bearer: Character {\n        include Incapacitated\n        ...additional effects...\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:32Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:32Z","labels":["language-design"]}
{"id":"ttrpg_dsl-82h","title":"Implement eval handle.field access in REPL","description":"Currently `eval handle.field` does not work — handles are not in the interpreter's eval scope (confirmed by test at runner.rs:1697). This was explicitly deferred from ttrpg_dsl-avf.\n\nThe goal is to make expressions like `eval hero.HP`, `eval hero.Spellcasting.spell_slots`, and `eval hero.Spellcasting` work in the CLI by injecting handle bindings into the interpreter's evaluation context before calling evaluate_expr.\n\nThis likely requires either:\n1. Pre-processing the expression to substitute handle.field references with their values before eval, or\n2. Extending the interpreter to accept an environment of handle→entity bindings so that handle names resolve during expression evaluation\n\nApproach 2 is cleaner but requires interpreter changes. Approach 1 can be done entirely in the CLI crate.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T02:30:46Z","created_by":"Theodore Gast","updated_at":"2026-02-23T16:12:30Z","closed_at":"2026-02-23T16:12:30Z","close_reason":"Added evaluate_expr_with_bindings to Interpreter and updated Runner::eval to inject handle bindings into scope"}
{"id":"ttrpg_dsl-8d6","title":"Tests: optional group end-to-end coverage","description":"Comprehensive test coverage for optional groups:\n- Parser tests: entity with optional groups, has expressions, grant/revoke stmts, with constraints\n- Checker tests: valid/invalid group access, narrowing through if-has, with constraints on actions/derives, grant/revoke only in actions, duplicate group names, nonexistent groups\n- Interpreter tests: grant/revoke lifecycle, has evaluation, namespaced field read/write, grant with defaults, revoke discards values, double-grant error, revoke-inactive error\n- Integration test: full 5e-style example with Character having optional Spellcasting and KiPowers, actions with 'with' constraints, guards in derives\n- CLI tests: spawn with inline groups, grant/revoke commands, eval namespaced paths\nDepends on all implementation tasks.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:41:15Z","closed_at":"2026-02-23T02:41:15Z","close_reason":"Added 12 end-to-end integration tests in optional_groups_integration.rs exercising the full pipeline (parse→lower→check→interpret) for optional groups: pipeline validation, has expression, grant/revoke via actions with StateAdapter, full lifecycle with multiple groups, with-constrained actions, derives with has-guards, per-entity independence, and effect emission verification. Existing unit tests in parser/checker/interp/CLI already cover syntax parsing, type checking, and CLI commands comprehensively.","dependencies":[{"issue_id":"ttrpg_dsl-8d6","depends_on_id":"ttrpg_dsl-avf","type":"blocks","created_at":"2026-02-22T16:32:59Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-8j9","title":"Checker: type check optional groups","description":"Type checking for optional groups:\n- Add OptionalGroupInfo to EntityInfo in env.rs, populate during collection (collect.rs)\n- Validate optional group declarations: unique names, valid field types, no nesting\n- Type check ExprKind::Has: entity type must have the named group, result is bool\n- Type check grant/revoke: only allowed in action/reaction resolve blocks, validate group exists and field types match\n- Validate 'with' constraints on params: entity type must declare the named group\n- Flow-sensitive type narrowing: track which groups are narrowed-as-active in scope (if entity has Group { ... }, early return after negative guard)\n- Reject access to entity.Group.field without a guard or 'with' constraint\n- Automatically narrow groups inside action/derive bodies when 'with' constraint is present\nDepends on parser changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:05:24Z","closed_at":"2026-02-23T01:05:24Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-8j9","depends_on_id":"ttrpg_dsl-o1b","type":"blocks","created_at":"2026-02-22T16:32:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-8tu","title":"Language: enum-associated data / lookup tables","description":"Enums can't carry associated data beyond variant payloads. The Skill-\u003eAbility mapping requires an 18-branch match derive for what is essentially static data. Would want either enum-level associated constants (enum Skill { athletics(ability: STR), ... }) or a const map type for lookup tables.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:47Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:47Z"}
{"id":"ttrpg_dsl-950","title":"AST: add optional group nodes","description":"Add AST types for optional groups:\n- OptionalGroup struct (name + fields) on EntityDecl\n- ExprKind::Has { entity, group_name } for guard expressions\n- StmtKind::Grant { entity, group_name, fields } and StmtKind::Revoke { entity, group_name }\n- with_groups: Vec\u003cString\u003e on Param and receiver_with_groups on ActionDecl/ReactionDecl/ConditionDecl/FnDecl\nFile: ttrpg_ast/src/ast.rs","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:23Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:45:29Z","closed_at":"2026-02-23T00:45:29Z","close_reason":"Added OptionalGroup on EntityDecl, ExprKind::Has, StmtKind::Grant/Revoke, with_groups on Param, receiver_with_groups on ActionDecl/ReactionDecl/ConditionDecl. All 844 tests pass."}
{"id":"ttrpg_dsl-9ng","title":"Parser: wildcard `_` not supported in modify bindings","description":"The spec (02_scoping.ttrpg:278) shows `modify attack_roll(attacker: _, target: _)` but the parser rejects _ in modify bindings because parse_modify_binding() calls parse_expr(), and Underscore is not a valid expression. Needed for option when-enabled blocks where there is no receiver to bind against.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:57Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:51Z","closed_at":"2026-02-22T17:28:51Z","close_reason":"Added wildcard _ support in parse_modify_binding(). Made ModifyBinding.value Option\u003cSpanned\u003cExprKind\u003e\u003e, updated checker and interpreter to skip type-check/match for None.","labels":["parser"]}
{"id":"ttrpg_dsl-a6m","title":"Interpreter: condition call dispatch + pipeline param binding","description":"Handle condition calls in eval_call (build parameterized Value::Condition). Update builtins to extract/pass params. Bind condition params in pipeline (modify/suppress scopes). Update adapter, GameState, CLI handler.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:53Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-a6m","depends_on_id":"ttrpg_dsl-4zi","type":"blocks","created_at":"2026-02-23T11:23:02Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-a6m","depends_on_id":"ttrpg_dsl-62f","type":"blocks","created_at":"2026-02-23T11:23:02Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-am8","title":"Add regression tests for resource-map edge cases","description":"Test coverage misses: (1) deep local-to-entity mutation with bounds (trigger.target.spell_slots[level] -= 1 should clamp), (2) complex bound expressions failing silently (resource(0..max_slots + 1)), (3) struct-field traversal for bound extraction (actor.stats.spell_slots[1]). Existing deep-entity test checks path/op but not bounds (eval.rs:5050).","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:01:47Z","closed_at":"2026-02-23T19:01:47Z","close_reason":"6 regression tests added covering: trigger payload bounds, complex bound expressions, struct field traversal","dependencies":[{"issue_id":"ttrpg_dsl-am8","depends_on_id":"ttrpg_dsl-0ch","type":"blocks","created_at":"2026-02-23T10:47:45Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-am8","depends_on_id":"ttrpg_dsl-5a2","type":"blocks","created_at":"2026-02-23T10:47:46Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-am8","depends_on_id":"ttrpg_dsl-lfm","type":"blocks","created_at":"2026-02-23T10:47:45Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-avf","title":"CLI: grant/revoke commands and spawn integration","description":"CLI support for optional groups:\n- New 'grant handle.GroupName { field: val, ... }' command\n- New 'revoke handle.GroupName' command\n- Extend spawn to accept inline groups: spawn Type handle { field: val, Group { field: val } }\n- Extend parse_field_block to distinguish regular fields from group activations\n- Validate group names and field types against TypeEnv during grant and spawn\n- Extend eval to handle namespaced paths (eval hero.Spellcasting.spell_save_DC)\n- Extend set to handle namespaced paths\n- Update completer.rs for group name completion\n- Update accessor methods (entity_type_names, field_names) to include group info\nDepends on interpreter changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:45Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:17:01Z","closed_at":"2026-02-23T02:17:01Z","close_reason":"Implemented CLI grant/revoke commands, extended spawn/set/inspect/types/state for optional groups, updated completer and highlighter","dependencies":[{"issue_id":"ttrpg_dsl-avf","depends_on_id":"ttrpg_dsl-5ho","type":"blocks","created_at":"2026-02-22T16:32:58Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-bcc","title":"Language: entity destruction / lifecycle management","description":"No way to remove entities from the game. Death in 5e is permanent removal of a character, but the DSL has no destroy() or remove_entity() builtin. Entities are created via spawn but never destroyed. Needed for: character death, destroying objects, banishment effects.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:44Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:44Z"}
{"id":"ttrpg_dsl-beu","title":"Tests: hook declaration parser, checker, and interpreter tests","description":"Parser tests: basic parse, with_groups, soft keyword. Checker tests: undefined event, shadow trigger/turn, struct receiver rejected, direct call rejected, binding type mismatch. Interpreter tests (new hook_integration.rs): fires on matching event, skips non-matching entity, can mutate/roll, declaration order, not suppressed. See plan: .claude/plans/staged-rolling-raccoon.md Step 7.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:43Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:22:14Z","closed_at":"2026-02-23T06:22:14Z","close_reason":"Added 3 parser tests, 9 checker tests (including hook direct call rejection fix in check_expr.rs), and 11 interpreter integration tests in hook_integration.rs","dependencies":[{"issue_id":"ttrpg_dsl-beu","depends_on_id":"ttrpg_dsl-d83","type":"blocks","created_at":"2026-02-22T21:55:49Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-c2y","title":"Parser: missing skip_newlines between cost and requires blocks","description":"In parse_action_decl (decl.rs:253-263), there is no skip_newlines() call between parsing the cost clause and checking for a requires clause. Comments or blank lines between cost {} and requires {} cause the requires to be silently skipped, and the parser then fails on 'expected resolve, found requires'. Fix: add self.skip_newlines() between the cost and requires parsing blocks.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:37Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:06:10Z","closed_at":"2026-02-22T17:06:10Z","close_reason":"Added skip_newlines() between cost and requires parsing in parse_action_decl. Added regression test.","labels":["parser"]}
{"id":"ttrpg_dsl-ccr","title":"Add if-let some(x) = expr syntax","description":"Allow if let some(x) = optional_expr { ... } else { ... } as a more ergonomic alternative to match for single-pattern option destructuring","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:15Z","created_by":"Theodore Gast","updated_at":"2026-02-22T19:04:01Z","closed_at":"2026-02-22T19:04:01Z","close_reason":"Added ExprKind::IfLet to AST, parser, checker, and interpreter. Supports if let some(x) = expr { ... } else { ... } with else-if-let chaining and nested patterns."}
{"id":"ttrpg_dsl-chb","title":"Checker: accept resource() as map value type","description":"Update type resolution so map\u003cK, resource(min..max)\u003e is valid. Verify TypeExpr::Map(key, TypeExpr::Resource(min, max)) resolves correctly. Ensure map[key] expressions resolve to Ty::Resource so arithmetic/mutation type-check. May already partially work — verify and fix any rejection points.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:47Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:42:30Z","closed_at":"2026-02-23T17:42:30Z","close_reason":"Checker already accepts map\u003cK, resource(min..max)\u003e through generic type composition. No code changes needed — added 4 tests confirming declaration, read, mutation, and optional group access all type-check correctly."}
{"id":"ttrpg_dsl-clo","title":"Language: automatic event emission from mutations","description":"When `target.HP -= amount` happens in an action, the runtime does not automatically emit a takes_damage event. The host must manually fire all events. Similarly for condition application.\n\nWould enable reactive patterns without host involvement:\n    entity Character {\n        HP: resource(0..max_HP) {\n            on_decrease =\u003e emit takes_damage(source: current_actor, amount: delta, damage_type: ...)\n        }\n    }\n\nThis would let concentration checks fire automatically when a concentrating caster takes damage.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ctc","title":"Language: typed prompts (return entity refs, not strings)","description":"Prompts always return string. For 'choose a target creature', the host must map the string back to an entity reference externally. Would be more type-safe to support:\n    prompt choose_target(chooser: Character, candidates: list\u003cCharacter\u003e) -\u003e Character\n    prompt choose_weapon(chooser: Character) -\u003e Weapon\n\nThis would let the interpreter validate the response type and eliminate string-to-entity mapping in the host.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:07Z","labels":["language-design"]}
{"id":"ttrpg_dsl-czr","title":"Fix named argument validation for condition calls","description":"Checker ignores arg.name and type-checks condition params by positional index only (check_expr.rs:819). Interpreter uses arg.name if present (call.rs:46), so Frightened(src: actor) passes checker but stores 'src' instead of 'source', causing runtime undefined variable. Fix: validate that named args match declared param names, and resolve positional vs named args consistently in both checker and interpreter.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:34Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:02:22Z","closed_at":"2026-02-23T20:02:22Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-d3r","title":"Language: additional Duration variants","description":"The built-in Duration enum has: end_of_turn, start_of_next_turn, rounds(count), minutes(count), indefinite.\n\nMissing duration types needed for 5e:\n- 'until next use': Help action grants advantage on the target's NEXT attack/check, then the condition auto-removes. Many buff spells work this way.\n- 'until a save is made': Many spell effects (Hold Person, etc.) let the target repeat a save at end of each turn. The condition persists until they succeed.\n- 'until concentration ends': Spells like Bless last as long as the caster maintains concentration.\n\nThese could be additional Duration variants or a separate mechanism.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:59Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:01:26Z","closed_at":"2026-02-23T17:01:26Z","close_reason":"Duration is now a ruleset-customizable enum (like TurnBudget). Removed hardcoded DurationValue/Value::Duration. Builtin fallback has only 'indefinite'. Rulesets define their own variants via enum Duration { ... }.","labels":["language-design"]}
{"id":"ttrpg_dsl-d83","title":"Interpreter: implement execute_hook and fire_hooks","description":"Add ActionKind::Hook to effect.rs. Add execute_hook() to action.rs (emit ActionStarted/Completed, bind receiver+trigger, execute body — no cost deduction). Add find_matching_hooks() to event.rs (reuse match_trigger_bindings, no suppression). Add fire_hooks() public API to lib.rs. See plan: .claude/plans/staged-rolling-raccoon.md Steps 5-6.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:41Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:17:26Z","closed_at":"2026-02-23T06:17:26Z","close_reason":"Implemented ActionKind::Hook variant, execute_hook in action.rs, find_matching_hooks+HookInfo in event.rs, and execute_hook/what_hooks/fire_hooks public API on Interpreter","dependencies":[{"issue_id":"ttrpg_dsl-d83","depends_on_id":"ttrpg_dsl-ixk","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-du9","title":"Tests: resource-valued maps end-to-end","description":"Add tests covering: (1) declaring map\u003cint, resource(0..N)\u003e fields, (2) spawning entities with initialized resource maps, (3) mutating via entity.field[key] -= 1 with clamping, (4) reading missing keys returns min, (5) writing missing keys auto-creates clamped entries, (6) type errors for invalid operations on resource map values. Cover checker, interpreter, and integration levels.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:56Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:38:44Z","closed_at":"2026-02-23T18:38:44Z","close_reason":"Added 8 checker tests (type errors: wrong key type, assign string, += string, += float, enum keys, arithmetic, comparison, nonzero min) and 8 interpreter tests (nonzero min underflow/clamp-up/auto-init, multiple keys in one action, derive reads, enum-keyed maps read+mutate+clamp). Total coverage: 12 checker tests + 16 interp tests for resource-valued maps.","dependencies":[{"issue_id":"ttrpg_dsl-du9","depends_on_id":"ttrpg_dsl-1wn","type":"blocks","created_at":"2026-02-23T09:38:04Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-du9","depends_on_id":"ttrpg_dsl-m2n","type":"blocks","created_at":"2026-02-23T09:38:04Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3","title":"Language: bounded iteration / loops","description":"The DSL has no loop construct. This blocks modeling:\n- Extra Attack (make N attack rolls where N depends on level)\n- AoE spells (apply damage to N targets)\n- Multi-damage-type processing (iterate over list\u003cDamageSpec\u003e)\n- Spell slot deduction (9-branch match instead of indexed access)\n\nA bounded `for` loop would cover most cases:\n    for target in targets { ... }\n    for i in 1..attack_count(attacker) { ... }\n\nUnbounded while loops are probably not needed for TTRPG modeling.","design":"# Design: Bounded Iteration / For-Loops\n\n## Motivation\n\nThe DSL has no loop construct. This blocks modeling common TTRPG patterns:\n\n- **Extra Attack**: make N attack rolls where N depends on level\n- **AoE spells**: apply damage to each target in a list\n- **Multi-damage processing**: iterate over `list\u003cDamageSpec\u003e` to resolve each\n- **Buff/debuff application**: apply a condition to multiple entities\n\nAll motivating cases involve iterating over a bounded, known-size collection\nor a small integer range. Unbounded `while` loops are not needed.\n\n---\n\n## Syntax\n\n### For-each (collection iteration)\n\n    for PATTERN in EXPR { BODY }\n\n### For-range (numeric iteration)\n\n    for IDENT in EXPR..EXPR { BODY }\n\nThe `..` produces a half-open range: `0..3` iterates over `0, 1, 2`.\n\n`for` is an expression (consistent with `if` and `match`). It appears in\n`primary_expr` alongside `if_expr` and `match_expr`.\n\n### Examples\n\n```ttrpg\n// Iterate over a list of targets\nfor target in targets {\n    target.HP -= damage\n}\n\n// Range-based iteration (Extra Attack)\nfor i in 0..extra_attacks(attacker) {\n    let result = resolve_melee_attack(attacker, target, weapon)\n    match result {\n        hit(amount) =\u003e { target.HP -= amount },\n        miss =\u003e {}\n    }\n}\n\n// Pattern matching — filter + destructure\nfor hit(amount) in results {\n    total_damage += amount\n}\n\n// Option filtering\nfor some(value) in optional_items {\n    process(value)\n}\n\n// AoE with saving throws\nfor target in targets {\n    let save = roll(d20_expr(score: target.abilities[DEX]))\n    if save \u003c DC {\n        target.HP -= damage_roll.total\n    } else {\n        target.HP -= floor(damage_roll.total / 2)\n    }\n}\n```\n\n---\n\n## Semantics\n\n### Iterable types\n\n| Source          | Binding type | Iteration order          |\n|-----------------|--------------|--------------------------|\n| `list\u003cT\u003e`       | `T`          | Index order              |\n| `set\u003cT\u003e`        | `T`          | Sorted order (BTreeSet)  |\n| `a..b` (range)  | `int`        | Ascending, half-open     |\n\nMap iteration is **deferred** to a future issue. Users who need map\nkeys/values can use `keys(map)` / `values(map)` builtins (also deferred;\nmaps are not the motivating use case for loops).\n\n### Return value\n\n**For-loops return `unit`.**\n\nFor-loops exist for side-effectful iteration — the primary TTRPG use cases\nare all about mutating game state (dealing damage, applying conditions,\nrolling dice). Returning unit keeps the implementation simple and avoids\nintroducing `list\u003cunit\u003e` as a type.\n\nFuture enhancement: collection semantics (`for x in xs { f(x) }` returns\n`list\u003cT\u003e`) could be added later. The AST and parser design below are\nforward-compatible with this change, which would be non-breaking (it makes\npreviously-erroring code valid rather than changing existing behavior).\n\n### Scoping\n\nEach iteration gets a fresh lexical scope:\n1. Push scope\n2. Bind loop variable(s) from pattern\n3. Evaluate body\n4. Pop scope\n\nLoop variables are immutable (consistent with `let` bindings). Mutation\nhappens through entity field assignment (`target.HP -= amount`), not\nthrough loop variable rebinding.\n\n### Empty collection / empty range\n\n- Empty list/set: zero iterations, returns `unit`\n- `a..b` where `a \u003e= b`: zero iterations, returns `unit`\n\n### Pattern matching in loops\n\nFor-loops support the full pattern infrastructure (reusing `PatternKind`):\n\n| Pattern               | Effect                                  |\n|-----------------------|-----------------------------------------|\n| `x`                   | Irrefutable — binds every element        |\n| `hit(amount)`         | Destructure enum variant, skip non-match |\n| `some(value)`         | Unwrap option, skip `none` values        |\n| `_`                   | Wildcard — matches all, binds nothing    |\n| `MyStruct(a, b)`      | Destructure, skip non-match             |\n\nWhen a pattern does not match an element, that iteration is **silently\nskipped**. This provides built-in filtering without a separate construct.\n\n### No break / continue\n\nNot included in this design. Bounded TTRPG collections are small, and\nconditional logic within the loop body (`if`/`match`) covers skip and\nearly-exit patterns adequately. These can be added later if needed.\n\n---\n\n## Grammar changes\n\nNew production in `primary_expr`:\n\n    primary_expr    = ... | for_expr\n    for_expr        = \"for\" pattern \"in\" for_source block\n    for_source      = expr \"..\" expr       // range\n                    | expr                 // collection\n\nDisambiguation: parse the expression after `in`. Since `..` is not a\nbinary operator in expression context, the expression parser naturally\nstops before `..`. If the next token is `DotDot`, parse the range end;\notherwise treat the expression as a collection iterable.\n\n### Newline handling\n\n`for` starts an expression — no special NL suppression rules needed beyond\nwhat `{` already provides. The `in` keyword already suppresses NL after it\n(it is a binary operator in the existing grammar).\n\n---\n\n## Keyword changes\n\n- Add `for` as a **reserved keyword** (`TokenKind::For`)\n- `in` already reserved, `..` already a token (`DotDot`)\n\n`for` is not currently used as an identifier anywhere in the spec or\nexamples. Reserving it is non-breaking for existing programs.\n\n---\n\n## AST changes\n\nNew variant in `ExprKind`:\n\n```rust\nFor {\n    pattern: Box\u003cSpanned\u003cPatternKind\u003e\u003e,\n    iterable: ForIterable,\n    body: Block,\n},\n```\n\nNew enum:\n\n```rust\npub enum ForIterable {\n    Collection(Box\u003cSpanned\u003cExprKind\u003e\u003e),\n    Range {\n        start: Box\u003cSpanned\u003cExprKind\u003e\u003e,\n        end: Box\u003cSpanned\u003cExprKind\u003e\u003e,\n    },\n}\n```\n\nThis unified representation keeps type-checking and evaluation logic\nshared between collection and range iteration.\n\n---\n\n## Type checker changes\n\nNew rules in `check_expr`:\n\n1. **For-each**: `for P in E { B }`\n   - `E` must have type `list\u003cT\u003e` or `set\u003cT\u003e`\n   - Pattern `P` checked against element type `T` (reuse `check_pattern`)\n   - Body `B` type-checked in scope with pattern bindings\n   - Expression type: `unit`\n\n2. **For-range**: `for x in A..B { C }`\n   - `A` and `B` must have type `int`\n   - `x` binds as `int`\n   - Body `C` type-checked with `x: int` in scope\n   - Expression type: `unit`\n\nError cases:\n- `for x in 42 { ... }` → \"expected list or set, found int\"\n- `for x in some_map { ... }` → \"map iteration not supported; use keys() or values()\"\n- `for x in 1.5..10 { ... }` → \"range bounds must be int\"\n\n---\n\n## Interpreter changes\n\nNew function `eval_for`:\n\n```rust\nfn eval_for(env: \u0026mut Env, pattern: \u0026PatternKind,\n            iterable: \u0026ForIterable, body: \u0026Block)\n            -\u003e Result\u003cValue, RuntimeError\u003e\n{\n    let items: Vec\u003cValue\u003e = match iterable {\n        ForIterable::Collection(expr) =\u003e match eval_expr(env, expr)? {\n            Value::List(items) =\u003e items,\n            Value::Set(items) =\u003e items.into_iter().map(Value::from).collect(),\n            other =\u003e return Err(not_iterable(other)),\n        },\n        ForIterable::Range { start, end } =\u003e {\n            let s = eval_expr(env, start)?.as_int()?;\n            let e = eval_expr(env, end)?.as_int()?;\n            (s..e).map(Value::Int).collect()\n        }\n    };\n\n    for item in items {\n        let mut bindings = HashMap::new();\n        if match_pattern(env, pattern, \u0026item, \u0026mut bindings) {\n            env.push_scope();\n            for (name, val) in bindings {\n                env.bind(name, val);\n            }\n            eval_block(env, body)?;\n            env.pop_scope();\n        }\n    }\n\n    Ok(Value::None)\n}\n```\n\nKey properties:\n- Collects iterable into a Vec up front (no lazy iteration needed for\n  small TTRPG collections)\n- Reuses existing `match_pattern` + scope push/pop infrastructure\n- Non-matching patterns silently skip (no error)\n- Returns `Value::None` (unit)\n\n---\n\n## CLI / REPL changes\n\n- `TtrpgHighlighter`: highlight `for` as keyword\n- `TtrpgValidator`: `for` opens a block (add to delimiter counting)\n- `TtrpgCompleter`: `for` as keyword completion\n\n---\n\n## Implementation plan\n\n| Phase | Crate         | Work                                           |\n|-------|---------------|-------------------------------------------------|\n| 1     | ttrpg_lexer   | Add `TokenKind::For`, reserve `for`             |\n| 2     | ttrpg_ast     | Add `ExprKind::For`, `ForIterable` enum         |\n| 3     | ttrpg_parser  | Parse `for_expr` in `primary_expr`              |\n| 4     | ttrpg_checker | Type-check for-loops (collection + range)       |\n| 5     | ttrpg_interp  | `eval_for` implementation                       |\n| 6     | ttrpg_cli     | Highlighter, validator, completer updates        |\n| 7     | spec          | Update grammar spec, add examples               |\n\nPhases 1-3 can land as a parsing-only PR. Phase 4-5 adds semantics.\nPhase 6-7 are polish.\n\n---\n\n## Open questions\n\n1. **Collection semantics later?** The design is forward-compatible with\n   changing the return type to `list\u003cT\u003e` when the body is non-unit. Worth\n   doing now or defer?\n\n2. **Range inclusivity**: `1..4` means `[1, 2, 3]` (half-open, Rust-style).\n   Should we also support `1..=4` for `[1, 2, 3, 4]` (inclusive)? D\u0026D\n   spell slot levels are 1-9 inclusive, so `for level in 1..10` vs\n   `for level in 1..=9`.\n\n3. **Nested for-loops**: Should work naturally via scope stacking. Any\n   reason to restrict nesting depth?","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:00Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:39:36Z","closed_at":"2026-02-22T20:39:36Z","close_reason":"Closed","labels":["language-design"]}
{"id":"ttrpg_dsl-dz3.1","title":"For-loop: Lexer — Add TokenKind::For, reserve `for` keyword","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:16Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:22:41Z","closed_at":"2026-02-22T20:22:41Z","close_reason":"Added TokenKind::For to lexer, keyword match in lex_ident_or_keyword, highlighter keyword group, and completer DSL_KEYWORDS list. All tests pass."}
{"id":"ttrpg_dsl-dz3.2","title":"For-loop: AST — Add ExprKind::For variant and ForIterable enum","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:25:26Z","closed_at":"2026-02-22T20:25:26Z","close_reason":"Added ExprKind::For variant and ForIterable enum to AST. Added stub arms in checker (check_for -\u003e Ty::Unit) and interpreter (RuntimeError). All 815 tests pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.2","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:16Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.2","depends_on_id":"ttrpg_dsl-dz3.1","type":"blocks","created_at":"2026-02-22T11:50:31Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.3","title":"For-loop: Parser — Parse for_expr in primary_expr (collection + range forms)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:27:31Z","closed_at":"2026-02-22T20:27:31Z","close_reason":"Added parse_for_expr in primary_expr. Parses both collection (for x in expr {}) and range (for x in a..b {}) forms with full pattern support. 7 new parser tests, all 822 tests pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.3","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:17Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.3","depends_on_id":"ttrpg_dsl-dz3.2","type":"blocks","created_at":"2026-02-22T11:50:34Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.4","title":"For-loop: Type checker — Type-check for-loops (collection + range, pattern bindings)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:18Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:31:26Z","closed_at":"2026-02-22T20:31:26Z","close_reason":"Implemented check_for: validates collection (list/set) and range (int bounds) iterables, checks pattern bindings against element type, marks for-loop bindings as non-local for entity field mutation. Added mark_current_scope_non_local to ScopeStack. 9 new tests (valid + error cases), all 831 pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.4","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:18Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.4","depends_on_id":"ttrpg_dsl-dz3.3","type":"blocks","created_at":"2026-02-22T11:50:34Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.5","title":"For-loop: Interpreter — eval_for implementation (collection iteration, range iteration, pattern matching)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:19Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:36:55Z","closed_at":"2026-02-22T20:36:55Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-dz3.5","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:19Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.5","depends_on_id":"ttrpg_dsl-dz3.4","type":"blocks","created_at":"2026-02-22T11:50:35Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.6","title":"For-loop: CLI — Highlighter, validator, completer updates for `for` keyword","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:20Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:37:36Z","closed_at":"2026-02-22T20:37:36Z","close_reason":"All three CLI components (highlighter, completer, validator) already handled: highlighter and completer done in phase 1, validator is delimiter-based and needs no keyword changes","dependencies":[{"issue_id":"ttrpg_dsl-dz3.6","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:20Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.6","depends_on_id":"ttrpg_dsl-dz3.1","type":"blocks","created_at":"2026-02-22T11:50:35Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.7","title":"For-loop: Spec — Update canonical grammar, add for-loop examples","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:21Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:39:33Z","closed_at":"2026-02-22T20:39:33Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-dz3.7","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:21Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.7","depends_on_id":"ttrpg_dsl-dz3.5","type":"blocks","created_at":"2026-02-22T11:50:36Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-efg","title":"Parser: `none` is not a valid match pattern","description":"The pattern parser (pattern.rs) does not handle TokenKind::None. This means `match opt_val { none =\u003e ..., _ =\u003e ... }` fails with 'expected pattern, found None'. The spec implies option types should be matchable. Fix: add a None case to parse_pattern() that produces PatternKind::Literal with a None value.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:48Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:54Z","closed_at":"2026-02-22T17:28:54Z","close_reason":"Added PatternKind::NoneLit, handled in parser (parse_pattern), checker (check_pattern), and interpreter (match_pattern).","labels":["parser"]}
{"id":"ttrpg_dsl-fz0","title":"CLI: pipe/script mode exits on load failure, diagnostics unreachable","description":"In pipe mode (run_pipe, main.rs:38) and script mode (run_script, main.rs:64), any command error calls process::exit(1) immediately. This means if `load` fails with parse/check errors, the subsequent `errors` command never runs — the user cannot see what went wrong.\n\nThe diagnostics ARE stored on the Runner (runner.rs:280), but the process exits before the next line of stdin/script is read.\n\nOptions:\n- Don't exit on load failure in pipe/script mode — just print the error and continue\n- Auto-print diagnostics on load failure (first N errors)\n- Add a --keep-going flag for script mode\n- In pipe mode, treat load failure as non-fatal (the Runner is still usable, just with no program loaded)","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:08:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:58:36Z","closed_at":"2026-02-22T17:58:36Z","close_reason":"pipe/script mode now continues on error instead of exiting immediately, so diagnostics are reachable","labels":["cli"]}
{"id":"ttrpg_dsl-gpe","title":"Fix scope leak in eval_for on body error","description":"eval_for uses ? on eval_block which skips pop_scope() on error, violating scope-balance invariants.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:08Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-gwr","title":"Checker: with constraints not enforced at call sites","description":"The with keyword on actions/reactions is only used for body-internal narrowing. Call sites never check that the receiver actually has the required group, leading to runtime field-access errors instead of type errors. Need to store with_groups in param metadata and validate at call sites.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:06Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-hpg","title":"Language: ordered enums / enum-to-int conversion","description":"Enums have no inherent ordering. In 5e, Size (tiny \u003c small \u003c medium \u003c large \u003c huge \u003c gargantuan) needs comparison:\n    requires { target.size \u003c= grappler.size + 1 }\nThis is impossible because Size is an enum without ordinal values. Workaround is != checks for specific variants, which doesn't generalize.\n\nOptions:\n- Ordered enums: `enum Size ordered { tiny, small, medium, large, huge, gargantuan }`\n- Enum-to-int builtin: `ordinal(Size.medium) -\u003e 2`\n- Comparable enums that support \u003c, \u003e, \u003c=, \u003e= based on declaration order","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:36Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:36Z","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-hwf","title":"Parser: newlines inside brace-delimited blocks not suppressed","description":"Newlines inside { } are NOT suppressed (unlike () and []). This means multiline expressions in requires/cost blocks fail: requires { a \u0026\u0026\\n b } breaks. Only the opening { suppresses the next NL, not all NLs inside braces. Workaround: put everything on one line, or wrap in parens. See pain point #18 in examples/dnd5e_expanded.ttrpg.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:50:44Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:07:24Z","closed_at":"2026-02-22T18:07:24Z","close_reason":"Added suppress_newlines_in_brace_block() to strip NL tokens in expression-brace contexts (requires, cost)"}
{"id":"ttrpg_dsl-irh","title":"Implement parameterized conditions","description":"Add optional params to condition declarations, Value::Condition, ActiveCondition, Effects, and propagate through checker/interpreter/CLI","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:25:10Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:45:14Z","closed_at":"2026-02-23T19:45:14Z","close_reason":"Implemented parameterized conditions across all crates"}
{"id":"ttrpg_dsl-iuw","title":"Language: parameterized conditions","description":"Conditions are binary (present or absent) and take no parameters. In 5e:\n- Frightened needs a 'source' entity (can't willingly move closer to source)\n- Exhaustion has 6 levels with escalating effects\n- Grappled needs a reference to the grappler (grappler's speed is also 0)\n\nWould need: `condition Frightened(source: Character) on bearer: Character { ... }`\nor: `condition Exhaustion(level: int) on bearer: Character { ... }`\n\nWithout this, parameterized effects require separate conditions per case or external state tracking.","status":"in_progress","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:11Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:22:42Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ixk","title":"Checker: implement collect_hook and check_hook","description":"Add FnKind::Hook to env.rs. Add collect_hook() to collect.rs (validate entity receiver, reject trigger/turn shadows, register via collect_fn). Add check_hook() to check.rs (bind receiver, validate trigger event+bindings, bind trigger/turn, type-check body). Extract shared trigger-checking from check_reaction if needed. See plan: .claude/plans/staged-rolling-raccoon.md Steps 3-4.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:39Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:13:20Z","closed_at":"2026-02-23T06:13:20Z","close_reason":"Added FnKind::Hook, BlockKind::HookResolve, collect_hook(), check_hook(). Extracted shared check_trigger_and_body() from check_reaction. Hook context allows dice, mutation, turn, and action calls.","dependencies":[{"issue_id":"ttrpg_dsl-ixk","depends_on_id":"ttrpg_dsl-6ee","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-ji8","title":"Materialize default values for condition parameters at runtime","description":"Condition constructor evaluation (call.rs:40-58) only records explicitly passed args. It never fills in declared defaults. So condition Weakened(level: int = 1) used as bare Weakened() stores empty args, and modify/suppress clauses crash with undefined variable when accessing 'level'. Fix: after processing passed args, iterate declared params and insert defaults for any missing ones.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:37Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:02:22Z","closed_at":"2026-02-23T20:02:22Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-jkl","title":"AST: add HookDecl and Program index","description":"Add HookDecl struct to ttrpg_ast/src/ast.rs (receiver, trigger, body — like ReactionDecl minus cost). Add DeclKind::Hook variant. Add hooks HashMap and hook_order Vec to Program. Wire into build_index(). See plan: .claude/plans/staged-rolling-raccoon.md Step 1.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T05:59:00Z","closed_at":"2026-02-23T05:59:00Z","close_reason":"Added HookDecl struct, DeclKind::Hook variant, hooks HashMap + hook_order Vec to Program, wired into build_index(), and added placeholder arms in checker collect/check"}
{"id":"ttrpg_dsl-kmy","title":"Language: struct update syntax","description":"Structs are immutable value types. To change one field, the entire struct must be reconstructed. There is no spread/update syntax like:\n    let upcast_spell = spell { damage: new_damage, ..spell }\n\nThis matters for spell upcasting (change damage dice based on slot level), buff modifications, and any case where a struct is 'almost the same' with one field changed.\n\nRust-style struct update syntax (`..base`) would be a natural fit.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:52:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:52:07Z","labels":["ergonomics","language-design"]}
{"id":"ttrpg_dsl-lfm","title":"Resource bounds dropped on local-to-entity mutation path","description":"eval.rs:1192 hardcodes bounds: None in the local-to-entity path, while direct entity assignment resolves bounds (eval.rs:1104). This means mutations like trigger.target.spell_slots[level] -= 1 can bypass resource clamping when the entity is reached through a local variable.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:34Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:53:17Z","closed_at":"2026-02-23T18:53:17Z","close_reason":"Fixed in eval.rs: local-to-entity path now calls resolve_resource_bounds; eval_bound_expr now injects entity fields into temp scope for complex expressions"}
{"id":"ttrpg_dsl-m2n","title":"Adapter: clamp writes to resource-valued map entries","description":"Extend the mutation/adapter path so that writing to a map\u003cK, resource(min..max)\u003e entry applies resource clamping. When the adapter handles MutateField with path [Field(f), Index(k)], look up the field declaration for f. If value type is resource(...), extract bound expressions, evaluate them in entity context, and clamp the result. This is the core new work — bounds lookup must unwrap the map value type to find the inner resource bounds.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:51Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:23:14Z","closed_at":"2026-02-23T18:23:14Z","close_reason":"Resource bounds now resolved from AST field declarations at mutation time. eval_assign_entity looks up entity type → field def → navigates TypeExpr along path to find resource bounds → evaluates bound expressions (literals + entity field refs). MutateField effects now carry actual bounds, and adapter clamping works for both direct resource fields and resource-valued map entries. 8 integration tests verify clamping for underflow, overflow, set, auto-init, dynamic bounds, and optional groups.","dependencies":[{"issue_id":"ttrpg_dsl-m2n","depends_on_id":"ttrpg_dsl-chb","type":"blocks","created_at":"2026-02-23T09:38:03Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-mcy","title":"Parser: only one requires block allowed per action","description":"Actions can only have a single requires {} block. Multiple preconditions must be combined with \u0026\u0026 on one long line. Multiline expressions inside requires {} also fail because newlines inside braces are not suppressed (unlike parens/brackets). Either support multiple requires blocks or suppress newlines inside requires {} braces.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:48:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:48:50Z","labels":["ergonomics","parser"]}
{"id":"ttrpg_dsl-o1b","title":"Parser: parse optional groups and related syntax","description":"Parse all optional group syntax:\n- optional { fields... } blocks inside entity declarations (decl.rs: parse_entity_decl)\n- 'with GroupName' constraints on action/derive/mechanic/condition receivers and parameters (decl.rs: parse_param, parse_action_decl, etc.)\n- 'has' expressions at comparison precedence level (expr.rs)\n- 'grant entity.Group { field: val, ... }' and 'revoke entity.Group' statements (stmt.rs)\nAll new keywords (optional, grant, revoke, has, with) are soft keywords — lexed as Ident, matched by name in the parser.\nDepends on AST changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:28Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:49:45Z","closed_at":"2026-02-23T00:49:45Z","close_reason":"Parser now handles: optional groups in entities, has expressions, with constraints on params/receivers, grant/revoke statements. 16 new tests, all 860 pass.","dependencies":[{"issue_id":"ttrpg_dsl-o1b","depends_on_id":"ttrpg_dsl-950","type":"blocks","created_at":"2026-02-22T16:32:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-pzy","title":"Language: turn phase hooks (on_turn_start, on_turn_end)","description":"No way to express automatic effects at the start or end of a turn:\n- Death saves happen at start of turn when at 0 HP\n- Regeneration happens at start of turn\n- Many conditions allow a repeat save at end of turn\n- Some effects trigger 'at the start of each of your turns'\n\nEvents/reactions are for OTHER entities reacting. Need a turn-phase hook system:\n    on_turn_start(actor: Character) {\n        if actor.HP == 0 \u0026\u0026 !(Stable in actor.conditions) {\n            do DeathSave on actor ()\n        }\n    }\n\nThis interacts with the Duration system (#9) — 'until a save is made' needs an end-of-turn hook to trigger the save.","notes":"Scoped down to hook declaration type (mandatory triggered action). Condition 'on' clauses deferred. No built-in events — game designers declare their own phase events. Implementation tracked in: ttrpg_dsl-5z0 (spec), ttrpg_dsl-jkl (AST), ttrpg_dsl-6ee (parser), ttrpg_dsl-ixk (checker), ttrpg_dsl-d83 (interp), ttrpg_dsl-beu (tests). Plan: .claude/plans/staged-rolling-raccoon.md","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:27Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:28:06Z","closed_at":"2026-02-23T06:28:06Z","close_reason":"All implementation beads complete: AST (jkl), parser (6ee), checker (ixk), interpreter (d83), tests (beu), spec docs (5z0). Hook declaration type is fully implemented.","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-pzy","depends_on_id":"ttrpg_dsl-d3r","type":"related","created_at":"2026-02-22T07:51:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-q5l","title":"Language: union types for heterogeneous entity references","description":"No union or sum type beyond enum payloads. In 5e, a 'damage source' could be a Weapon, Spell, or environment. Actions that work on 'any character type' need a common base. Currently no way to write:\n    type DamageSource = Weapon | Spell | Environment\n    action Attack on attacker: Character | Monster (target: Character | Monster, ...) { ... }\n\nEnum payloads can approximate this but with significant boilerplate for wrapping/unwrapping. Entity trait system (ttrpg_dsl-s43) might subsume this need.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:47Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:47Z","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-q5l","depends_on_id":"ttrpg_dsl-s43","type":"related","created_at":"2026-02-22T08:01:47Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-qj0","title":"Tests + spec updates for parameterized conditions","description":"Add parser, checker, interpreter, and integration tests for parameterized conditions. Update spec/examples with Frightened(source) example. Remove pain-point comments.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:55Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-qj0","depends_on_id":"ttrpg_dsl-6p8","type":"blocks","created_at":"2026-02-23T11:23:03Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-qj0","depends_on_id":"ttrpg_dsl-a6m","type":"blocks","created_at":"2026-02-23T11:23:03Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-qv2","title":"Interp: grant default resolution picks first global match","description":"find_optional_group walks all entity decls and returns the first group with matching name. If two entity types define the same group name with different defaults, wrong defaults may be used. Need to resolve defaults based on the receiver's entity type.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:07Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-rh4","title":"Language: 'until next use' and 'until save' duration variants","description":"The Duration enum covers time-based and indefinite durations but not event-triggered removal. The Help action needs 'remove this condition after it applies once' (next-use). Many spell effects need 'remove when the target succeeds on a saving throw at end of turn' (until-save). These require host-side duration interpretation beyond simple countdown.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:50Z"}
{"id":"ttrpg_dsl-s43","title":"Language: entity composition / traits / mixins","description":"Entities have no composition mechanism. In 5e, a Character entity grows to 40+ fields because spellcasting, class features, and equipment all live in one flat struct. There is no way to express:\n- trait Spellcaster { spellcasting_ability: Ability, spell_save_DC: int, ... }\n- entity Wizard: Character with Spellcaster { ... }\n- Optional field groups that only exist for certain character classes\n\nClass features end up as boolean flags (has_extra_attack, has_sneak_attack, etc.) with no type safety or associated behavior.","design":"Settled on optional groups as the composition mechanism. Key decisions:\n\n- **Approach**: Optional field groups declared inside entities with `optional GroupName { fields... }`\n- **Access**: Namespaced — `actor.Spellcasting.spell_save_DC`\n- **Guards**: `has` keyword as composable boolean expression with flow-sensitive type narrowing (`if actor has Spellcasting { ... }`)\n- **Activation**: `grant`/`revoke` keywords for runtime enable/disable in action resolve blocks\n- **Deactivation**: Discard field values on revoke (groups model structural identity, not toggles)\n- **Constraints**: `with GroupName` on action/derive/mechanic/condition parameters for lightweight polymorphism\n- **Cross-entity reuse**: Deferred — manual repetition for now, door open for future mixins/traits\n\nDesign doc: spec/design/entity_composition.md\n\nSurveyed 6 TTRPG systems (D\u0026D 5e, PF2e, CoC 7e, Savage Worlds, CofD, PbtA, FATE) and evaluated traits, inheritance, mixins, and optional groups against each. Optional groups cover the highest-value use cases (class-conditional fields, multiclassing, edge-activated subsystems) with moderate complexity.","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:11Z","created_by":"Theodore Gast","updated_at":"2026-02-23T16:43:00Z","closed_at":"2026-02-23T16:43:00Z","close_reason":"All subtasks complete: AST nodes, parser, checker, interpreter, CLI integration, and end-to-end tests for optional groups are all implemented and passing.","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-5ho","type":"blocks","created_at":"2026-02-22T16:33:58Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-8d6","type":"blocks","created_at":"2026-02-22T16:33:59Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-8j9","type":"blocks","created_at":"2026-02-22T16:33:58Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-950","type":"blocks","created_at":"2026-02-22T16:33:57Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-avf","type":"blocks","created_at":"2026-02-22T16:33:59Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-o1b","type":"blocks","created_at":"2026-02-22T16:33:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-wus","title":"Language: wildcard modify targets (modify all d20 rolls)","description":"The modify system targets specific mechanic names — you must list each one separately. The Helped condition should apply advantage to both attack_roll and skill_check, but there is no way to write 'modify any mechanic that uses a d20 roll'. Would want either a wildcard mechanic name or a mechanic trait/tag system so conditions can target categories of rolls.","status":"open","priority":4,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:58Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:58Z"}
{"id":"ttrpg_dsl-x0y","title":"Checker: has narrowing keyed by root var only","description":"extract_root_var collapses actor.friend and actor.target to actor, so 'if actor.friend has Spellcasting' incorrectly narrows actor.target.Spellcasting too. Need to key narrowings by full path, not just root variable.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:04Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-xh9","title":"Language: cost overrides and free/no-cost actions","description":"Two related issues with the action cost system:\n\n1. No 'free' or 'no cost' designation. Action Surge has no action cost — omitting the cost block works but is indistinguishable from forgetting to declare a cost (potential footgun).\n\n2. No way to override the cost of an existing action. In 5e, Rogue's Cunning Action lets you Dash/Disengage/Hide as a bonus action instead of an action. Currently requires duplicating the entire action with a different cost block (CunningDash, CunningDisengage). Would like:\n    condition CunningAction on bearer: Character {\n        modify Dash.cost(actor: bearer) { cost = bonus_action }\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:17Z","labels":["language-design"]}
{"id":"ttrpg_dsl-xyp","title":"Default lookup can silently use wrong entity's optional group definition","description":"Both interpreter and CLI default-fill helpers fall back to the first matching group name if entity type is unknown (eval.rs:1916, runner.rs:1051). This makes defaults declaration-order-dependent and can apply incorrect defaults without error. Fix: treat unknown entity type during default filling as an error instead of falling back.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:33Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:41:09Z","closed_at":"2026-02-23T04:41:09Z","close_reason":"Removed fallback in find_optional_group — returns None when entity type is unknown instead of using wrong entity's defaults"}
{"id":"ttrpg_dsl-yg0","title":"Update dnd5e_expanded to use map\u003cint, resource\u003e for spell slots","description":"Replace the 9 spell_slots_N fields with a single spell_slots: map\u003cint, resource(0..9)\u003e field. Replace the 9-branch match in CastSpell with spell_slots[level] -= 1. Update any derives or references that touch spell_slots_N. This validates the feature end-to-end against the motivating use case.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:59Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:40:51Z","closed_at":"2026-02-23T18:40:51Z","close_reason":"Migrated dnd5e_expanded to use map\u003cint, resource(0..9)\u003e for spell_slots. Replaced 9 spell_slots_N fields with single resource-valued map. Replaced 9-branch matches in CureWounds and Fireball with spell_slots[slot_level] -= 1. Updated pain point comments and summary. File loads and type-checks cleanly.","dependencies":[{"issue_id":"ttrpg_dsl-yg0","depends_on_id":"ttrpg_dsl-du9","type":"blocks","created_at":"2026-02-23T09:38:05Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-zq1","title":"Language: option\u003cT\u003e destructuring and unwrapping","description":"option\u003cT\u003e values cannot be destructured or unwrapped:\n- No `some(x)` pattern in match: `match val { some(x) =\u003e x.field, none =\u003e default }`\n- No `if let` syntax: `if let some(armor) = char.equipped_armor { ... }`\n- No `.unwrap()` or `.unwrap_or(default)` methods\n- Can't use option\u003cAbility\u003e as a map index without unwrapping first\n- `none` is not a valid pattern (separate parser bug ttrpg_dsl-efg)\n\nThis blocks any idiomatic use of option fields on entities (equipped_armor, spellcasting_ability, etc.).","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T19:04:18Z","closed_at":"2026-02-22T19:04:18Z","close_reason":"All destructuring/unwrapping items complete: none pattern (ttrpg_dsl-efg), some(x) match pattern, .unwrap()/.unwrap_or(), if let some(x). Option-as-index tracked separately in ttrpg_dsl-7ch.","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-zq1","depends_on_id":"ttrpg_dsl-efg","type":"blocks","created_at":"2026-02-22T08:04:54Z","created_by":"Theodore Gast","metadata":"{}"}]}
