{"id":"ttrpg_dsl-002","title":"Add .unwrap() / .unwrap_or(default) methods on option values","description":"Allow calling .unwrap() to extract the inner value (runtime error if none) and .unwrap_or(default) to provide a fallback. Useful for cases where match is too verbose.","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:51:26Z","closed_at":"2026-02-22T18:51:26Z","close_reason":"Implemented .unwrap() and .unwrap_or(default) methods on option values"}
{"id":"ttrpg_dsl-04h","title":"Add for-loop tests for side effects and error-path scope cleanup","description":"Existing for-loop tests mostly validate return values. Need tests for: loop body side effects, scope cleanup on body error.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:10Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-09t","title":"Field/group name collisions allowed in optional groups","description":"collect.rs tracks entity fields and optional groups in separate duplicate sets, so an entity can have both a field and an optional group with the same name (e.g. Spellcasting). The checker resolves entity.Spellcasting as an optional group before normal fields, while runtime has/field reads use raw field names — creating ambiguous/incorrect behavior. Fix: make field names and optional-group names disjoint per entity during collection.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:30Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:28:34Z","closed_at":"2026-02-23T04:28:34Z","close_reason":"Added cross-check in collect_entity() to detect field/group name collisions"}
{"id":"ttrpg_dsl-0ch","title":"Resource bound evaluation is fail-open for complex expressions","description":"Bounds parse as full expressions (parser/types.rs:64-66), but runtime fallback only handles bare identifiers (eval.rs:2029). If evaluation fails, resolution returns None via ? (eval.rs:2055-2056) and assignment proceeds without bounds. Checker also does not validate bound expressions (env.rs:178). Bounds like resource(0..max_slots + 1) silently disable clamping.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:53:17Z","closed_at":"2026-02-23T18:53:17Z","close_reason":"Fixed in eval.rs: local-to-entity path now calls resolve_resource_bounds; eval_bound_expr now injects entity fields into temp scope for complex expressions"}
{"id":"ttrpg_dsl-0f1","title":"Module: resolver (resolve.rs)","description":"New resolve.rs in ttrpg_parser. Build system registry, merge same-name systems, validate imports (alias collisions, unknown targets, self-import), detect global name collisions across all namespaces, compute per-system visibility, desugar TypeExpr::Qualified to TypeExpr::Named.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:02Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:56:44Z","closed_at":"2026-02-24T00:56:44Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-0f1","depends_on_id":"ttrpg_dsl-64l","type":"blocks","created_at":"2026-02-23T16:40:23Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-0f1","depends_on_id":"ttrpg_dsl-9bu","type":"blocks","created_at":"2026-02-23T16:40:24Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-0f1","depends_on_id":"ttrpg_dsl-p9s","type":"blocks","created_at":"2026-02-23T16:40:23Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-1ar","title":"Add ..= inclusive range syntax","description":"Resolve inconsistency: .. is exclusive everywhere, ..= is inclusive. Resources change from resource(min..max) to resource(min..=max). For loops gain ..= support.","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T22:20:55Z","created_by":"Theodore Gast","updated_at":"2026-02-23T22:26:11Z","closed_at":"2026-02-23T22:26:11Z","close_reason":"Implemented ..= inclusive range syntax. All tests pass."}
{"id":"ttrpg_dsl-1sy","title":"Module: declaration ownership tracking in TypeEnv","description":"Add owner maps to TypeEnv: type_owner, function_owner, condition_owner, event_owner, option_owner, variant_owner (all HashMap\u003cString, String\u003e mapping decl name to system name). Populate during collect() when ModuleMap is provided. Add system_visibility and system_aliases fields.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:04Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:04:21Z","closed_at":"2026-02-24T01:04:21Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-1sy","depends_on_id":"ttrpg_dsl-3px","type":"blocks","created_at":"2026-02-23T16:41:09Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-1sy","depends_on_id":"ttrpg_dsl-5vq","type":"blocks","created_at":"2026-02-23T16:41:09Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-1wn","title":"GameState: auto-initialize missing resource map keys to min","description":"When reading a map\u003cK, resource(min..max)\u003e entry with a missing key, return min instead of erroring. When writing a missing key, auto-create the entry with the operation applied, then clamp. Modify read path (read_field or eval_index) and write path (write_nested) in reference_state.rs. Needs access to the resource min bound expression for the default.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:53Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:23:18Z","closed_at":"2026-02-23T18:23:18Z","close_reason":"Auto-initialization for writes already works via the adapter: compute_field_value defaults missing paths to Int(0), applies the operation, then clamps with resource bounds. With bounds now populated (from m2n), this auto-inits correctly. For reads, missing keys still error — users should initialize maps at spawn time. Test: resource_map_write_to_missing_key_auto_initializes verifies += on absent key creates the entry.","dependencies":[{"issue_id":"ttrpg_dsl-1wn","depends_on_id":"ttrpg_dsl-chb","type":"blocks","created_at":"2026-02-23T09:38:03Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-2e8","title":"Checker: validate struct update base type","description":"Update check_struct_lit() to accept and validate the base expression. Verify base is same struct type. Suppress missing-required-field errors when base is present.","status":"open","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:12:16Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:12:16Z","dependencies":[{"issue_id":"ttrpg_dsl-2e8","depends_on_id":"ttrpg_dsl-ah3","type":"blocks","created_at":"2026-02-23T20:12:25Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-34x","title":"Language: auto-succeed / auto-fail modifier for rolls","description":"The modify system only supports advantage/disadvantage as roll modifiers. In 5e, several conditions cause auto-failure on certain saves:\n- Stunned: auto-fail STR and DEX saves\n- Paralyzed: auto-fail STR and DEX saves\n- Petrified: auto-fail STR and DEX saves\n\nThe modify clause can set mode=disadvantage but cannot express 'the result is always failure'. Need either:\n- A new RollMode variant: `enum RollMode { normal, advantage, disadvantage, auto_fail, auto_succeed }`\n- Or the ability to override the result directly in a post-call modify:\n    `modify saving_throw(target: bearer) { result = SaveResult.failure }`","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-3mb","title":"Rebase + spec: handle base expr spans, update grammar","description":"Update rebase_expr in lib.rs to rebase base expression spans. Update struct_lit grammar in 03_canonical_grammar.ttrpg to include ..expr syntax.","status":"open","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:12:19Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:12:19Z","dependencies":[{"issue_id":"ttrpg_dsl-3mb","depends_on_id":"ttrpg_dsl-svl","type":"blocks","created_at":"2026-02-23T20:12:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-3px","title":"Module: span rebasing for multi-file","description":"In parse_multi step 2: compute base offsets with 1-byte sentinel gaps, rebase ALL AST spans and diagnostic spans to global offsets before merge.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:09Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:57:02Z","closed_at":"2026-02-24T00:57:02Z","close_reason":"Span rebasing implemented as part of parse_multi() in lib.rs","dependencies":[{"issue_id":"ttrpg_dsl-3px","depends_on_id":"ttrpg_dsl-0f1","type":"blocks","created_at":"2026-02-23T16:40:33Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-3px","depends_on_id":"ttrpg_dsl-4r6","type":"blocks","created_at":"2026-02-23T16:40:32Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-3px","depends_on_id":"ttrpg_dsl-h0s","type":"blocks","created_at":"2026-02-23T16:40:33Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-3v8","title":"Language: integer range / bounded int types","description":"Can't express constrained integer types like int(1..9) for spell slot levels. Plain int accepts any value — no compile-time or runtime range enforcement beyond manual checks. Would help with spell levels, ability scores (typically 1-30), proficiency multipliers, etc.","status":"open","priority":4,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:55Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:55Z"}
{"id":"ttrpg_dsl-3ww","title":"Module: multi-file load command parsing","description":"Change commands.rs load branch to collect all whitespace-delimited tokens (not just first). Stop at tokens starting with //. Preserves // within paths while stripping trailing comments.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:22Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:09:56Z","closed_at":"2026-02-24T01:09:56Z","close_reason":"Load command parsing updated to collect all whitespace-delimited tokens for multi-file support","dependencies":[{"issue_id":"ttrpg_dsl-3ww","depends_on_id":"ttrpg_dsl-1sy","type":"blocks","created_at":"2026-02-23T16:41:26Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-3ww","depends_on_id":"ttrpg_dsl-42w","type":"blocks","created_at":"2026-02-23T16:41:27Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-3ww","depends_on_id":"ttrpg_dsl-4lt","type":"blocks","created_at":"2026-02-23T16:41:28Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-3ww","depends_on_id":"ttrpg_dsl-73m","type":"blocks","created_at":"2026-02-23T16:41:27Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-3ww","depends_on_id":"ttrpg_dsl-fzw","type":"blocks","created_at":"2026-02-23T16:41:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-42w","title":"Module: option extends validation","description":"Replace existing 'extends not yet validated' warning (collect.rs:873) with actual validation: parent existence check, visibility check, circular detection. Error messages: 'extends unknown option', 'extends non-imported option', 'circular option extends'.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:14Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:04:21Z","closed_at":"2026-02-24T01:04:21Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-42w","depends_on_id":"ttrpg_dsl-3px","type":"blocks","created_at":"2026-02-23T16:41:12Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-42w","depends_on_id":"ttrpg_dsl-5vq","type":"blocks","created_at":"2026-02-23T16:41:12Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-45r","title":"Evaluate default values for struct fields in interpreter","description":"Struct fields can declare default values in the DSL (e.g. `struct Foo { x: int = 5 }`), but the interpreter currently ignores these defaults. When constructing a struct instance without providing a value for a field that has a default, the default expression should be evaluated and used. This likely needs changes in the interpreter's struct instantiation logic to check for and evaluate default expressions from the AST/Program when a field is not explicitly provided.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:14:29Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:19:10Z","closed_at":"2026-02-24T04:19:10Z","close_reason":"Added find_struct_defaults helper and filled defaults in StructLit evaluation"}
{"id":"ttrpg_dsl-46i","title":"Language: no default/zero value for DiceExpr fields","description":"Can't write sneak_attack_dice: DiceExpr = 0d6 because 0d6 isn't a valid dice literal (0 count). There's no 'empty dice expression' value. This forces workarounds like option\u003cDiceExpr\u003e or separate boolean flags for features that may not have dice. See pain point #20 in examples/dnd5e_expanded.ttrpg.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:51:01Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:51:01Z"}
{"id":"ttrpg_dsl-4km","title":"Language: list sorting, map, filter, reduce","description":"The DSL has for-loops for iteration but no way to produce transformed or ordered collections. Initiative sorting, filtering targets by condition, mapping over lists — all must be done by the host. Would need builtins like sort(), filter(), map() or list comprehensions.","status":"in_progress","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:42Z","created_by":"Theodore Gast","updated_at":"2026-02-23T21:57:54Z"}
{"id":"ttrpg_dsl-4lt","title":"Module: qualified name resolution (Alias.Name)","description":"check_ident returns ModuleAlias for aliases. resolve_field handles ModuleAlias arm (enum types, bare variants, conditions, struct/entity errors). check_call handles FieldAccess with alias LHS for function calls. Visibility-aware function lookup priority: visible user fn \u003e builtin \u003e non-visible error \u003e undefined.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:19Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:04:21Z","closed_at":"2026-02-24T01:04:21Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-4lt","depends_on_id":"ttrpg_dsl-3px","type":"blocks","created_at":"2026-02-23T16:41:13Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-4lt","depends_on_id":"ttrpg_dsl-5vq","type":"blocks","created_at":"2026-02-23T16:41:13Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-4qz","title":"Fix for-loop checker: only mark entity-typed bindings as non-local","description":"mark_current_scope_non_local() marks ALL for-loop pattern bindings as non-local, but only entity-typed ones should be non-local. Non-entity loop vars (struct, list elements) can currently bypass the immutable-local guard in action/reaction contexts.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:06Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-4r6","title":"Module: metadata types (ModuleMap, SystemInfo, ImportInfo)","description":"New module.rs in ttrpg_ast. ModuleMap with per-system namespace sets (types, functions, conditions, events, options, variants) and ImportInfo with system_name, alias, span.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:39:58Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:56:44Z","closed_at":"2026-02-24T00:56:44Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-4r6","depends_on_id":"ttrpg_dsl-64l","type":"blocks","created_at":"2026-02-23T16:40:18Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-4r6","depends_on_id":"ttrpg_dsl-9bu","type":"blocks","created_at":"2026-02-23T16:40:20Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-4r6","depends_on_id":"ttrpg_dsl-p9s","type":"blocks","created_at":"2026-02-23T16:40:19Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-4zi","title":"Value + State + Effects: parameterize runtime types","description":"Change Value::Condition from tuple to struct with args map. Add params to ActiveCondition. Add params to ApplyCondition/RemoveCondition effects. Update all pattern-match sites.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-4zi","depends_on_id":"ttrpg_dsl-62f","type":"blocks","created_at":"2026-02-23T11:23:00Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-586","title":"Language: position arithmetic and spatial queries","description":"Position is opaque — only `distance(a, b) -\u003e int` is available. Can't express:\n- 'Move target 5 feet away from shover' (Shove action)\n- 'Is attacker on the opposite side of target from ally?' (Flanking)\n- 'All creatures within 20 feet of a point' (AoE targeting)\n- Direction vectors, line-of-sight, adjacency\n\nWould need builtins like:\n    direction(from: Position, to: Position) -\u003e Direction\n    move_toward(pos: Position, target: Position, distance: int) -\u003e Position\n    move_away(pos: Position, source: Position, distance: int) -\u003e Position\n    creatures_within(center: Position, radius: int) -\u003e list\u003cCharacter\u003e","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:59Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:59Z","labels":["builtins","language-design"]}
{"id":"ttrpg_dsl-59o","title":"Validate condition parameter declarations (defaults, duplicates)","description":"collect_condition (collect.rs:723) doesn't check for duplicate param names, and check_condition (check.rs:349) doesn't validate default expression types against declared param types. condition Foo(x: int = \"oops\") and condition Foo(x: int, x: int) both pass silently. Fix: add duplicate-name check in collect, and type-check default expressions in check_condition.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:07:41Z","closed_at":"2026-02-23T20:07:41Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-5a2","title":"Bound extraction does not traverse struct field segments","description":"extract_resource_bounds_from_type only handles Index through map/list (eval.rs:2005-2008). Paths like actor.stats.spell_slots[1] where stats is a named struct type won't resolve bounds, so resource-map clamping is skipped for nested struct access patterns.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:38Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:01:47Z","closed_at":"2026-02-23T19:01:47Z","close_reason":"extract_resource_bounds_from_type now traverses Named struct types via find_struct_field"}
{"id":"ttrpg_dsl-5ho","title":"Interpreter: runtime optional group support","description":"Runtime support for optional groups:\n- Extend StateProvider trait: is_group_active(), read_group_field()\n- Extend WritableState trait: grant_group(), revoke_group()\n- Add active_groups: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e to EntityState in reference_state.rs\n- Implement grant_group: validate group not already active, store fields, return Result\n- Implement revoke_group: remove group and discard field values, return Result\n- Evaluate ExprKind::Has: call state.is_group_active()\n- Evaluate namespaced field access: actor.Group.field reads from active_groups\n- Execute grant/revoke statements: evaluate field exprs, call state methods\n- Add GrantGroup/RevokeGroup to Effect enum if using effect-based mutation path\n- Handle namespaced field writes in actions (actor.Group.field -= 1)\nDepends on checker changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:23:49Z","closed_at":"2026-02-23T01:23:49Z","close_reason":"Implemented runtime optional group support: Has expression (read_field-based), Grant/Revoke statements emitting GrantGroup/RevokeGroup effects, remove_field on WritableState, adapter + CLI handler support","dependencies":[{"issue_id":"ttrpg_dsl-5ho","depends_on_id":"ttrpg_dsl-8j9","type":"blocks","created_at":"2026-02-22T16:32:58Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-5kb","title":"Language: spell instance / effect source tracking","description":"When a caster drops concentration, the spell's effects (conditions, ongoing damage, etc.) should be removed. But there is no concept of a 'spell instance' that links applied conditions back to their source spell. Dropping concentration sets concentrating_on to none but can't automatically clean up the conditions the spell applied. Would need effect provenance tracking.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:53Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:53Z"}
{"id":"ttrpg_dsl-5nt","title":"Parser: alias shadowing check only inspects current import target","description":"Alias shadowing check claims 'all imported systems' but only checks the current import target. At resolve.rs:193, comment says check imported names broadly, but code uses only module_map.systems.get(\u0026import.system_name). Repro: use A (A exports Foo) + use B as Foo loads with no diagnostics — the alias Foo shadows A's exported name Foo silently.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T01:23:56Z","created_by":"Theodore Gast","updated_at":"2026-02-24T02:52:45Z","closed_at":"2026-02-24T02:52:45Z","close_reason":"Fixed alias collision checks: (1) own-declaration check now includes variant names, (2) imported-name check now covers all imported systems, not just the current target"}
{"id":"ttrpg_dsl-5v9","title":"Module system: multi-file imports and qualified access","description":"# Module System Design\n\n## Context\n\nThe TTRPG DSL currently processes single files. The `use` keyword is parsed but inert. This design specifies how multiple files compose via system-name-based imports, alias-based qualification, and additive system merging. The deliverable is a spec document and beads issues — no implementation yet.\n\n## Design Decisions\n\n| Decision | Choice |\n|---|---|\n| Import target | System name (`use \"D\u0026D 5e Core\"`) |\n| Transitivity | No — explicit only |\n| Conflicts | **v0**: global duplicate ban (load-time error); **v1**: error on ambiguous unqualified reference (requires qualified access to disambiguate) |\n| Qualification | Alias-based (`use \"...\" as Alias`) |\n| File loading | Explicit multi-file + glob (`load *.ttrpg`) |\n| System merging | Additive — same-name blocks merge |\n| Use scope | All uses in a file apply to all system blocks in that file |\n| Cross-system duplicates | **Banned globally in v0** (load-time error) |\n| REPL | Unchanged — flat namespace, no ambiguity possible |\n\n### Key Architectural Constraint: Global Name Uniqueness (v0)\n\nIn v0, **no two loaded systems may define the same declaration name** in the same namespace. Enforced at module resolution time (before checking).\n\n**Namespaces checked for uniqueness** (matches every flat index in `Program` and `TypeEnv`):\n- Types (enums, structs, entities)\n- Functions (derives, mechanics, actions, reactions, hooks, prompts — all share the function namespace in TypeEnv)\n- Conditions\n- Events\n- Options\n- Enum variants (via `variant_to_enum` — two enums in different systems with overlapping variant names collide)\n\nSame name in different namespaces is fine (e.g., type `Foo` and function `Foo` coexist).\n\n**Consequences**:\n- `Program.build_index()` — **unchanged** (flat HashMap, no collisions by construction)\n- `TypeEnv` — **unchanged** (flat namespace works)\n- Interpreter — **completely unchanged** (trusts checker, uses flat names)\n- Qualified access (`Core.foo()`) — **pure syntactic sugar**; checker validates the qualification and resolves to the flat name\n- REPL — **no changes**; all loaded declarations visible, no ambiguity possible\n\n**v1 upgrade path**: To allow cross-system duplicates later, `Program` indices change to `HashMap\u003cString, HashMap\u003cString, Decl\u003e\u003e` (system → name → decl). The checker produces a resolution side table `HashMap\u003cSpan, (SystemName, DeclName)\u003e` for the interpreter. The v0 `ModuleMap` already tracks per-system ownership, so the infrastructure carries forward.\n\n---\n\n## Language Surface\n\n### Syntax\n\n```\nuse_decl = \"use\" STRING (\"as\" IDENT)? term\n```\n\n`as` is a soft keyword (recognized only after a `use` string).\n\n```ttrpg\nuse \"D\u0026D 5e Core\"\nuse \"D\u0026D 5e Core\" as Core\n```\n\n### Qualified Access\n\nWith `use \"D\u0026D 5e Core\" as Core`, the alias `Core` acts as a namespace. Access chains work via the existing field-access typing pipeline:\n\n**Type position**: `Core.Ability` → parsed as `TypeExpr::Qualified { qualifier: \"Core\", name: \"Ability\" }`. Checker resolves to `Ty::Enum(\"Ability\")` after validating `Ability` belongs to the aliased system.\n\n**Expression position** — evaluated via the field-access chain:\n\n1. `Core` → `check_ident(\"Core\")` returns new `Ty::ModuleAlias(\"D\u0026D 5e Core\")`\n2. `Core.Ability` → `resolve_field(ModuleAlias, \"Ability\")` → `Ty::EnumType(\"Ability\")` (not `Ty::Enum` — mirrors `check_ident`'s behavior at `check_expr.rs:125` which returns `EnumType` for enum type names used as namespace access)\n3. `Core.Ability.STR` → `resolve_field(Ty::EnumType(\"Ability\"), \"STR\")` → existing variant resolution at `check_expr.rs:570`\n4. `Core.modifier(10)` → `check_call` sees `FieldAccess { object: Ident(\"Core\"), field: \"modifier\" }`, recognizes `Core` as a module alias, dispatches to function `modifier` after validating it belongs to the aliased system\n5. `Core.Prone` → `resolve_field(ModuleAlias, \"Prone\")` → looks up conditions in the aliased system, returns `Ty::Condition`\n\n**Critical distinction**: `resolve_field` for `ModuleAlias` must return `Ty::EnumType` (namespace marker), NOT `Ty::Enum` (value type). The existing checker rejects field access on `Ty::Enum` at `check_expr.rs:593` with \"cannot access field on enum value; use pattern matching\". Only `Ty::EnumType` supports `.Variant` access at `check_expr.rs:570`.\n\nSince names are globally unique in v0, the types returned are identical to unqualified access — the interpreter needs no changes.\n\n**New `Ty::ModuleAlias(String)`** variant in `ttrpg_checker/src/ty.rs`. Not a \"real\" type — intermediate marker consumed by `resolve_field` and `check_call`. Cannot appear in function signatures, struct fields, etc.\n\n**Changes to `resolve_field`** (`check_expr.rs:478`): Add `Ty::ModuleAlias(system_name)` arm that mirrors `check_ident` logic (lines 85-138) scoped to the aliased system:\n- If field matches an enum TYPE name → return `Ty::EnumType(name)` (for namespace access, not `Ty::Enum`)\n- If field matches a bare enum variant → return `Ty::Enum(enum_name)` (fieldless variant as value)\n- If field matches a condition name → return `Ty::Condition`\n- If field matches a struct/entity name → error: \"type cannot be used as a value\"\n- Otherwise → error: `no declaration \"X\" in system \"...\" (alias \"...\")`\n\n**Changes to `check_call`** (`check_expr.rs`): In the `FieldAccess` branch, before checking for method calls, check if the LHS is a module alias. If so, dispatch the call to the named function after validating system ownership.\n\n### System Block Merging\n\nMultiple system blocks with the same name (same or different files) merge additively. Duplicate declaration names within a merged system are errors.\n\n### Visibility Rules\n\nA system can see:\n1. Its own declarations (all fragments merged)\n2. Declarations from directly `use`'d systems (not transitive)\n3. Builtins (always)\n\n**Name resolution priority**: local scope → own system → imports → builtins\n\nLocal declarations always shadow imports (no error).\n\n### Option `extends` Resolution\n\n`option extends \"ParentOption\"` references another option by name. With the module system:\n\n- The parent option must be **visible** to the extending system (own or imported) — same rules as any other name reference.\n- `extends` targets are resolved during the checker's collect pass using the same visibility rules. The existing warning (\"option `extends` is not yet validated\") is replaced with actual validation:\n  1. Parent name exists in the options namespace → ok if visible\n  2. Parent name exists but not visible → `error: option \"X\" extends \"Y\" which belongs to system \"Z\" (not imported)`\n  3. Parent name does not exist → `error: option \"X\" extends unknown option \"Y\"`\n- Qualified extends (`extends \"Core.ParentOption\"`) is **not supported in v0**. The extends field is a plain string name, resolved via flat lookup + visibility check.\n- Circular extends (A extends B extends A) should be detected and reported as an error.\n- Cross-system extends IS valid when the parent system is imported — this is a key use case (e.g., a supplement extending a core ruleset's options).\n\n### Use Scoping Within Files\n\nAll `use` declarations in a file apply to ALL system blocks in that file. When a system spans multiple files, its imports are the union of uses from all files containing it.\n\n**Design tradeoff**: This means if a file defines systems A and B, and has `use \"C\"`, then both A and B can see C's declarations — even if the import was only intended for A. This is a deliberate simplification for v0:\n- It mirrors how most DSLs and configuration languages scope imports (file-level, not block-level).\n- Placing `use` inside a `system` block would require parser changes and creates awkward nesting for the common case where a file has one system.\n- The practical workaround is simple: put unrelated systems in separate files.\n- If per-system scoping is needed later, `use` inside `system { }` can be added as a refinement without breaking file-level `use`.\n\n### Error Cases\n\n| Scenario | Diagnostic |\n|---|---|\n| `use \"Unknown\"` | `error: unknown system \"Unknown\"` |\n| Two systems define `modifier` | `error: duplicate declaration \"modifier\": defined in \"Core\" (core.ttrpg:5) and \"Alt\" (alt.ttrpg:3)` |\n| Two systems define enum variant `STR` | `error: duplicate enum variant \"STR\": defined in \"Ability\" (system \"Core\") and \"Stat\" (system \"Alt\")` |\n| `use \"A\" as X` + `use \"B\" as X` | `error: duplicate alias \"X\": already used for \"A\"` (same alias → different targets) |\n| `use \"A\" as X` in two files for same system | Idempotent — no error (same alias → same target) |\n| Alias collides with own declaration | `error: alias \"Foo\" conflicts with declaration \"Foo\"` |\n| Alias collides with imported name | `error: alias \"modifier\" shadows imported declaration \"modifier\"` |\n| Alias collides with builtin | `error: alias \"floor\" shadows builtin function \"floor\"` (checked by checker, not resolver — builtins are defined in `ttrpg_checker::builtins`) |\n| Self-import | warning (no-op) |\n| `use` with no system block in file | warning |\n| Duplicate decl within merged system | `error: duplicate declaration \"Ability\" in system \"D\u0026D 5e Core\"` |\n| `Core.nonexistent` | `error: no declaration \"nonexistent\" in system \"D\u0026D 5e Core\" (alias \"Core\")` |\n| Unqualified name not visible | `error: \"modifier\" is not visible; it belongs to system \"Core\" which is not imported` |\n| `option extends` parent not visible | `error: option \"X\" extends \"Y\" which belongs to system \"Z\" (not imported)` |\n| `option extends` unknown parent | `error: option \"X\" extends unknown option \"Y\"` |\n| `option extends` circular | `error: circular option extends: \"A\" → \"B\" → \"A\"` |\n| Circular `use` (A↔B) | Allowed — no ordering dependency |\n\n---\n\n## Architecture Changes\n\n### Pipeline\n\n```\nCLI reads files → parse_multi (parse + lower_moves + resolve) → check_with_modules → interpret\n```\n\n`parse_multi` encapsulates the entire pre-check pipeline:\n1. Parse each file independently\n2. **`lower_moves` per file** — before resolution, so synthetic declarations (e.g., `__attack_roll`) are visible to the resolver and included in `ModuleMap` ownership/visibility\n3. Compute base offsets and **rebase all spans + diagnostics to global offsets**\n4. Merge programs into single `Program`\n5. Resolve modules (registry, validation, collision detection, visibility, desugar)\n6. Return merged Program + ModuleMap + all diagnostics (all with global offsets)\n\nThere is no separate `lower_moves` call in the CLI — it is part of `parse_multi`. The CLI calls `parse_multi` then `check_with_modules`.\n\n**Fail-fast on resolution errors**: If `parse_multi` returns any error-level diagnostics (parse errors, duplicate declarations, unknown imports, etc.), the CLI must **not** proceed to `check_with_modules` or interpretation. The merged `Program` may contain duplicate names where `build_index()` silently overwrote a HashMap entry, making downstream analysis unsound. The CLI stores the diagnostics for `errors` display and reports the error count, but does not set the program/type_env as loaded. This is the same pattern the CLI already uses for parse errors today — it's extended to cover resolution errors.\n\nModule resolution is a **language-level** concern in `ttrpg_parser`, not a CLI concern.\n\n### ttrpg_ast (`crates/ttrpg_ast/src/ast.rs`)\n\n**UseDecl** gains alias + span:\n```rust\npub struct UseDecl {\n    pub path: String,\n    pub alias: Option\u003cString\u003e,\n    pub span: Span,\n}\n```\n\n**TypeExpr** gains qualified variant:\n```rust\nTypeExpr::Qualified { qualifier: String, name: String }\n```\n\n**New module metadata types** (new file `crates/ttrpg_ast/src/module.rs`):\n```rust\npub struct ModuleMap {\n    pub systems: HashMap\u003cString, SystemInfo\u003e,\n}\n\npub struct SystemInfo {\n    // Per-namespace declaration names — mirrors TypeEnv's namespace split\n    pub types: HashSet\u003cString\u003e,\n    pub functions: HashSet\u003cString\u003e,   // derives, mechanics, actions, reactions, hooks, prompts\n    pub conditions: HashSet\u003cString\u003e,\n    pub events: HashSet\u003cString\u003e,\n    pub options: HashSet\u003cString\u003e,\n    pub variants: HashSet\u003cString\u003e,    // enum variant names\n\n    pub imports: Vec\u003cImportInfo\u003e,\n}\n\npub struct ImportInfo {\n    pub system_name: String,\n    pub alias: Option\u003cString\u003e,\n    pub span: Span,\n}\n```\n\n**Program and build_index** — **no changes**. Flat index remains runtime truth.\n\n### ttrpg_parser (`crates/ttrpg_parser/src/`)\n\n**`parser.rs`** — update `parse_use_decl` to handle `as IDENT` soft keyword.\n\n**New `resolve.rs` module**:\n```rust\n/// Takes already-rebased, merged program. Produces ModuleMap + validation diagnostics.\n/// All spans in the input program are already global offsets.\npub fn resolve_modules(\n    program: \u0026mut Program,           // merged, rebased — mutated to desugar TypeExpr::Qualified\n    file_systems: Vec\u003cFileSystemInfo\u003e, // which systems and use-decls came from which files\n) -\u003e (ModuleMap, Vec\u003cDiagnostic\u003e)\n```\n\n`FileSystemInfo` carries: filename, list of system names defined in the file, list of UseDecls in the file. This is extracted by `parse_multi` before calling `resolve_modules`.\n\n**Algorithm — split between `parse_multi` and `resolve_modules`**:\n\n`parse_multi` (steps 1-3):\n1. **Parse + lower each file**: For each source, `parse()` then `lower_moves()`. Collect per-file programs and diagnostics.\n2. **Rebase spans**: Compute base offsets (with 1-byte sentinel gaps). Rebase ALL AST spans and ALL diagnostic spans for each file to global offsets.\n3. **Merge programs**: Concatenate rebased items into a single `Program`, call `build_index()`. Extract `FileSystemInfo` per file.\n\n`resolve_modules` (steps 4-9, all spans already global):\n4. **Build system registry**: `HashMap\u003cString, Vec\u003c(file_idx, Vec\u003cSpanned\u003cDeclKind\u003e\u003e)\u003e\u003e`. Detect duplicate declarations within merged same-name systems.\n5. **Collect per-file `use` declarations**: Associate with all system blocks in that file (union).\n6. **Validate imports**: Use targets exist, alias collisions, self-imports. Alias collision rule: same alias → same target across files is **idempotent** (no error); same alias → different targets is an error. Also check alias vs own declarations and alias vs imported names. Alias-vs-builtin deferred to checker (builtins live in `ttrpg_checker::builtins`, not accessible from parser).\n7. **Detect global name collisions** across all namespaces (types, functions, conditions, events, options, enum variants). Error with both source locations.\n8. **Compute per-system visibility** (own + direct imports).\n9. **Desugar `TypeExpr::Qualified`**: Walk all AST nodes in `program.items` and replace `TypeExpr::Qualified { qualifier, name }` with `TypeExpr::Named(name)`, after validating the alias and verifying the type belongs to the aliased system. This must happen before `collect()` because `TypeEnv::resolve_type()` (`env.rs:146`) runs during pass 1b signature resolution and has no system context. Safe because names are globally unique in v0.\n10. **Return** ModuleMap + validation diagnostics (all with global offsets).\n\n**New `parse_multi` public API** in `lib.rs`:\n```rust\npub struct ParseMultiResult {\n    pub program: Program,\n    pub module_map: ModuleMap,\n    pub diagnostics: Vec\u003cDiagnostic\u003e,\n    pub has_errors: bool,  // true if any diagnostic is error-level\n}\n\npub fn parse_multi(\n    sources: \u0026[(String, String)],  // (filename, source_text)\n) -\u003e ParseMultiResult\n```\n\n**Safe consumption pattern**: `ParseMultiResult` includes `has_errors` so callers can check before proceeding. The `program` and `module_map` are always returned (even with errors) for diagnostic rendering and IDE use cases.\n\nTo prevent accidentally checking a program with duplicate names, `ParseMultiResult` provides a guarded accessor:\n\n```rust\nimpl ParseMultiResult {\n    /// Returns program + module_map only if no errors.\n    /// CLI and other callers use this before calling check_with_modules.\n    pub fn ok(\u0026self) -\u003e Option\u003c(\u0026Program, \u0026ModuleMap)\u003e {\n        if self.has_errors { None } else { Some((\u0026self.program, \u0026self.module_map)) }\n    }\n}\n```\n\nThe checker's API remains decoupled from the parser — it takes `\u0026Program` and `\u0026ModuleMap` separately:\n\n```rust\n// ttrpg_checker::lib.rs — unchanged layering\npub fn check_with_modules(program: \u0026Program, modules: \u0026ModuleMap) -\u003e CheckResult\n```\n\nThe fail-fast guard lives in the calling code (CLI), not in the checker. This keeps `ttrpg_checker` independently usable — test code can construct a `Program` + `ModuleMap` directly without going through `parse_multi`.\n\n**Diagnostic span rebasing**: Parse and lower diagnostics from file N have local-offset spans. In `parse_multi`, span rebasing (algorithm step 2) applies to ALL spans — both AST node spans and diagnostic spans — BEFORE any validation or collision detection. This ensures:\n- Parse diagnostics: rebased alongside their file's AST spans\n- Lower diagnostics: rebased alongside their file's AST spans\n- Resolution diagnostics (steps 4-9): produced with global offsets naturally, since they reference already-rebased AST spans\n\n**`types.rs`** — update type parsing to handle `IDENT \".\" IDENT` as `TypeExpr::Qualified`.\n\n### Multi-File Span Handling\n\n**`Span` type is unchanged** (`{ start: usize, end: usize }`).\n\n**Span rebasing during merge**: Each file gets a base offset with a **1-byte sentinel gap** between files to avoid boundary ambiguity (EOF of file N at offset `base_N + len(source_N)` would otherwise collide with start of file N+1):\n- File 0: base = 0\n- File 1: base = len(source_0) + 1\n- File 2: base = len(source_0) + 1 + len(source_1) + 1\n- General: base_N = sum(len(source_i) + 1 for i in 0..N)\n\nThe sentinel byte is a logical gap — it does not appear in any source text or span. It ensures that a span at exactly EOF of file N (`base_N + len(source_N)`) cannot be attributed to file N+1 (`base_{N+1}`).\n\nNo physical source concatenation occurs.\n\n**New `MultiSourceMap`** in `crates/ttrpg_ast/src/diagnostic.rs`:\n\n```rust\n/// Renders diagnostics across multiple source files.\n/// Owns source strings to avoid self-referential borrowing in the host.\npub struct MultiSourceMap {\n    files: Vec\u003cFileEntry\u003e,\n}\n\nstruct FileEntry {\n    filename: String,\n    base_offset: usize,\n    /// Half-open upper bound: base_offset + source.len().\n    /// Valid span starts satisfy: base_offset \u003c= start \u003c= end_exclusive.\n    /// The `\u003c=` on the right allows zero-width EOF spans (start == end_exclusive).\n    /// The 1-byte sentinel gap guarantees end_exclusive \u003c next file's base_offset.\n    end_exclusive: usize,\n    source: String,       // owned — avoids self-borrow issues in Runner\n    line_starts: Vec\u003cusize\u003e,\n}\n```\n\n**Owning design**: `MultiSourceMap` stores owned `String` sources (moved or cloned from the loaded file contents). This avoids the self-referential struct problem where `Runner` would need to store both `Vec\u003c(String, String)\u003e` sources and a `MultiSourceMap\u003c'a\u003e` borrowing from them — that pattern is not representable in safe Rust.\n\n`MultiSourceMap` does NOT wrap `SourceMap` instances. It reimplements line/col computation with its own `line_starts` per file. The rendering logic from `SourceMap::render` is factored into a shared free function or duplicated (it's ~15 lines).\n\n`MultiSourceMap::render(diag)`:\n1. Find which file owns the span: iterate `files`, match on `base_offset \u003c= span.start \u003c= end_exclusive`. This is a closed check on both sides: `end_exclusive` equals `base_offset + source.len()`, and a span at exactly that offset is a zero-width EOF span (e.g., \"unexpected end of file\") that still belongs to this file. The 1-byte sentinel gap guarantees `end_exclusive \u003c next_file.base_offset`, so no ambiguity.\n2. Subtract the file's `base_offset` to get local span offsets\n3. Compute line/col from the file's `line_starts` and `source`\n4. Render with `filename:line:col` prefix (extends the existing rustc-style format)\n\n**Uniform usage**: `MultiSourceMap` is constructed for ALL `load` commands, including single-file loads (it works fine with one file entry). This means all `load`-sourced diagnostics use the rich `filename:line:col` format uniformly. The legacy `[error] message` format (no spans) is only used for REPL `eval` errors and other contexts where no source map exists. Existing `SourceMap\u003c'a\u003e` remains available for non-CLI consumers (tests, library callers).\n\n### ttrpg_checker (`crates/ttrpg_checker/src/`)\n\n**New entry point** in `lib.rs`:\n```rust\npub fn check_with_modules(program: \u0026Program, modules: \u0026ModuleMap) -\u003e CheckResult\n```\n\nTakes `\u0026Program` and `\u0026ModuleMap` directly — no dependency on `ParseMultiResult`. Callers are responsible for not passing programs with duplicate names (enforced by `ParseMultiResult::ok()` guard in the CLI). The existing `check(program)` remains for backward compatibility (single-file, no module constraints).\n\n**`collect.rs`** — `collect()` accepts optional `\u0026ModuleMap`. During collection, tracks which system owns each declaration:\n```rust\n// New fields in TypeEnv — one owner map per namespace\npub type_owner: HashMap\u003cString, String\u003e,      // decl name → system name\npub function_owner: HashMap\u003cString, String\u003e,\npub condition_owner: HashMap\u003cString, String\u003e,\npub event_owner: HashMap\u003cString, String\u003e,\npub option_owner: HashMap\u003cString, String\u003e,\npub variant_owner: HashMap\u003cString, String\u003e,   // variant name → system name (via owning enum)\n\npub system_visibility: HashMap\u003cString, VisibleNames\u003e,\npub system_aliases: HashMap\u003cString, HashMap\u003cString, String\u003e\u003e, // system → {alias → target_system}\n```\n\nEvery namespace that has a global uniqueness constraint must have an owner map. The `option_owner` map is required for `extends` visibility checks. The `variant_owner` map is required for qualified access to bare variants (`Core.STR`) and for \"not visible\" diagnostics that name the owning system.\n\n`VisibleNames` per system:\n```rust\npub struct VisibleNames {\n    pub types: HashSet\u003cString\u003e,\n    pub functions: HashSet\u003cString\u003e,\n    pub conditions: HashSet\u003cString\u003e,\n    pub events: HashSet\u003cString\u003e,\n    pub variants: HashSet\u003cString\u003e,\n    pub options: HashSet\u003cString\u003e,\n}\n```\n\nComputed as: own declarations ∪ (union of all directly imported systems' declarations).\n\n**`ty.rs`** — add `Ty::ModuleAlias(String)`:\n- Intermediate marker type for module alias identifiers\n- Cannot appear in function signatures, struct fields, etc.\n- Consumed by `resolve_field` and `check_call`\n\n**`check.rs`** — `Checker` gains `current_system: Option\u003cString\u003e`, set when entering each system block. Name lookups are gated:\n\n```rust\nfn is_name_visible(\u0026self, name: \u0026str, namespace: Namespace) -\u003e bool {\n    let system = match \u0026self.current_system {\n        Some(s) =\u003e s,\n        None =\u003e return true, // REPL / single-file mode: everything visible\n    };\n    match self.env.system_visibility.get(system) {\n        Some(vis) =\u003e vis.contains(name, namespace),\n        None =\u003e true, // no module info: legacy mode\n    }\n}\n```\n\n**Comprehensive visibility gating** — the checker resolves names in several places beyond `check_expr.rs` and `check_pattern.rs`. Each must be gated by `is_name_visible` to prevent module-visibility bypasses:\n\n| Call site | What's looked up | Gate needed |\n|---|---|---|\n| `check.rs:202` `check_trigger_and_body` | `self.env.events.get(\u0026trigger.event_name)` — trigger event | `is_name_visible(event_name, Namespace::Event)` before lookup |\n| `check_modify.rs:22` `check_modify_clause` | `self.env.lookup_fn(\u0026clause.target)` — modify target fn | `is_name_visible(target, Namespace::Function)` before lookup |\n| `check_modify.rs:278` `check_suppress_clause` | `self.env.events.get(\u0026clause.event_name)` — suppress event | `is_name_visible(event_name, Namespace::Event)` before lookup |\n| `check_stmt.rs:317,413` `check_narrowing` | `self.env.lookup_optional_group(entity, group)` — optional group | Entity type already resolved via `resolve_type` which is visibility-gated (see below); group names are entity-internal, not system-scoped — **no extra gate needed** |\n\nFor all gated sites: if the name exists in the env but is not visible, emit `error: \"X\" is not visible; it belongs to system \"Y\" which is not imported` (same message as check_expr). If the name doesn't exist at all, fall through to the existing \"not defined\" error.\n\n**`env.rs` — visibility-aware `resolve_type`**: `resolve_type` is called from ~20 sites across `check.rs`, `check_stmt.rs`, `check_modify.rs`, and `collect.rs` (let annotations, function signatures, receiver types, parameter types, field types, etc.). Rather than gating every callsite individually, `resolve_type` itself becomes visibility-aware:\n\n```rust\n// New method on TypeEnv\npub fn resolve_type_visible(\n    \u0026self,\n    type_expr: \u0026Spanned\u003cTypeExpr\u003e,\n    current_system: Option\u003c\u0026str\u003e,\n    visibility: Option\u003c\u0026HashMap\u003cString, VisibleNames\u003e\u003e,\n) -\u003e (Ty, Option\u003cDiagnostic\u003e)\n```\n\nWhen `current_system` is `Some` and the resolved type name is not visible, returns `(Ty::Error, Some(diagnostic))`. When `current_system` is `None` (REPL/single-file), behaves identically to existing `resolve_type`. The existing `resolve_type(\u0026self, expr) -\u003e Ty` remains as a convenience wrapper that passes `None` for backward compatibility.\n\nThe `Checker` calls `resolve_type_visible` with its `current_system`, collecting any emitted diagnostic. This covers ALL type annotation paths uniformly:\n- `check_stmt.rs:33` — `let x: Type = ...`\n- `check.rs:78,87` — derive/mechanic return types\n- `check.rs:96,148,175` — action/reaction/hook receiver types\n- `check.rs:355,419,495` — function parameter types\n- `check.rs:440,460,477` — struct/entity field types\n- `check_modify.rs:49,281` — condition receiver types\n- `check_modify.rs:69,157,293` — parameter/annotation types in modify/suppress\n\n**Other `env.rs` methods**:\n- `lookup_fn` at `env.rs:231`: Remains visibility-unaware. Gated at each callsite (`check_call` in check_expr.rs, `check_modify_clause` in check_modify.rs) where the caller has `current_system` context.\n- `lookup_fields` at `env.rs:237`: Called for struct literal checking — the struct type name was already visibility-checked when the type was resolved, so field access on an already-validated type does not need a second gate.\n- `lookup_optional_group` at `env.rs:246`: Entity type already visibility-checked via `resolve_type_visible`.\n\n**`collect.rs`** — **alias-vs-builtin validation**: After `register_builtin_types` and builtin function registration (end of collect pass), if a `ModuleMap` is provided, iterate all alias names from `system_aliases` and check each against the builtin function table (`BUILTIN_FUNCTIONS` or equivalent lookup). Emit `error: alias \"floor\" shadows builtin function \"floor\"` for any collision. This is an **eager, declaration-site check** — it fires even if the alias is never used, matching the behavior of alias-vs-own-declaration and alias-vs-import collisions (which are also declaration-site errors in `resolve_modules`). The check lives in the checker because builtins are defined in `ttrpg_checker::builtins`, not accessible from the parser.\n\n**`check_expr.rs`** — four changes:\n1. **`check_ident`**: After local scope and before enum/variant/condition checks, if name matches a module alias for `current_system`, return `Ty::ModuleAlias(system_name)`. Aliases are validated at resolution time to not shadow own declarations or imported names, so this insertion point cannot silently shadow a name found later in the lookup chain. Alias-vs-builtin is checked eagerly in `collect.rs` (see above), so no shadowing can occur at lookup time.\n2. **`resolve_field`**: Add `Ty::ModuleAlias(system_name)` arm — look up the field in the aliased system's declarations across all namespaces (types, conditions, enum variants, etc.) and return the appropriate type.\n3. **`check_call` FieldAccess branch**: Before existing enum-variant-constructor logic, check if LHS identifier is a module alias. If so, validate the field name belongs to the aliased system and dispatch to normal function checking.\n4. **`check_call` direct calls**: When resolving a function name (at `check_expr.rs:762+`), visibility must be checked without breaking builtin fallback. Current `lookup_fn` does user-fn-first → builtin-second (`env.rs:231`). The visibility-aware lookup must follow this priority:\n   - Visible user fn (own + imported) → use it\n   - Builtin → use it\n   - Non-visible user fn exists → error: \"not visible; belongs to system X which is not imported\"\n   - Not found → error: \"undefined\"\n\n   A non-visible user function must NOT shadow a builtin. For example, if system \"A\" defines `floor()` and system \"B\" doesn't import \"A\", calling `floor()` in B should resolve to the builtin, not error with \"floor is not visible.\" The same logic applies to conditions and any other namespace with builtin entries.\n5. **`check_pattern`**: Pattern matching resolves enum names/variants from global env (`check_pattern.rs:85`, `check_pattern.rs:142`). Add `is_name_visible` checks when resolving enum/variant names in pattern position to close this visibility gap.\n\n**`collect.rs`** — visibility for type signatures: During pass 1b signature resolution, the collector calls `resolve_type_visible` (see env.rs above) with `current_system` set to the system being collected. The collector already iterates system blocks, so it knows which system it's processing. This gates ALL type references in function signatures, field types, parameter types, etc. Without this, a function signature could reference a type from a non-imported system and the error would only appear if the type happened to be used in the function body.\n\n### ttrpg_interp — **No changes in v0**\n\nSince names are globally unique, qualified access is resolved to unqualified names by the checker, and the flat `Program`/`TypeEnv` indices work unchanged.\n\n### ttrpg_cli (`crates/ttrpg_cli/src/`)\n\n**`commands.rs`** — `load` currently takes only the first token (line 51: `let (path, _) = split_first_token(tail_trimmed)`). This must change to pass all path tokens. **Critical**: `strip_comment` must NOT be used for load paths because `//` can appear in valid file paths (see `commands.rs:36-38` and test at line 307). Instead, tokenize by whitespace and stop collecting tokens when a token starts with `//`:\n\n```rust\n\"load\" =\u003e {\n    let tail_trimmed = tail.trim_start();\n    // Collect all whitespace-delimited tokens until one starts with \"//\"\n    let mut paths = String::new();\n    for token in tail_trimmed.split_whitespace() {\n        if token.starts_with(\"//\") {\n            break; // rest is a comment\n        }\n        if !paths.is_empty() {\n            paths.push(' ');\n        }\n        paths.push_str(token);\n    }\n    if paths.is_empty() {\n        Some(Command::Unknown(\"load\".into()))\n    } else {\n        Some(Command::Load(paths))\n    }\n}\n```\n\nThis preserves `//` within paths (e.g., `/tmp//file.ttrpg` is a single token) while stripping trailing `// comment` (which starts a new token with `//`).\n\n**Known limitation**: Paths that START with `//` (e.g., UNC paths `//server/share/file.ttrpg`) will be treated as comment markers. This is acceptable for v0 — TTRPG DSL files do not use UNC paths in practice. If needed, a future version could support quoted paths (`load \"//path\"`).\n\n**`runner.rs`** — `cmd_load` changes:\n```rust\nfn cmd_load(\u0026mut self, tail: \u0026str) -\u003e Result\u003c(), CliError\u003e {\n    // 1. Split tail into whitespace-delimited tokens\n    // 2. For each token: if it contains glob chars (* ? [), expand with `glob` crate\n    //    and sort the expanded results alphabetically for determinism\n    //    Otherwise treat as literal path (preserving user-specified order)\n    // 3. Dedup while preserving first occurrence\n    //    (user order matters: reactions/options maintain declaration order)\n    // 4. Read all files into Vec\u003c(String, String)\u003e\n    // 5. Call ttrpg_parser::parse_multi(\u0026sources) → ParseMultiResult\n    //    (this handles parse + lower_moves + resolve internally)\n    // 6. If parse_result.ok() returns Some((program, module_map)):\n    //       call ttrpg_checker::check_with_modules(program, module_map)\n    //    Else: store parse diagnostics, skip checking\n    // 7. Construct owning MultiSourceMap from sources\n    // 8. Store program, type_env, diagnostics, last_paths, multi_source_map\n}\n```\n\n**Path ordering**: Explicit paths preserve user order (`load a.ttrpg b.ttrpg` → a first, then b). Glob expansions are sorted alphabetically within each glob for determinism, then inserted at the glob's position in the argument list. This matters because `reaction_order`, `option_order`, and `hook_order` depend on declaration order.\n\n**Glob failure modes**:\n- Glob matches zero files → **hard error**: `error: no files matched pattern \"*.foo\"`. This is not silent because a zero-match glob almost certainly indicates a typo or wrong directory, and silently loading nothing would produce confusing downstream errors (e.g., \"unknown system\" when the user thought the file was loaded).\n- Glob syntax error (e.g., unclosed `[`) → hard error from the `glob` crate, propagated as `error: invalid glob pattern \"...\"`.\n- Literal path does not exist → hard error: `error: file not found: \"missing.ttrpg\"` (existing behavior, unchanged).\n- Glob matches files but some are unreadable → hard error on the unreadable file (fail-fast, not partial load).\n\n`last_path: Option\u003cPathBuf\u003e` → `last_paths: Vec\u003cPathBuf\u003e` for `reload`.\n\n**`runner.rs` diagnostic rendering** (line 341-351) — currently `cmd_errors` prints `[severity] message` without spans. After a `load` or `reload`, a `MultiSourceMap` is always constructed (even for single-file loads), so diagnostics use `filename:line:col` with caret underlines uniformly:\n\n```rust\n// New field on Runner (owning, no lifetime parameter needed)\nmulti_source_map: Option\u003cMultiSourceMap\u003e,\n\n// In cmd_errors:\nif let Some(ref map) = self.multi_source_map {\n    for diag in \u0026self.diagnostics {\n        self.output.push(map.render(diag));\n    }\n} else {\n    // Fallback: [severity] message (before any file is loaded)\n    for diag in \u0026self.diagnostics {\n        self.output.push(format!(\"[{}] {}\", severity_str(diag), diag.message));\n    }\n}\n```\n\nSince `MultiSourceMap` owns its source strings, no self-referential borrowing issues arise. The fallback path is only hit when no file has been loaded (edge case). Note: REPL `eval` errors do **not** flow through `self.diagnostics` — they are returned directly as `CliError::Message` from the `eval()` method (`runner.rs:207-244`). The `cmd_errors` command only shows diagnostics from file loading (parse/check errors), not from interactive eval.\n\n**Dependency**: Add `glob` crate to `ttrpg_cli/Cargo.toml`.\n\n---\n\n## Implementation Phases (Beads Issues)\n\n### Phase 1: AST + Parser Foundation\n1. **Extend UseDecl** — add `alias: Option\u003cString\u003e`, `span: Span` fields in `ast.rs`\n2. **Parse `use ... as`** — soft keyword `as` in `parser.rs`, update `parse_use_decl`\n3. **Add TypeExpr::Qualified** — new variant, parse `IDENT.IDENT` in type position (`types.rs`)\n\n### Phase 2: Module Metadata + Resolution\n4. **Module metadata types** — new `module.rs` in ttrpg_ast: `ModuleMap`, `SystemInfo`, `ImportInfo`\n5. **Module resolver** — new `resolve.rs` in ttrpg_parser: system registry, merging, validation, global duplicate detection across all namespaces, visibility computation, **TypeExpr::Qualified desugaring** (rewrite to TypeExpr::Named before collect)\n6. **Multi-file parse API** — `parse_multi()` in ttrpg_parser `lib.rs`\n\n### Phase 3: Multi-File Diagnostics\n7. **Span rebasing** — offset spans during `parse_multi` (step 2), before program merge\n8. **MultiSourceMap** — new owning struct in `diagnostic.rs` (owns `String` sources + `line_starts` per file); does NOT wrap `SourceMap` instances\n\n### Phase 4: Checker Module Awareness\n9. **Declaration ownership tracking** — collector records which system owns each name in TypeEnv\n10. **`Ty::ModuleAlias`** — new intermediate marker type in `ty.rs`\n11. **Visibility enforcement** — checker gates lookups via `is_name_visible()`, reports \"not visible\" errors. Gates in: `check_expr` (expressions/calls), `check_pattern` (patterns), `check.rs` (trigger events), `check_modify.rs` (modify targets, suppress events), `collect.rs` (type signatures in pass 1b). Also: **alias-vs-builtin validation** (eager, declaration-site check in collect pass)\n11b. **Option `extends` validation** — replace the existing warning with actual validation: parent existence, visibility, circular detection\n12. **Qualified name resolution** — `check_ident` returns `ModuleAlias` for aliases; `resolve_field` handles `ModuleAlias` arm for types/conditions/variants; `check_call` handles `FieldAccess` with alias LHS for function calls\n\n### Phase 5: CLI Integration\n13. **Multi-file load command parsing** — change `commands.rs` `load` branch to pass full tail (not just first token)\n14. **Multi-file load + glob** — `glob` crate, multi-path `cmd_load`, `reload` with `Vec\u003cPathBuf\u003e`\n15. **Diagnostic rendering** — store loaded sources on Runner, construct `MultiSourceMap`, update `cmd_errors` to use `MultiSourceMap::render()`\n\n### Phase 6: Spec + Tests\n16. **Update spec** — `spec/v0/02_scoping.ttrpg` with new grammar and semantics\n17. **Integration tests** — multi-file fixtures exercising all edge cases\n\n---\n\n## Verification\n\n### Core functionality\n- Parse `use \"X\" as Y` and verify AST has alias\n- Parse `Core.Character` as type, verify `TypeExpr::Qualified`\n- Multi-file load: two files with different systems → merged Program has both\n- Same-name system blocks across files merge correctly\n- `load a.ttrpg b.ttrpg` → preserves explicit ordering (a first)\n- `load *.ttrpg` → glob results sorted alphabetically\n- `load /tmp//file.ttrpg` → `//` in path preserved (not treated as comment)\n- `load *.nonexistent` → hard error \"no files matched pattern\"\n- `load a.ttrpg *.nonexistent b.ttrpg` → hard error (fail-fast, not partial load)\n\n### Global duplicate detection\n- Two systems define `modifier` (function) → load-time error naming both files/lines\n- Two systems define `Ability` (type) → error\n- Two enums in different systems define variant `STR` → error (variant namespace collision)\n- Same name in different namespaces (type `Foo` + function `Foo`) → **not** a conflict\n- Duplicate declaration within same merged system → error\n\n### Visibility enforcement\n- System A uses System B: A can reference B's declarations\n- System A does NOT use System C: A referencing C's declaration → \"not visible\" error\n- Transitive: A uses B, B uses C, A references C → error (not transitive)\n\n### Non-expression visibility enforcement\n- Reaction trigger referencing non-imported event → \"not visible\" error (`check.rs:202`)\n- Hook trigger referencing non-imported event → \"not visible\" error (same path)\n- Suppress clause referencing non-imported event → \"not visible\" error (`check_modify.rs:278`)\n- Modify clause targeting non-imported function → \"not visible\" error (`check_modify.rs:22`)\n- Modify clause targeting an imported function → valid\n- Suppress clause targeting an imported event → valid\n- Type signature in function referencing non-imported type → \"not visible\" error (collect pass 1b)\n- `let x: NonImportedType = ...` in function body → \"not visible\" error (`check_stmt.rs:33` via `resolve_type_visible`)\n\n### Qualified access (all chains)\n- `Core.modifier(10)` — function call through alias (`check_call` FieldAccess dispatch)\n- `Core.Ability` — type name through alias (expression position → `Ty::EnumType`, NOT `Ty::Enum`)\n- `Core.Ability.STR` — enum variant through alias (two-step: `ModuleAlias` → `EnumType` → variant)\n- `Core.Prone` — condition name through alias → `Ty::Condition`\n- `Core.nonexistent` → error naming the aliased system\n- `UnknownAlias.foo` → \"undefined variable\" (not a known alias)\n- `Core.Character` in type position → `TypeExpr::Qualified` desugared to `TypeExpr::Named(\"Character\")` during resolution, before `collect()`\n- `Core.Character` in type position within a function signature → works because desugar happens pre-collect\n\n### Option extends\n- `option X extends \"Y\"` where Y is in an imported system → valid\n- `option X extends \"Y\"` where Y is in a non-imported system → \"not imported\" error\n- `option X extends \"Y\"` where Y does not exist → \"unknown option\" error\n- Circular extends (A→B→A) → error\n- `option X extends \"Y\"` where Y is in the same system → valid (trivial case)\n\n### Edge cases\n- Circular use (A↔B) → both see each other, no error\n- Self-import → warning\n- Use with no system block → warning\n- Local declaration shadows import → no error\n- Alias collides with own declaration → error\n- Alias collides with another alias → error\n- Alias shadows imported declaration → error\n- Alias shadows builtin function name → error\n- Same `use \"A\" as X` in two files for same system → idempotent, no error\n- `use \"A\" as X` + `use \"B\" as X` in different files for same system → error (different targets)\n\n### Backward compatibility\n- Single-file `load core.ttrpg` → works exactly as before\n- `check(program)` without modules → no visibility restrictions\n- REPL `eval` with no system context → everything visible\n- All existing tests pass unchanged\n\n### Diagnostic rendering\n- **All `load` paths** (single- and multi-file): `MultiSourceMap` always constructed, `cmd_errors` displays diagnostics with `filename:line:col` and caret underlines. Existing single-file load tests that assert `[error] message` format must be updated to expect the new rich format.\n- **REPL `eval` errors**: NOT stored in `self.diagnostics` — returned directly as `CliError::Message` from `eval()` (`runner.rs:207`). `cmd_errors` never displays eval errors. No change to eval error flow.\n- Span rebasing: error in file 2 points to correct line (not offset by file 1's length)\n- Span at exact EOF of file N correctly attributed to file N (not file N+1) — sentinel gap\n\n### Fail-fast gating\n- Duplicate declaration across systems → checker never runs, no secondary errors\n- Parse error in one file → resolution still runs on other files' AST, but checker never runs\n- Resolution warning (self-import) → checker still runs (warnings don't gate)\n\n### Regressions to verify\n- Existing `load /tmp//file.ttrpg` test passes (commands.rs:307)\n- Existing `load /some/path // comment` test passes (commands.rs:316)\n- All existing single-file tests pass unchanged\n- Declaration order (reactions, options, hooks) is deterministic and matches file load order\n- Alias collision introduced by cross-file system fragment union detected correctly","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:39:23Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:18:03Z","closed_at":"2026-02-24T01:18:03Z","close_reason":"All 18 sub-issues complete: AST extensions, parser, resolver, metadata types, span rebasing, parse_multi API, MultiSourceMap, checker infrastructure (ownership, visibility, aliases, Ty::ModuleAlias, option extends validation), CLI integration (multi-file load, glob, diagnostics), integration tests, spec update","dependencies":[{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-0f1","type":"blocks","created_at":"2026-02-23T16:40:45Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-3px","type":"blocks","created_at":"2026-02-23T16:40:46Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-4r6","type":"blocks","created_at":"2026-02-23T16:40:44Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-5vq","type":"blocks","created_at":"2026-02-23T16:40:46Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-64l","type":"blocks","created_at":"2026-02-23T16:40:43Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-7hs","type":"blocks","created_at":"2026-02-23T16:41:54Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-9bu","type":"blocks","created_at":"2026-02-23T16:40:44Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-h0s","type":"blocks","created_at":"2026-02-23T16:40:45Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-p9s","type":"blocks","created_at":"2026-02-23T16:40:43Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5v9","depends_on_id":"ttrpg_dsl-v50","type":"blocks","created_at":"2026-02-23T16:41:53Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-5vq","title":"Module: MultiSourceMap for diagnostic rendering","description":"New owning MultiSourceMap in diagnostic.rs. Stores owned String sources + line_starts per file. end_exclusive field (half-open bound, allows EOF zero-width spans). render(diag) maps global span to filename:line:col.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:13Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:58:22Z","closed_at":"2026-02-24T00:58:22Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-5vq","depends_on_id":"ttrpg_dsl-0f1","type":"blocks","created_at":"2026-02-23T16:40:37Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5vq","depends_on_id":"ttrpg_dsl-4r6","type":"blocks","created_at":"2026-02-23T16:40:36Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-5vq","depends_on_id":"ttrpg_dsl-h0s","type":"blocks","created_at":"2026-02-23T16:40:37Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-5yt","title":"Language: indexed resources / map of resources","description":"Spell slots in 5e are a resource indexed by level (1-9). The DSL forces 9 separate fields:\n    spell_slots_1: int = 0\n    spell_slots_2: int = 0\n    ...\n    spell_slots_9: int = 0\n\nIdeally: `spell_slots: map\u003cint, resource(0..max_slots)\u003e`\nBut resource types cannot be values in a map. There is also no way to use a runtime int to select a field (no computed field access like `entity.spell_slots[level]`).","design":"## Design: map\u003cK, resource(min..max)\u003e\n\n### Two-Step Approach\n1. **Ship now (Option B):** resource as map value type with uniform bounds\n2. **Design for next (F-lite):** key-aware bounds resolver as extension\n\n### Type System Changes\n- Accept resource(...) as valid map value type (TypeExpr::Map already supports nesting)\n- Resolve map[key] to Ty::Resource when map's value type is resource\n- Bounds storage: keep on AST TypeExpr (adapter looks up field declarations, unwraps map value type to find resource bounds) — no Ty::Resource refactor needed\n\n### Missing Key Policy\n- Read missing key → return min (no mutation, matches resource-starts-at-minimum semantics)\n- Write missing key → auto-create entry, apply operation, clamp to [min, max]\n\n### Mutation Path\nPath like entity.spell_slots[3] -= 1 yields [Field(\"spell_slots\"), Index(Int(3))]:\n1. Adapter resolves field declaration for spell_slots\n2. Sees map\u003cint, resource(0..max)\u003e, extracts bound exprs from inner resource type\n3. Evaluates bounds in entity context (max could be a derive)\n4. Applies operation, clamps result to [min, max]\nSteps 2-4 are new work; path walking already exists in write_nested.\n\n### Initialization\n- Map literal syntax: spell_slots = { 1: 4, 2: 3, 3: 3, ... }\n- Values clamped on init too\n\n### Uniform bounds only (for now)\n- resource(0..9) means every key shares the same min/max\n- F-lite extension later adds key-parameterized bounds: resource(0..max_slots(key))\n\n### What it looks like\n```\noptional Spellcasting {\n    spell_slots: map\u003cint, resource(0..9)\u003e\n}\naction CastSpell(caster, spell_name, spell_level) {\n    require caster.Spellcasting.spell_slots[spell_level] \u003e 0\n    caster.Spellcasting.spell_slots[spell_level] -= 1\n}\n```\n\n### Rejected alternatives\n- Option C (computed field names): fragile, untyped\n- Option E (plain maps, no resource): defeats resource safety purpose\n- Option D (fixed-size arrays): future sugar after map-resource is solid","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:02Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:40:51Z","closed_at":"2026-02-23T18:40:51Z","close_reason":"Migrated dnd5e_expanded to use map\u003cint, resource(0..9)\u003e for spell_slots. Replaced 9 spell_slots_N fields with single resource-valued map. Replaced 9-branch matches in CureWounds and Fireball with spell_slots[slot_level] -= 1. Updated pain point comments and summary. File loads and type-checks cleanly.","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-5z0","title":"Spec: document hook declaration syntax and semantics","description":"Update spec/v0/ files to document the new hook declaration type. Add hook row to permission table in 02_scoping.ttrpg, add grammar rule in 03_canonical_grammar.ttrpg, add examples in 04_full_example.ttrpg. Hook is a mandatory triggered action (like reaction minus cost). Uses same trigger syntax as reactions, fires automatically on event match. See plan: .claude/plans/staged-rolling-raccoon.md Step 8.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:35Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:27:40Z","closed_at":"2026-02-23T06:27:40Z","close_reason":"Added hook documentation to all three spec files: permission table and description in 02_scoping, grammar rule in 03_canonical_grammar, worked example in 04_full_example"}
{"id":"ttrpg_dsl-62f","title":"AST + Parser: add params to ConditionDecl and parse them","description":"Add params: Vec\u003cParam\u003e field to ConditionDecl in ttrpg_ast. Update parser to parse optional (params) between condition name and 'on' keyword.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:48Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh"}
{"id":"ttrpg_dsl-64l","title":"Module: extend UseDecl with alias and span","description":"Add alias: Option\u003cString\u003e and span: Span fields to UseDecl in ast.rs. Update all existing UseDecl construction sites.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:39:46Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:47:36Z","closed_at":"2026-02-24T00:47:36Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-671","title":"spawn is not atomic when inline optional groups are present","description":"runner.rs:444 creates the entity and binds the handle before inline-group validation/application at :449. Any later error (unknown group field, missing required field, default-eval error) returns Err but leaves partially created state behind. Fix: validate inline optional groups before mutating state, or roll back on error.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:33Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:34:10Z","closed_at":"2026-02-23T04:34:10Z","close_reason":"Reordered cmd_spawn to validate+prepare inline groups before mutating state"}
{"id":"ttrpg_dsl-68l","title":"Interpreter: merge base fields with overrides","description":"Update StructLit eval arm: evaluate base expr, destructure Value::Struct to get BTreeMap, evaluate explicit fields and insert (overriding base), return merged struct.","status":"open","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:12:17Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:12:17Z","dependencies":[{"issue_id":"ttrpg_dsl-68l","depends_on_id":"ttrpg_dsl-2e8","type":"blocks","created_at":"2026-02-23T20:12:25Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6ee","title":"Parser: implement parse_hook_decl","description":"Add parse_hook_decl() to ttrpg_parser/src/decl.rs. Wire 'hook' soft keyword in dispatch. Reuse parse_trigger_param() and parse_with_groups(). Body is a bare block (no cost/resolve wrappers). See plan: .claude/plans/staged-rolling-raccoon.md Step 2.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:37Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:08:08Z","closed_at":"2026-02-23T06:08:08Z","close_reason":"Added parse_hook_decl() to decl.rs and wired 'hook' soft keyword in parse_decl dispatch. Reuses parse_trigger_param(), parse_with_groups(), and parse_block() for bare body.","dependencies":[{"issue_id":"ttrpg_dsl-6ee","depends_on_id":"ttrpg_dsl-jkl","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6o0","title":"Enforce with-group constraints on condition call arguments","description":"Function calls enforce with_groups on params (check_expr.rs:969), but condition calls (check_expr.rs:798) skip this check entirely. condition Frightened(source: Character with Spellcasting) called as Frightened(actor) where actor is plain Character emits no diagnostic. Fix: add with-group enforcement parallel to what function calls do.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:43Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:07:41Z","closed_at":"2026-02-23T20:07:41Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-6o0","depends_on_id":"ttrpg_dsl-czr","type":"blocks","created_at":"2026-02-23T11:54:46Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6o7","title":"Module: multi-file load + glob expansion","description":"Add glob crate to ttrpg_cli. cmd_load: split tokens, expand globs alphabetically, dedup preserving first occurrence, read files, call parse_multi, check via ok() guard. Hard error on zero-match globs. last_paths: Vec\u003cPathBuf\u003e for reload.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:26Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:09:57Z","closed_at":"2026-02-24T01:09:57Z","close_reason":"Multi-file load with glob expansion, parse_multi, check_with_modules integrated in runner.rs","dependencies":[{"issue_id":"ttrpg_dsl-6o7","depends_on_id":"ttrpg_dsl-1sy","type":"blocks","created_at":"2026-02-23T16:41:28Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-6o7","depends_on_id":"ttrpg_dsl-42w","type":"blocks","created_at":"2026-02-23T16:41:29Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-6o7","depends_on_id":"ttrpg_dsl-4lt","type":"blocks","created_at":"2026-02-23T16:41:30Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-6o7","depends_on_id":"ttrpg_dsl-73m","type":"blocks","created_at":"2026-02-23T16:41:29Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-6o7","depends_on_id":"ttrpg_dsl-fzw","type":"blocks","created_at":"2026-02-23T16:41:29Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6p8","title":"Checker: type-check condition params and calls","description":"Add params to ConditionInfo. Register in collect_condition. Handle condition calls in check_call. Error on bare use of parameterized conditions. Bind params in modify/suppress clause scopes.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:51Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-6p8","depends_on_id":"ttrpg_dsl-4zi","type":"blocks","created_at":"2026-02-23T11:23:01Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-6p8","depends_on_id":"ttrpg_dsl-62f","type":"blocks","created_at":"2026-02-23T11:23:01Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6su","title":"Implement some(x) pattern matching for option\u003cT\u003e","description":"Add some(x) pattern to match expressions, fix none pattern bug (doesn't match Value::Option(None)), update dnd5e_expanded example","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:21:15Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:27:37Z","closed_at":"2026-02-22T18:27:37Z","close_reason":"Implemented some(x) pattern matching, fixed none bug, added tests, updated dnd5e example"}
{"id":"ttrpg_dsl-73m","title":"Module: visibility enforcement in checker","description":"Add is_name_visible() to Checker gated by current_system. Gate ALL name resolution paths: check_expr (expressions/calls), check_pattern (patterns), check.rs:202 (trigger events), check_modify.rs:22 (modify targets), check_modify.rs:278 (suppress events). Add resolve_type_visible on TypeEnv for ~20 type annotation callsites. Add alias-vs-builtin eager validation in collect pass.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:11Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:04:21Z","closed_at":"2026-02-24T01:04:21Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-73m","depends_on_id":"ttrpg_dsl-3px","type":"blocks","created_at":"2026-02-23T16:41:11Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-73m","depends_on_id":"ttrpg_dsl-5vq","type":"blocks","created_at":"2026-02-23T16:41:11Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-7ch","title":"Transparent option-as-index: use option\u003cAbility\u003e to index into abilities[]","description":"Allow option\u003cT\u003e to be used where T is expected for indexing operations, with a runtime error if none. E.g. abilities[spellcasting_ability] where spellcasting_ability: option\u003cAbility\u003e.","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:20Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:12:02Z","closed_at":"2026-02-23T20:12:02Z","close_reason":"WON'T FIX: use a guard"}
{"id":"ttrpg_dsl-7fv","title":"Language: dynamic dice construction","description":"DiceExpr literals are compile-time only. There is no way to construct a dice expression from runtime values. This means upcast spells need a match per slot level:\n    match slot_level { 1 =\u003e 1d8, 2 =\u003e 2d8, 3 =\u003e 3d8, ... }\n\nNeed something like:\n    dice(count: slot_level, sides: 8)  // -\u003e DiceExpr\nor a builtin:\n    make_dice(slot_level, 8) -\u003e DiceExpr\n\nAlso: there is no zero/empty DiceExpr value, so DiceExpr fields cannot have defaults.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:19Z","created_by":"Theodore Gast","updated_at":"2026-02-23T15:50:49Z","closed_at":"2026-02-23T15:50:49Z","close_reason":"Implemented dice(count, sides) builtin","labels":["language-design"]}
{"id":"ttrpg_dsl-7hs","title":"Module: integration tests for multi-file loading","description":"Multi-file fixtures covering: basic multi-file load, system merging, duplicate detection (all namespaces), visibility enforcement (expression, pattern, trigger, modify, suppress, type annotations), qualified access chains, alias edge cases, glob expansion, fail-fast gating, diagnostic rendering, backward compatibility.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:36Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:16:50Z","closed_at":"2026-02-24T01:16:50Z","close_reason":"Added 8 integration tests: basic multi-file load, reload, cross-system duplicate detection, error rendering with filenames, glob expansion, nonexistent file, no-match glob, single-file backward compat","dependencies":[{"issue_id":"ttrpg_dsl-7hs","depends_on_id":"ttrpg_dsl-3ww","type":"blocks","created_at":"2026-02-23T16:41:41Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-7hs","depends_on_id":"ttrpg_dsl-6o7","type":"blocks","created_at":"2026-02-23T16:41:42Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-7hs","depends_on_id":"ttrpg_dsl-dkf","type":"blocks","created_at":"2026-02-23T16:41:42Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-7r4","title":"Language: condition composition / inheritance","description":"Many 5e conditions include effects of other conditions:\n- Stunned includes Incapacitated (can't take actions/reactions)\n- Unconscious includes Prone + Incapacitated\n- Paralyzed includes Incapacitated + auto-fail STR/DEX saves\n\nCurrently all effects must be duplicated in each condition. Would like:\n    condition Stunned extends Incapacitated on bearer: Character { ... }\nor:\n    condition Stunned on bearer: Character {\n        include Incapacitated\n        ...additional effects...\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:32Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:32Z","labels":["language-design"]}
{"id":"ttrpg_dsl-82h","title":"Implement eval handle.field access in REPL","description":"Currently `eval handle.field` does not work — handles are not in the interpreter's eval scope (confirmed by test at runner.rs:1697). This was explicitly deferred from ttrpg_dsl-avf.\n\nThe goal is to make expressions like `eval hero.HP`, `eval hero.Spellcasting.spell_slots`, and `eval hero.Spellcasting` work in the CLI by injecting handle bindings into the interpreter's evaluation context before calling evaluate_expr.\n\nThis likely requires either:\n1. Pre-processing the expression to substitute handle.field references with their values before eval, or\n2. Extending the interpreter to accept an environment of handle→entity bindings so that handle names resolve during expression evaluation\n\nApproach 2 is cleaner but requires interpreter changes. Approach 1 can be done entirely in the CLI crate.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T02:30:46Z","created_by":"Theodore Gast","updated_at":"2026-02-23T16:12:30Z","closed_at":"2026-02-23T16:12:30Z","close_reason":"Added evaluate_expr_with_bindings to Interpreter and updated Runner::eval to inject handle bindings into scope"}
{"id":"ttrpg_dsl-8d6","title":"Tests: optional group end-to-end coverage","description":"Comprehensive test coverage for optional groups:\n- Parser tests: entity with optional groups, has expressions, grant/revoke stmts, with constraints\n- Checker tests: valid/invalid group access, narrowing through if-has, with constraints on actions/derives, grant/revoke only in actions, duplicate group names, nonexistent groups\n- Interpreter tests: grant/revoke lifecycle, has evaluation, namespaced field read/write, grant with defaults, revoke discards values, double-grant error, revoke-inactive error\n- Integration test: full 5e-style example with Character having optional Spellcasting and KiPowers, actions with 'with' constraints, guards in derives\n- CLI tests: spawn with inline groups, grant/revoke commands, eval namespaced paths\nDepends on all implementation tasks.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:41:15Z","closed_at":"2026-02-23T02:41:15Z","close_reason":"Added 12 end-to-end integration tests in optional_groups_integration.rs exercising the full pipeline (parse→lower→check→interpret) for optional groups: pipeline validation, has expression, grant/revoke via actions with StateAdapter, full lifecycle with multiple groups, with-constrained actions, derives with has-guards, per-entity independence, and effect emission verification. Existing unit tests in parser/checker/interp/CLI already cover syntax parsing, type checking, and CLI commands comprehensively.","dependencies":[{"issue_id":"ttrpg_dsl-8d6","depends_on_id":"ttrpg_dsl-avf","type":"blocks","created_at":"2026-02-22T16:32:59Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-8j9","title":"Checker: type check optional groups","description":"Type checking for optional groups:\n- Add OptionalGroupInfo to EntityInfo in env.rs, populate during collection (collect.rs)\n- Validate optional group declarations: unique names, valid field types, no nesting\n- Type check ExprKind::Has: entity type must have the named group, result is bool\n- Type check grant/revoke: only allowed in action/reaction resolve blocks, validate group exists and field types match\n- Validate 'with' constraints on params: entity type must declare the named group\n- Flow-sensitive type narrowing: track which groups are narrowed-as-active in scope (if entity has Group { ... }, early return after negative guard)\n- Reject access to entity.Group.field without a guard or 'with' constraint\n- Automatically narrow groups inside action/derive bodies when 'with' constraint is present\nDepends on parser changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:05:24Z","closed_at":"2026-02-23T01:05:24Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-8j9","depends_on_id":"ttrpg_dsl-o1b","type":"blocks","created_at":"2026-02-22T16:32:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-8tu","title":"Language: enum-associated data / lookup tables","description":"Enums can't carry associated data beyond variant payloads. The Skill-\u003eAbility mapping requires an 18-branch match derive for what is essentially static data. Would want either enum-level associated constants (enum Skill { athletics(ability: STR), ... }) or a const map type for lookup tables.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:47Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:47Z"}
{"id":"ttrpg_dsl-950","title":"AST: add optional group nodes","description":"Add AST types for optional groups:\n- OptionalGroup struct (name + fields) on EntityDecl\n- ExprKind::Has { entity, group_name } for guard expressions\n- StmtKind::Grant { entity, group_name, fields } and StmtKind::Revoke { entity, group_name }\n- with_groups: Vec\u003cString\u003e on Param and receiver_with_groups on ActionDecl/ReactionDecl/ConditionDecl/FnDecl\nFile: ttrpg_ast/src/ast.rs","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:23Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:45:29Z","closed_at":"2026-02-23T00:45:29Z","close_reason":"Added OptionalGroup on EntityDecl, ExprKind::Has, StmtKind::Grant/Revoke, with_groups on Param, receiver_with_groups on ActionDecl/ReactionDecl/ConditionDecl. All 844 tests pass."}
{"id":"ttrpg_dsl-9bu","title":"Module: add TypeExpr::Qualified variant","description":"Add TypeExpr::Qualified { qualifier: String, name: String } variant. Parse IDENT.IDENT in type position in types.rs.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:39:55Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:47:36Z","closed_at":"2026-02-24T00:47:36Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-9n0","title":"Alias-qualified calls bypass with-group constraints","description":"check_expr.rs alias call paths (~line 2347, 2421) reimplement call checking but omit with_groups enforcement present in normal call paths (~line 876, 1102). Core.needs_rage(c) passes without diagnostics when needs_rage(c) correctly errors.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T02:28:54Z","created_by":"Theodore Gast","updated_at":"2026-02-24T02:30:48Z","closed_at":"2026-02-24T02:30:48Z","close_reason":"Added with_groups enforcement to both check_alias_condition_call and check_alias_function_call paths"}
{"id":"ttrpg_dsl-9ng","title":"Parser: wildcard `_` not supported in modify bindings","description":"The spec (02_scoping.ttrpg:278) shows `modify attack_roll(attacker: _, target: _)` but the parser rejects _ in modify bindings because parse_modify_binding() calls parse_expr(), and Underscore is not a valid expression. Needed for option when-enabled blocks where there is no receiver to bind against.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:57Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:51Z","closed_at":"2026-02-22T17:28:51Z","close_reason":"Added wildcard _ support in parse_modify_binding(). Made ModifyBinding.value Option\u003cSpanned\u003cExprKind\u003e\u003e, updated checker and interpreter to skip type-check/match for None.","labels":["parser"]}
{"id":"ttrpg_dsl-a6m","title":"Interpreter: condition call dispatch + pipeline param binding","description":"Handle condition calls in eval_call (build parameterized Value::Condition). Update builtins to extract/pass params. Bind condition params in pipeline (modify/suppress scopes). Update adapter, GameState, CLI handler.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:53Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-a6m","depends_on_id":"ttrpg_dsl-4zi","type":"blocks","created_at":"2026-02-23T11:23:02Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-a6m","depends_on_id":"ttrpg_dsl-62f","type":"blocks","created_at":"2026-02-23T11:23:02Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-ah3","title":"Parser: parse ..base in struct literals","description":"Update is_struct_lit_start() to recognize IDENT { DotDot pattern. Update parse_struct_lit() to parse ..expr after fields (must come last). Allow trailing comma after ..base.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:12:15Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:25:08Z","closed_at":"2026-02-24T04:25:08Z","close_reason":"Parser now handles ..base in struct literals: is_struct_lit_start recognizes IDENT { DotDot, parse_struct_lit handles ..expr as first or last element with optional trailing comma","dependencies":[{"issue_id":"ttrpg_dsl-ah3","depends_on_id":"ttrpg_dsl-svl","type":"blocks","created_at":"2026-02-23T20:12:24Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-am8","title":"Add regression tests for resource-map edge cases","description":"Test coverage misses: (1) deep local-to-entity mutation with bounds (trigger.target.spell_slots[level] -= 1 should clamp), (2) complex bound expressions failing silently (resource(0..max_slots + 1)), (3) struct-field traversal for bound extraction (actor.stats.spell_slots[1]). Existing deep-entity test checks path/op but not bounds (eval.rs:5050).","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:01:47Z","closed_at":"2026-02-23T19:01:47Z","close_reason":"6 regression tests added covering: trigger payload bounds, complex bound expressions, struct field traversal","dependencies":[{"issue_id":"ttrpg_dsl-am8","depends_on_id":"ttrpg_dsl-0ch","type":"blocks","created_at":"2026-02-23T10:47:45Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-am8","depends_on_id":"ttrpg_dsl-5a2","type":"blocks","created_at":"2026-02-23T10:47:46Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-am8","depends_on_id":"ttrpg_dsl-lfm","type":"blocks","created_at":"2026-02-23T10:47:45Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-avf","title":"CLI: grant/revoke commands and spawn integration","description":"CLI support for optional groups:\n- New 'grant handle.GroupName { field: val, ... }' command\n- New 'revoke handle.GroupName' command\n- Extend spawn to accept inline groups: spawn Type handle { field: val, Group { field: val } }\n- Extend parse_field_block to distinguish regular fields from group activations\n- Validate group names and field types against TypeEnv during grant and spawn\n- Extend eval to handle namespaced paths (eval hero.Spellcasting.spell_save_DC)\n- Extend set to handle namespaced paths\n- Update completer.rs for group name completion\n- Update accessor methods (entity_type_names, field_names) to include group info\nDepends on interpreter changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:45Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:17:01Z","closed_at":"2026-02-23T02:17:01Z","close_reason":"Implemented CLI grant/revoke commands, extended spawn/set/inspect/types/state for optional groups, updated completer and highlighter","dependencies":[{"issue_id":"ttrpg_dsl-avf","depends_on_id":"ttrpg_dsl-5ho","type":"blocks","created_at":"2026-02-22T16:32:58Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-bcc","title":"Language: entity destruction / lifecycle management","description":"No way to remove entities from the game. Death in 5e is permanent removal of a character, but the DSL has no destroy() or remove_entity() builtin. Entities are created via spawn but never destroyed. Needed for: character death, destroying objects, banishment effects.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:44Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:44Z"}
{"id":"ttrpg_dsl-beu","title":"Tests: hook declaration parser, checker, and interpreter tests","description":"Parser tests: basic parse, with_groups, soft keyword. Checker tests: undefined event, shadow trigger/turn, struct receiver rejected, direct call rejected, binding type mismatch. Interpreter tests (new hook_integration.rs): fires on matching event, skips non-matching entity, can mutate/roll, declaration order, not suppressed. See plan: .claude/plans/staged-rolling-raccoon.md Step 7.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:43Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:22:14Z","closed_at":"2026-02-23T06:22:14Z","close_reason":"Added 3 parser tests, 9 checker tests (including hook direct call rejection fix in check_expr.rs), and 11 interpreter integration tests in hook_integration.rs","dependencies":[{"issue_id":"ttrpg_dsl-beu","depends_on_id":"ttrpg_dsl-d83","type":"blocks","created_at":"2026-02-22T21:55:49Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-c2y","title":"Parser: missing skip_newlines between cost and requires blocks","description":"In parse_action_decl (decl.rs:253-263), there is no skip_newlines() call between parsing the cost clause and checking for a requires clause. Comments or blank lines between cost {} and requires {} cause the requires to be silently skipped, and the parser then fails on 'expected resolve, found requires'. Fix: add self.skip_newlines() between the cost and requires parsing blocks.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:37Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:06:10Z","closed_at":"2026-02-22T17:06:10Z","close_reason":"Added skip_newlines() between cost and requires parsing in parse_action_decl. Added regression test.","labels":["parser"]}
{"id":"ttrpg_dsl-ccr","title":"Add if-let some(x) = expr syntax","description":"Allow if let some(x) = optional_expr { ... } else { ... } as a more ergonomic alternative to match for single-pattern option destructuring","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:15Z","created_by":"Theodore Gast","updated_at":"2026-02-22T19:04:01Z","closed_at":"2026-02-22T19:04:01Z","close_reason":"Added ExprKind::IfLet to AST, parser, checker, and interpreter. Supports if let some(x) = expr { ... } else { ... } with else-if-let chaining and nested patterns."}
{"id":"ttrpg_dsl-ccz","title":"Tests: struct update syntax","description":"Add checker tests (valid update, wrong type base, non-struct base, regression for missing-field without base). Add interpreter unit tests (override one field, base-only). Add end-to-end integration test.","status":"open","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:12:20Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:12:20Z","dependencies":[{"issue_id":"ttrpg_dsl-ccz","depends_on_id":"ttrpg_dsl-3mb","type":"blocks","created_at":"2026-02-23T20:12:27Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-ccz","depends_on_id":"ttrpg_dsl-68l","type":"blocks","created_at":"2026-02-23T20:12:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-chb","title":"Checker: accept resource() as map value type","description":"Update type resolution so map\u003cK, resource(min..max)\u003e is valid. Verify TypeExpr::Map(key, TypeExpr::Resource(min, max)) resolves correctly. Ensure map[key] expressions resolve to Ty::Resource so arithmetic/mutation type-check. May already partially work — verify and fix any rejection points.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:47Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:42:30Z","closed_at":"2026-02-23T17:42:30Z","close_reason":"Checker already accepts map\u003cK, resource(min..max)\u003e through generic type composition. No code changes needed — added 4 tests confirming declaration, read, mutation, and optional group access all type-check correctly."}
{"id":"ttrpg_dsl-clo","title":"Language: automatic event emission from mutations","description":"When `target.HP -= amount` happens in an action, the runtime does not automatically emit a takes_damage event. The host must manually fire all events. Similarly for condition application.\n\nWould enable reactive patterns without host involvement:\n    entity Character {\n        HP: resource(0..max_HP) {\n            on_decrease =\u003e emit takes_damage(source: current_actor, amount: delta, damage_type: ...)\n        }\n    }\n\nThis would let concentration checks fire automatically when a concentrating caster takes damage.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ctc","title":"Language: typed prompts (return entity refs, not strings)","description":"Prompts always return string. For 'choose a target creature', the host must map the string back to an entity reference externally. Would be more type-safe to support:\n    prompt choose_target(chooser: Character, candidates: list\u003cCharacter\u003e) -\u003e Character\n    prompt choose_weapon(chooser: Character) -\u003e Weapon\n\nThis would let the interpreter validate the response type and eliminate string-to-entity mapping in the host.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:07Z","labels":["language-design"]}
{"id":"ttrpg_dsl-czr","title":"Fix named argument validation for condition calls","description":"Checker ignores arg.name and type-checks condition params by positional index only (check_expr.rs:819). Interpreter uses arg.name if present (call.rs:46), so Frightened(src: actor) passes checker but stores 'src' instead of 'source', causing runtime undefined variable. Fix: validate that named args match declared param names, and resolve positional vs named args consistently in both checker and interpreter.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:34Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:02:22Z","closed_at":"2026-02-23T20:02:22Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-d3r","title":"Language: additional Duration variants","description":"The built-in Duration enum has: end_of_turn, start_of_next_turn, rounds(count), minutes(count), indefinite.\n\nMissing duration types needed for 5e:\n- 'until next use': Help action grants advantage on the target's NEXT attack/check, then the condition auto-removes. Many buff spells work this way.\n- 'until a save is made': Many spell effects (Hold Person, etc.) let the target repeat a save at end of each turn. The condition persists until they succeed.\n- 'until concentration ends': Spells like Bless last as long as the caster maintains concentration.\n\nThese could be additional Duration variants or a separate mechanism.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:59Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:01:26Z","closed_at":"2026-02-23T17:01:26Z","close_reason":"Duration is now a ruleset-customizable enum (like TurnBudget). Removed hardcoded DurationValue/Value::Duration. Builtin fallback has only 'indefinite'. Rulesets define their own variants via enum Duration { ... }.","labels":["language-design"]}
{"id":"ttrpg_dsl-d83","title":"Interpreter: implement execute_hook and fire_hooks","description":"Add ActionKind::Hook to effect.rs. Add execute_hook() to action.rs (emit ActionStarted/Completed, bind receiver+trigger, execute body — no cost deduction). Add find_matching_hooks() to event.rs (reuse match_trigger_bindings, no suppression). Add fire_hooks() public API to lib.rs. See plan: .claude/plans/staged-rolling-raccoon.md Steps 5-6.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:41Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:17:26Z","closed_at":"2026-02-23T06:17:26Z","close_reason":"Implemented ActionKind::Hook variant, execute_hook in action.rs, find_matching_hooks+HookInfo in event.rs, and execute_hook/what_hooks/fire_hooks public API on Interpreter","dependencies":[{"issue_id":"ttrpg_dsl-d83","depends_on_id":"ttrpg_dsl-ixk","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dkf","title":"Module: diagnostic rendering with MultiSourceMap","description":"Store MultiSourceMap on Runner (owning, no lifetime). cmd_errors uses map.render() for filename:line:col format. Uniform for all load paths (single and multi-file). Fallback [severity] message only before any file loaded. REPL eval errors unchanged (CliError::Message, not stored diagnostics).","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:29Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:09:57Z","closed_at":"2026-02-24T01:09:57Z","close_reason":"MultiSourceMap stored on Runner, cmd_errors uses map.render() for rich diagnostic output","dependencies":[{"issue_id":"ttrpg_dsl-dkf","depends_on_id":"ttrpg_dsl-1sy","type":"blocks","created_at":"2026-02-23T16:41:30Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dkf","depends_on_id":"ttrpg_dsl-42w","type":"blocks","created_at":"2026-02-23T16:41:32Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dkf","depends_on_id":"ttrpg_dsl-4lt","type":"blocks","created_at":"2026-02-23T16:41:32Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dkf","depends_on_id":"ttrpg_dsl-73m","type":"blocks","created_at":"2026-02-23T16:41:31Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dkf","depends_on_id":"ttrpg_dsl-fzw","type":"blocks","created_at":"2026-02-23T16:41:31Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-du9","title":"Tests: resource-valued maps end-to-end","description":"Add tests covering: (1) declaring map\u003cint, resource(0..N)\u003e fields, (2) spawning entities with initialized resource maps, (3) mutating via entity.field[key] -= 1 with clamping, (4) reading missing keys returns min, (5) writing missing keys auto-creates clamped entries, (6) type errors for invalid operations on resource map values. Cover checker, interpreter, and integration levels.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:56Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:38:44Z","closed_at":"2026-02-23T18:38:44Z","close_reason":"Added 8 checker tests (type errors: wrong key type, assign string, += string, += float, enum keys, arithmetic, comparison, nonzero min) and 8 interpreter tests (nonzero min underflow/clamp-up/auto-init, multiple keys in one action, derive reads, enum-keyed maps read+mutate+clamp). Total coverage: 12 checker tests + 16 interp tests for resource-valued maps.","dependencies":[{"issue_id":"ttrpg_dsl-du9","depends_on_id":"ttrpg_dsl-1wn","type":"blocks","created_at":"2026-02-23T09:38:04Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-du9","depends_on_id":"ttrpg_dsl-m2n","type":"blocks","created_at":"2026-02-23T09:38:04Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3","title":"Language: bounded iteration / loops","description":"The DSL has no loop construct. This blocks modeling:\n- Extra Attack (make N attack rolls where N depends on level)\n- AoE spells (apply damage to N targets)\n- Multi-damage-type processing (iterate over list\u003cDamageSpec\u003e)\n- Spell slot deduction (9-branch match instead of indexed access)\n\nA bounded `for` loop would cover most cases:\n    for target in targets { ... }\n    for i in 1..attack_count(attacker) { ... }\n\nUnbounded while loops are probably not needed for TTRPG modeling.","design":"# Design: Bounded Iteration / For-Loops\n\n## Motivation\n\nThe DSL has no loop construct. This blocks modeling common TTRPG patterns:\n\n- **Extra Attack**: make N attack rolls where N depends on level\n- **AoE spells**: apply damage to each target in a list\n- **Multi-damage processing**: iterate over `list\u003cDamageSpec\u003e` to resolve each\n- **Buff/debuff application**: apply a condition to multiple entities\n\nAll motivating cases involve iterating over a bounded, known-size collection\nor a small integer range. Unbounded `while` loops are not needed.\n\n---\n\n## Syntax\n\n### For-each (collection iteration)\n\n    for PATTERN in EXPR { BODY }\n\n### For-range (numeric iteration)\n\n    for IDENT in EXPR..EXPR { BODY }\n\nThe `..` produces a half-open range: `0..3` iterates over `0, 1, 2`.\n\n`for` is an expression (consistent with `if` and `match`). It appears in\n`primary_expr` alongside `if_expr` and `match_expr`.\n\n### Examples\n\n```ttrpg\n// Iterate over a list of targets\nfor target in targets {\n    target.HP -= damage\n}\n\n// Range-based iteration (Extra Attack)\nfor i in 0..extra_attacks(attacker) {\n    let result = resolve_melee_attack(attacker, target, weapon)\n    match result {\n        hit(amount) =\u003e { target.HP -= amount },\n        miss =\u003e {}\n    }\n}\n\n// Pattern matching — filter + destructure\nfor hit(amount) in results {\n    total_damage += amount\n}\n\n// Option filtering\nfor some(value) in optional_items {\n    process(value)\n}\n\n// AoE with saving throws\nfor target in targets {\n    let save = roll(d20_expr(score: target.abilities[DEX]))\n    if save \u003c DC {\n        target.HP -= damage_roll.total\n    } else {\n        target.HP -= floor(damage_roll.total / 2)\n    }\n}\n```\n\n---\n\n## Semantics\n\n### Iterable types\n\n| Source          | Binding type | Iteration order          |\n|-----------------|--------------|--------------------------|\n| `list\u003cT\u003e`       | `T`          | Index order              |\n| `set\u003cT\u003e`        | `T`          | Sorted order (BTreeSet)  |\n| `a..b` (range)  | `int`        | Ascending, half-open     |\n\nMap iteration is **deferred** to a future issue. Users who need map\nkeys/values can use `keys(map)` / `values(map)` builtins (also deferred;\nmaps are not the motivating use case for loops).\n\n### Return value\n\n**For-loops return `unit`.**\n\nFor-loops exist for side-effectful iteration — the primary TTRPG use cases\nare all about mutating game state (dealing damage, applying conditions,\nrolling dice). Returning unit keeps the implementation simple and avoids\nintroducing `list\u003cunit\u003e` as a type.\n\nFuture enhancement: collection semantics (`for x in xs { f(x) }` returns\n`list\u003cT\u003e`) could be added later. The AST and parser design below are\nforward-compatible with this change, which would be non-breaking (it makes\npreviously-erroring code valid rather than changing existing behavior).\n\n### Scoping\n\nEach iteration gets a fresh lexical scope:\n1. Push scope\n2. Bind loop variable(s) from pattern\n3. Evaluate body\n4. Pop scope\n\nLoop variables are immutable (consistent with `let` bindings). Mutation\nhappens through entity field assignment (`target.HP -= amount`), not\nthrough loop variable rebinding.\n\n### Empty collection / empty range\n\n- Empty list/set: zero iterations, returns `unit`\n- `a..b` where `a \u003e= b`: zero iterations, returns `unit`\n\n### Pattern matching in loops\n\nFor-loops support the full pattern infrastructure (reusing `PatternKind`):\n\n| Pattern               | Effect                                  |\n|-----------------------|-----------------------------------------|\n| `x`                   | Irrefutable — binds every element        |\n| `hit(amount)`         | Destructure enum variant, skip non-match |\n| `some(value)`         | Unwrap option, skip `none` values        |\n| `_`                   | Wildcard — matches all, binds nothing    |\n| `MyStruct(a, b)`      | Destructure, skip non-match             |\n\nWhen a pattern does not match an element, that iteration is **silently\nskipped**. This provides built-in filtering without a separate construct.\n\n### No break / continue\n\nNot included in this design. Bounded TTRPG collections are small, and\nconditional logic within the loop body (`if`/`match`) covers skip and\nearly-exit patterns adequately. These can be added later if needed.\n\n---\n\n## Grammar changes\n\nNew production in `primary_expr`:\n\n    primary_expr    = ... | for_expr\n    for_expr        = \"for\" pattern \"in\" for_source block\n    for_source      = expr \"..\" expr       // range\n                    | expr                 // collection\n\nDisambiguation: parse the expression after `in`. Since `..` is not a\nbinary operator in expression context, the expression parser naturally\nstops before `..`. If the next token is `DotDot`, parse the range end;\notherwise treat the expression as a collection iterable.\n\n### Newline handling\n\n`for` starts an expression — no special NL suppression rules needed beyond\nwhat `{` already provides. The `in` keyword already suppresses NL after it\n(it is a binary operator in the existing grammar).\n\n---\n\n## Keyword changes\n\n- Add `for` as a **reserved keyword** (`TokenKind::For`)\n- `in` already reserved, `..` already a token (`DotDot`)\n\n`for` is not currently used as an identifier anywhere in the spec or\nexamples. Reserving it is non-breaking for existing programs.\n\n---\n\n## AST changes\n\nNew variant in `ExprKind`:\n\n```rust\nFor {\n    pattern: Box\u003cSpanned\u003cPatternKind\u003e\u003e,\n    iterable: ForIterable,\n    body: Block,\n},\n```\n\nNew enum:\n\n```rust\npub enum ForIterable {\n    Collection(Box\u003cSpanned\u003cExprKind\u003e\u003e),\n    Range {\n        start: Box\u003cSpanned\u003cExprKind\u003e\u003e,\n        end: Box\u003cSpanned\u003cExprKind\u003e\u003e,\n    },\n}\n```\n\nThis unified representation keeps type-checking and evaluation logic\nshared between collection and range iteration.\n\n---\n\n## Type checker changes\n\nNew rules in `check_expr`:\n\n1. **For-each**: `for P in E { B }`\n   - `E` must have type `list\u003cT\u003e` or `set\u003cT\u003e`\n   - Pattern `P` checked against element type `T` (reuse `check_pattern`)\n   - Body `B` type-checked in scope with pattern bindings\n   - Expression type: `unit`\n\n2. **For-range**: `for x in A..B { C }`\n   - `A` and `B` must have type `int`\n   - `x` binds as `int`\n   - Body `C` type-checked with `x: int` in scope\n   - Expression type: `unit`\n\nError cases:\n- `for x in 42 { ... }` → \"expected list or set, found int\"\n- `for x in some_map { ... }` → \"map iteration not supported; use keys() or values()\"\n- `for x in 1.5..10 { ... }` → \"range bounds must be int\"\n\n---\n\n## Interpreter changes\n\nNew function `eval_for`:\n\n```rust\nfn eval_for(env: \u0026mut Env, pattern: \u0026PatternKind,\n            iterable: \u0026ForIterable, body: \u0026Block)\n            -\u003e Result\u003cValue, RuntimeError\u003e\n{\n    let items: Vec\u003cValue\u003e = match iterable {\n        ForIterable::Collection(expr) =\u003e match eval_expr(env, expr)? {\n            Value::List(items) =\u003e items,\n            Value::Set(items) =\u003e items.into_iter().map(Value::from).collect(),\n            other =\u003e return Err(not_iterable(other)),\n        },\n        ForIterable::Range { start, end } =\u003e {\n            let s = eval_expr(env, start)?.as_int()?;\n            let e = eval_expr(env, end)?.as_int()?;\n            (s..e).map(Value::Int).collect()\n        }\n    };\n\n    for item in items {\n        let mut bindings = HashMap::new();\n        if match_pattern(env, pattern, \u0026item, \u0026mut bindings) {\n            env.push_scope();\n            for (name, val) in bindings {\n                env.bind(name, val);\n            }\n            eval_block(env, body)?;\n            env.pop_scope();\n        }\n    }\n\n    Ok(Value::None)\n}\n```\n\nKey properties:\n- Collects iterable into a Vec up front (no lazy iteration needed for\n  small TTRPG collections)\n- Reuses existing `match_pattern` + scope push/pop infrastructure\n- Non-matching patterns silently skip (no error)\n- Returns `Value::None` (unit)\n\n---\n\n## CLI / REPL changes\n\n- `TtrpgHighlighter`: highlight `for` as keyword\n- `TtrpgValidator`: `for` opens a block (add to delimiter counting)\n- `TtrpgCompleter`: `for` as keyword completion\n\n---\n\n## Implementation plan\n\n| Phase | Crate         | Work                                           |\n|-------|---------------|-------------------------------------------------|\n| 1     | ttrpg_lexer   | Add `TokenKind::For`, reserve `for`             |\n| 2     | ttrpg_ast     | Add `ExprKind::For`, `ForIterable` enum         |\n| 3     | ttrpg_parser  | Parse `for_expr` in `primary_expr`              |\n| 4     | ttrpg_checker | Type-check for-loops (collection + range)       |\n| 5     | ttrpg_interp  | `eval_for` implementation                       |\n| 6     | ttrpg_cli     | Highlighter, validator, completer updates        |\n| 7     | spec          | Update grammar spec, add examples               |\n\nPhases 1-3 can land as a parsing-only PR. Phase 4-5 adds semantics.\nPhase 6-7 are polish.\n\n---\n\n## Open questions\n\n1. **Collection semantics later?** The design is forward-compatible with\n   changing the return type to `list\u003cT\u003e` when the body is non-unit. Worth\n   doing now or defer?\n\n2. **Range inclusivity**: `1..4` means `[1, 2, 3]` (half-open, Rust-style).\n   Should we also support `1..=4` for `[1, 2, 3, 4]` (inclusive)? D\u0026D\n   spell slot levels are 1-9 inclusive, so `for level in 1..10` vs\n   `for level in 1..=9`.\n\n3. **Nested for-loops**: Should work naturally via scope stacking. Any\n   reason to restrict nesting depth?","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:00Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:39:36Z","closed_at":"2026-02-22T20:39:36Z","close_reason":"Closed","labels":["language-design"]}
{"id":"ttrpg_dsl-dz3.1","title":"For-loop: Lexer — Add TokenKind::For, reserve `for` keyword","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:16Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:22:41Z","closed_at":"2026-02-22T20:22:41Z","close_reason":"Added TokenKind::For to lexer, keyword match in lex_ident_or_keyword, highlighter keyword group, and completer DSL_KEYWORDS list. All tests pass."}
{"id":"ttrpg_dsl-dz3.2","title":"For-loop: AST — Add ExprKind::For variant and ForIterable enum","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:25:26Z","closed_at":"2026-02-22T20:25:26Z","close_reason":"Added ExprKind::For variant and ForIterable enum to AST. Added stub arms in checker (check_for -\u003e Ty::Unit) and interpreter (RuntimeError). All 815 tests pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.2","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:16Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.2","depends_on_id":"ttrpg_dsl-dz3.1","type":"blocks","created_at":"2026-02-22T11:50:31Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.3","title":"For-loop: Parser — Parse for_expr in primary_expr (collection + range forms)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:27:31Z","closed_at":"2026-02-22T20:27:31Z","close_reason":"Added parse_for_expr in primary_expr. Parses both collection (for x in expr {}) and range (for x in a..b {}) forms with full pattern support. 7 new parser tests, all 822 tests pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.3","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:17Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.3","depends_on_id":"ttrpg_dsl-dz3.2","type":"blocks","created_at":"2026-02-22T11:50:34Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.4","title":"For-loop: Type checker — Type-check for-loops (collection + range, pattern bindings)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:18Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:31:26Z","closed_at":"2026-02-22T20:31:26Z","close_reason":"Implemented check_for: validates collection (list/set) and range (int bounds) iterables, checks pattern bindings against element type, marks for-loop bindings as non-local for entity field mutation. Added mark_current_scope_non_local to ScopeStack. 9 new tests (valid + error cases), all 831 pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.4","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:18Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.4","depends_on_id":"ttrpg_dsl-dz3.3","type":"blocks","created_at":"2026-02-22T11:50:34Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.5","title":"For-loop: Interpreter — eval_for implementation (collection iteration, range iteration, pattern matching)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:19Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:36:55Z","closed_at":"2026-02-22T20:36:55Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-dz3.5","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:19Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.5","depends_on_id":"ttrpg_dsl-dz3.4","type":"blocks","created_at":"2026-02-22T11:50:35Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.6","title":"For-loop: CLI — Highlighter, validator, completer updates for `for` keyword","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:20Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:37:36Z","closed_at":"2026-02-22T20:37:36Z","close_reason":"All three CLI components (highlighter, completer, validator) already handled: highlighter and completer done in phase 1, validator is delimiter-based and needs no keyword changes","dependencies":[{"issue_id":"ttrpg_dsl-dz3.6","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:20Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.6","depends_on_id":"ttrpg_dsl-dz3.1","type":"blocks","created_at":"2026-02-22T11:50:35Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.7","title":"For-loop: Spec — Update canonical grammar, add for-loop examples","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:21Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:39:33Z","closed_at":"2026-02-22T20:39:33Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-dz3.7","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:21Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.7","depends_on_id":"ttrpg_dsl-dz3.5","type":"blocks","created_at":"2026-02-22T11:50:36Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-efg","title":"Parser: `none` is not a valid match pattern","description":"The pattern parser (pattern.rs) does not handle TokenKind::None. This means `match opt_val { none =\u003e ..., _ =\u003e ... }` fails with 'expected pattern, found None'. The spec implies option types should be matchable. Fix: add a None case to parse_pattern() that produces PatternKind::Literal with a None value.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:48Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:54Z","closed_at":"2026-02-22T17:28:54Z","close_reason":"Added PatternKind::NoneLit, handled in parser (parse_pattern), checker (check_pattern), and interpreter (match_pattern).","labels":["parser"]}
{"id":"ttrpg_dsl-fz0","title":"CLI: pipe/script mode exits on load failure, diagnostics unreachable","description":"In pipe mode (run_pipe, main.rs:38) and script mode (run_script, main.rs:64), any command error calls process::exit(1) immediately. This means if `load` fails with parse/check errors, the subsequent `errors` command never runs — the user cannot see what went wrong.\n\nThe diagnostics ARE stored on the Runner (runner.rs:280), but the process exits before the next line of stdin/script is read.\n\nOptions:\n- Don't exit on load failure in pipe/script mode — just print the error and continue\n- Auto-print diagnostics on load failure (first N errors)\n- Add a --keep-going flag for script mode\n- In pipe mode, treat load failure as non-fatal (the Runner is still usable, just with no program loaded)","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:08:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:58:36Z","closed_at":"2026-02-22T17:58:36Z","close_reason":"pipe/script mode now continues on error instead of exiting immediately, so diagnostics are reachable","labels":["cli"]}
{"id":"ttrpg_dsl-fzw","title":"Module: Ty::ModuleAlias intermediate type","description":"Add Ty::ModuleAlias(String) variant in ty.rs. Intermediate marker for module alias identifiers, consumed by resolve_field and check_call. Cannot appear in signatures or struct fields.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:07Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:04:21Z","closed_at":"2026-02-24T01:04:21Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-fzw","depends_on_id":"ttrpg_dsl-3px","type":"blocks","created_at":"2026-02-23T16:41:10Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-fzw","depends_on_id":"ttrpg_dsl-5vq","type":"blocks","created_at":"2026-02-23T16:41:10Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-gpe","title":"Fix scope leak in eval_for on body error","description":"eval_for uses ? on eval_block which skips pop_scope() on error, violating scope-balance invariants.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:08Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-gwr","title":"Checker: with constraints not enforced at call sites","description":"The with keyword on actions/reactions is only used for body-internal narrowing. Call sites never check that the receiver actually has the required group, leading to runtime field-access errors instead of type errors. Need to store with_groups in param metadata and validate at call sites.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:06Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-h0s","title":"Module: parse_multi() API","description":"New public API in ttrpg_parser lib.rs: parse_multi(sources) -\u003e ParseMultiResult. Encapsulates parse + lower_moves + span rebase + merge + resolve. Returns ParseMultiResult with has_errors flag and ok() guard.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:05Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:56:44Z","closed_at":"2026-02-24T00:56:44Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-h0s","depends_on_id":"ttrpg_dsl-64l","type":"blocks","created_at":"2026-02-23T16:40:27Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-h0s","depends_on_id":"ttrpg_dsl-9bu","type":"blocks","created_at":"2026-02-23T16:40:28Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-h0s","depends_on_id":"ttrpg_dsl-p9s","type":"blocks","created_at":"2026-02-23T16:40:28Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-hpg","title":"Language: ordered enums / enum-to-int conversion","description":"Enums have no inherent ordering. In 5e, Size (tiny \u003c small \u003c medium \u003c large \u003c huge \u003c gargantuan) needs comparison:\n    requires { target.size \u003c= grappler.size + 1 }\nThis is impossible because Size is an enum without ordinal values. Workaround is != checks for specific variants, which doesn't generalize.\n\nOptions:\n- Ordered enums: `enum Size ordered { tiny, small, medium, large, huge, gargantuan }`\n- Enum-to-int builtin: `ordinal(Size.medium) -\u003e 2`\n- Comparable enums that support \u003c, \u003e, \u003c=, \u003e= based on declaration order","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T21:27:38Z","closed_at":"2026-02-23T21:27:38Z","close_reason":"Implemented ordered enums with ordinal/from_ordinal builtins","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-hwf","title":"Parser: newlines inside brace-delimited blocks not suppressed","description":"Newlines inside { } are NOT suppressed (unlike () and []). This means multiline expressions in requires/cost blocks fail: requires { a \u0026\u0026\\n b } breaks. Only the opening { suppresses the next NL, not all NLs inside braces. Workaround: put everything on one line, or wrap in parens. See pain point #18 in examples/dnd5e_expanded.ttrpg.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:50:44Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:07:24Z","closed_at":"2026-02-22T18:07:24Z","close_reason":"Added suppress_newlines_in_brace_block() to strip NL tokens in expression-brace contexts (requires, cost)"}
{"id":"ttrpg_dsl-irh","title":"Implement parameterized conditions","description":"Add optional params to condition declarations, Value::Condition, ActiveCondition, Effects, and propagate through checker/interpreter/CLI","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:25:10Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:45:14Z","closed_at":"2026-02-23T19:45:14Z","close_reason":"Implemented parameterized conditions across all crates"}
{"id":"ttrpg_dsl-iuw","title":"Language: parameterized conditions","description":"Conditions are binary (present or absent) and take no parameters. In 5e:\n- Frightened needs a 'source' entity (can't willingly move closer to source)\n- Exhaustion has 6 levels with escalating effects\n- Grappled needs a reference to the grappler (grappler's speed is also 0)\n\nWould need: `condition Frightened(source: Character) on bearer: Character { ... }`\nor: `condition Exhaustion(level: int) on bearer: Character { ... }`\n\nWithout this, parameterized effects require separate conditions per case or external state tracking.","status":"in_progress","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:11Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:22:42Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ixk","title":"Checker: implement collect_hook and check_hook","description":"Add FnKind::Hook to env.rs. Add collect_hook() to collect.rs (validate entity receiver, reject trigger/turn shadows, register via collect_fn). Add check_hook() to check.rs (bind receiver, validate trigger event+bindings, bind trigger/turn, type-check body). Extract shared trigger-checking from check_reaction if needed. See plan: .claude/plans/staged-rolling-raccoon.md Steps 3-4.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:39Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:13:20Z","closed_at":"2026-02-23T06:13:20Z","close_reason":"Added FnKind::Hook, BlockKind::HookResolve, collect_hook(), check_hook(). Extracted shared check_trigger_and_body() from check_reaction. Hook context allows dice, mutation, turn, and action calls.","dependencies":[{"issue_id":"ttrpg_dsl-ixk","depends_on_id":"ttrpg_dsl-6ee","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-jam","title":"Module visibility not enforced for type references in signatures","description":"Parameter/receiver/return/field types are resolved but not visibility-gated (check.rs:568, check.rs:166, check_stmt.rs:32). Type validation only checks existence, not visibility (env.rs:220). A module can reference Core.Character without use Core and get no diagnostic.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T02:28:56Z","created_by":"Theodore Gast","updated_at":"2026-02-24T02:42:38Z","closed_at":"2026-02-24T02:42:38Z","close_reason":"Added check_type_visible method to Checker that walks TypeExpr trees and enforces module visibility for Named types. Called from all signature positions: params, return types, receiver types, struct/entity/enum field types, condition params, event params/fields, and let type annotations. 14 new tests."}
{"id":"ttrpg_dsl-ji8","title":"Materialize default values for condition parameters at runtime","description":"Condition constructor evaluation (call.rs:40-58) only records explicitly passed args. It never fills in declared defaults. So condition Weakened(level: int = 1) used as bare Weakened() stores empty args, and modify/suppress clauses crash with undefined variable when accessing 'level'. Fix: after processing passed args, iterate declared params and insert defaults for any missing ones.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:54:37Z","created_by":"Theodore Gast","updated_at":"2026-02-23T20:02:22Z","closed_at":"2026-02-23T20:02:22Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-jkl","title":"AST: add HookDecl and Program index","description":"Add HookDecl struct to ttrpg_ast/src/ast.rs (receiver, trigger, body — like ReactionDecl minus cost). Add DeclKind::Hook variant. Add hooks HashMap and hook_order Vec to Program. Wire into build_index(). See plan: .claude/plans/staged-rolling-raccoon.md Step 1.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T05:59:00Z","closed_at":"2026-02-23T05:59:00Z","close_reason":"Added HookDecl struct, DeclKind::Hook variant, hooks HashMap + hook_order Vec to Program, wired into build_index(), and added placeholder arms in checker collect/check"}
{"id":"ttrpg_dsl-jl8","title":"CLI: single-file mode bypasses module resolution entirely","description":"CLI behavior is inconsistent: single-file mode skips module resolution entirely. In runner.rs, sources.len()==1 uses parse + check, while multi-file uses parse_multi + check_with_modules. So valid module syntax in one file can fail (or skip rules) purely due to file count. Repro: single file with use Core as C and C.Ability type fails with 'qualified type requires module resolution'.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T01:23:54Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:52:49Z","closed_at":"2026-02-24T01:52:49Z","close_reason":"Unified single-file and multi-file loading to always use parse_multi + check_with_modules"}
{"id":"ttrpg_dsl-kmy","title":"Language: struct update syntax","description":"Structs are immutable value types. To change one field, the entire struct must be reconstructed. There is no spread/update syntax like:\n    let upcast_spell = spell { damage: new_damage, ..spell }\n\nThis matters for spell upcasting (change damage dice based on slot level), buff modifications, and any case where a struct is 'almost the same' with one field changed.\n\nRust-style struct update syntax (`..base`) would be a natural fit.","status":"in_progress","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:52:07Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:00:34Z","labels":["ergonomics","language-design"]}
{"id":"ttrpg_dsl-lfm","title":"Resource bounds dropped on local-to-entity mutation path","description":"eval.rs:1192 hardcodes bounds: None in the local-to-entity path, while direct entity assignment resolves bounds (eval.rs:1104). This means mutations like trigger.target.spell_slots[level] -= 1 can bypass resource clamping when the entity is reached through a local variable.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T18:47:34Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:53:17Z","closed_at":"2026-02-23T18:53:17Z","close_reason":"Fixed in eval.rs: local-to-entity path now calls resolve_resource_bounds; eval_bound_expr now injects entity fields into temp scope for complex expressions"}
{"id":"ttrpg_dsl-m2n","title":"Adapter: clamp writes to resource-valued map entries","description":"Extend the mutation/adapter path so that writing to a map\u003cK, resource(min..max)\u003e entry applies resource clamping. When the adapter handles MutateField with path [Field(f), Index(k)], look up the field declaration for f. If value type is resource(...), extract bound expressions, evaluate them in entity context, and clamp the result. This is the core new work — bounds lookup must unwrap the map value type to find the inner resource bounds.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:51Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:23:14Z","closed_at":"2026-02-23T18:23:14Z","close_reason":"Resource bounds now resolved from AST field declarations at mutation time. eval_assign_entity looks up entity type → field def → navigates TypeExpr along path to find resource bounds → evaluates bound expressions (literals + entity field refs). MutateField effects now carry actual bounds, and adapter clamping works for both direct resource fields and resource-valued map entries. 8 integration tests verify clamping for underflow, overflow, set, auto-init, dynamic bounds, and optional groups.","dependencies":[{"issue_id":"ttrpg_dsl-m2n","depends_on_id":"ttrpg_dsl-chb","type":"blocks","created_at":"2026-02-23T09:38:03Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-mcy","title":"Parser: only one requires block allowed per action","description":"Actions can only have a single requires {} block. Multiple preconditions must be combined with \u0026\u0026 on one long line. Multiline expressions inside requires {} also fail because newlines inside braces are not suppressed (unlike parens/brackets). Either support multiple requires blocks or suppress newlines inside requires {} braces.","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:48:50Z","created_by":"Theodore Gast","updated_at":"2026-02-24T03:51:40Z","closed_at":"2026-02-24T03:51:40Z","close_reason":"Support multiple requires blocks per action, combined with implicit \u0026\u0026. Multiline expressions inside requires were already working.","labels":["ergonomics","parser"]}
{"id":"ttrpg_dsl-mtu","title":"Enforce module visibility in the checker","description":"Add check_name_visible helper to Checker and insert calls at every name-resolution point. The helper emits a diagnostic when a name is used in a system that hasn't imported the owning system.","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-24T01:36:30Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:41:55Z","closed_at":"2026-02-24T01:41:55Z","close_reason":"Implemented check_name_visible helper and wired it into all name-resolution points across check.rs, check_expr.rs, check_pattern.rs, and check_modify.rs. Added 11 integration tests."}
{"id":"ttrpg_dsl-o1b","title":"Parser: parse optional groups and related syntax","description":"Parse all optional group syntax:\n- optional { fields... } blocks inside entity declarations (decl.rs: parse_entity_decl)\n- 'with GroupName' constraints on action/derive/mechanic/condition receivers and parameters (decl.rs: parse_param, parse_action_decl, etc.)\n- 'has' expressions at comparison precedence level (expr.rs)\n- 'grant entity.Group { field: val, ... }' and 'revoke entity.Group' statements (stmt.rs)\nAll new keywords (optional, grant, revoke, has, with) are soft keywords — lexed as Ident, matched by name in the parser.\nDepends on AST changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:28Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:49:45Z","closed_at":"2026-02-23T00:49:45Z","close_reason":"Parser now handles: optional groups in entities, has expressions, with constraints on params/receivers, grant/revoke statements. 16 new tests, all 860 pass.","dependencies":[{"issue_id":"ttrpg_dsl-o1b","depends_on_id":"ttrpg_dsl-950","type":"blocks","created_at":"2026-02-22T16:32:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-p9s","title":"Module: parse 'use ... as' syntax","description":"Update parse_use_decl in parser.rs to handle 'as IDENT' soft keyword after use string. 'as' is only recognized in this position.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:39:51Z","created_by":"Theodore Gast","updated_at":"2026-02-24T00:47:36Z","closed_at":"2026-02-24T00:47:36Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-pzy","title":"Language: turn phase hooks (on_turn_start, on_turn_end)","description":"No way to express automatic effects at the start or end of a turn:\n- Death saves happen at start of turn when at 0 HP\n- Regeneration happens at start of turn\n- Many conditions allow a repeat save at end of turn\n- Some effects trigger 'at the start of each of your turns'\n\nEvents/reactions are for OTHER entities reacting. Need a turn-phase hook system:\n    on_turn_start(actor: Character) {\n        if actor.HP == 0 \u0026\u0026 !(Stable in actor.conditions) {\n            do DeathSave on actor ()\n        }\n    }\n\nThis interacts with the Duration system (#9) — 'until a save is made' needs an end-of-turn hook to trigger the save.","notes":"Scoped down to hook declaration type (mandatory triggered action). Condition 'on' clauses deferred. No built-in events — game designers declare their own phase events. Implementation tracked in: ttrpg_dsl-5z0 (spec), ttrpg_dsl-jkl (AST), ttrpg_dsl-6ee (parser), ttrpg_dsl-ixk (checker), ttrpg_dsl-d83 (interp), ttrpg_dsl-beu (tests). Plan: .claude/plans/staged-rolling-raccoon.md","status":"closed","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:27Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:28:06Z","closed_at":"2026-02-23T06:28:06Z","close_reason":"All implementation beads complete: AST (jkl), parser (6ee), checker (ixk), interpreter (d83), tests (beu), spec docs (5z0). Hook declaration type is fully implemented.","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-pzy","depends_on_id":"ttrpg_dsl-d3r","type":"related","created_at":"2026-02-22T07:51:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-q1f","title":"Checker: module visibility not enforced — cross-system names usable without use","description":"Module visibility is not enforced during checking. Cross-system names are usable without a use statement. check.rs sets current_system, but lookups in check_expr.rs are global and never consult per-system visibility. Visibility metadata is built in collect.rs but unused by checker lookups. Repro: loading two files where Main calls helper() from Core without use reports no diagnostics.","status":"in_progress","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T01:23:47Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:24:04Z"}
{"id":"ttrpg_dsl-q5l","title":"Language: union types for heterogeneous entity references","description":"No union or sum type beyond enum payloads. In 5e, a 'damage source' could be a Weapon, Spell, or environment. Actions that work on 'any character type' need a common base. Currently no way to write:\n    type DamageSource = Weapon | Spell | Environment\n    action Attack on attacker: Character | Monster (target: Character | Monster, ...) { ... }\n\nEnum payloads can approximate this but with significant boilerplate for wrapping/unwrapping. Entity trait system (ttrpg_dsl-s43) might subsume this need.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:47Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:47Z","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-q5l","depends_on_id":"ttrpg_dsl-s43","type":"related","created_at":"2026-02-22T08:01:47Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-q7q","title":"Checker: alias-qualified expressions (Core.modifier) not implemented","description":"Alias-qualified expressions like Core.modifier and Core.Ability.STR are not implemented in the checker. The spec expects this (02_scoping.ttrpg). Currently qualified access through module aliases does not resolve.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T01:23:49Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:59:03Z","closed_at":"2026-02-24T01:59:03Z","close_reason":"Implemented alias-qualified expressions (Core.Ability, Core.modifier(), Core.Prone etc) in the checker. Added ModuleAlias resolution in check_ident, resolve_field, and check_call."}
{"id":"ttrpg_dsl-qj0","title":"Tests + spec updates for parameterized conditions","description":"Add parser, checker, interpreter, and integration tests for parameterized conditions. Update spec/examples with Frightened(source) example. Remove pain-point comments.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T19:22:55Z","created_by":"Theodore Gast","updated_at":"2026-02-23T19:48:17Z","closed_at":"2026-02-23T19:48:17Z","close_reason":"Completed as part of ttrpg_dsl-irh","dependencies":[{"issue_id":"ttrpg_dsl-qj0","depends_on_id":"ttrpg_dsl-6p8","type":"blocks","created_at":"2026-02-23T11:23:03Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-qj0","depends_on_id":"ttrpg_dsl-a6m","type":"blocks","created_at":"2026-02-23T11:23:03Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-qv2","title":"Interp: grant default resolution picks first global match","description":"find_optional_group walks all entity decls and returns the first group with matching name. If two entity types define the same group name with different defaults, wrong defaults may be used. Need to resolve defaults based on the receiver's entity type.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:07Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-rh4","title":"Language: 'until next use' and 'until save' duration variants","description":"The Duration enum covers time-based and indefinite durations but not event-triggered removal. The Help action needs 'remove this condition after it applies once' (next-use). Many spell effects need 'remove when the target succeeds on a saving throw at end of turn' (until-save). These require host-side duration interpretation beyond simple countdown.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:50Z"}
{"id":"ttrpg_dsl-s43","title":"Language: entity composition / traits / mixins","description":"Entities have no composition mechanism. In 5e, a Character entity grows to 40+ fields because spellcasting, class features, and equipment all live in one flat struct. There is no way to express:\n- trait Spellcaster { spellcasting_ability: Ability, spell_save_DC: int, ... }\n- entity Wizard: Character with Spellcaster { ... }\n- Optional field groups that only exist for certain character classes\n\nClass features end up as boolean flags (has_extra_attack, has_sneak_attack, etc.) with no type safety or associated behavior.","design":"Settled on optional groups as the composition mechanism. Key decisions:\n\n- **Approach**: Optional field groups declared inside entities with `optional GroupName { fields... }`\n- **Access**: Namespaced — `actor.Spellcasting.spell_save_DC`\n- **Guards**: `has` keyword as composable boolean expression with flow-sensitive type narrowing (`if actor has Spellcasting { ... }`)\n- **Activation**: `grant`/`revoke` keywords for runtime enable/disable in action resolve blocks\n- **Deactivation**: Discard field values on revoke (groups model structural identity, not toggles)\n- **Constraints**: `with GroupName` on action/derive/mechanic/condition parameters for lightweight polymorphism\n- **Cross-entity reuse**: Deferred — manual repetition for now, door open for future mixins/traits\n\nDesign doc: spec/design/entity_composition.md\n\nSurveyed 6 TTRPG systems (D\u0026D 5e, PF2e, CoC 7e, Savage Worlds, CofD, PbtA, FATE) and evaluated traits, inheritance, mixins, and optional groups against each. Optional groups cover the highest-value use cases (class-conditional fields, multiclassing, edge-activated subsystems) with moderate complexity.","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:11Z","created_by":"Theodore Gast","updated_at":"2026-02-23T16:43:00Z","closed_at":"2026-02-23T16:43:00Z","close_reason":"All subtasks complete: AST nodes, parser, checker, interpreter, CLI integration, and end-to-end tests for optional groups are all implemented and passing.","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-5ho","type":"blocks","created_at":"2026-02-22T16:33:58Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-8d6","type":"blocks","created_at":"2026-02-22T16:33:59Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-8j9","type":"blocks","created_at":"2026-02-22T16:33:58Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-950","type":"blocks","created_at":"2026-02-22T16:33:57Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-avf","type":"blocks","created_at":"2026-02-22T16:33:59Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-o1b","type":"blocks","created_at":"2026-02-22T16:33:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-svl","title":"AST: add base field to StructLit","description":"Add optional base: Option\u003cBox\u003cSpanned\u003cExprKind\u003e\u003e\u003e to ExprKind::StructLit. Fix all match sites to add base: None or destructure the new field.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T04:12:13Z","created_by":"Theodore Gast","updated_at":"2026-02-24T04:22:39Z","closed_at":"2026-02-24T04:22:39Z","close_reason":"Added base: Option\u003cBox\u003cSpanned\u003cExprKind\u003e\u003e\u003e to ExprKind::StructLit and updated all 7 match/construction sites"}
{"id":"ttrpg_dsl-uf6","title":"Alias collision checks incomplete - missing variant names and cross-import shadowing","description":"Resolver alias conflict check ignores enum variants (resolve.rs:175), and imported-name shadowing only compares against the alias target system, not all imported names (resolve.rs:193). Causes confusing downstream errors like fire.helper() reporting type DamageType has no methods instead of alias collision.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-24T02:28:58Z","created_by":"Theodore Gast","updated_at":"2026-02-24T02:52:45Z","closed_at":"2026-02-24T02:52:45Z","close_reason":"Fixed alias collision checks: (1) own-declaration check now includes variant names, (2) imported-name check now covers all imported systems, not just the current target"}
{"id":"ttrpg_dsl-v50","title":"Module: update spec with module system grammar and semantics","description":"Update spec/v0/02_scoping.ttrpg with: use_decl grammar, as soft keyword, qualified access semantics, system merging rules, visibility rules, error cases.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-24T00:40:32Z","created_by":"Theodore Gast","updated_at":"2026-02-24T01:18:02Z","closed_at":"2026-02-24T01:18:02Z","close_reason":"Updated spec/v0/02_scoping.ttrpg with module grammar, global name uniqueness, system merging, import semantics, qualified access, alias rules","dependencies":[{"issue_id":"ttrpg_dsl-v50","depends_on_id":"ttrpg_dsl-3ww","type":"blocks","created_at":"2026-02-23T16:41:40Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-v50","depends_on_id":"ttrpg_dsl-6o7","type":"blocks","created_at":"2026-02-23T16:41:40Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-v50","depends_on_id":"ttrpg_dsl-dkf","type":"blocks","created_at":"2026-02-23T16:41:41Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-wus","title":"Language: wildcard modify targets (modify all d20 rolls)","description":"The modify system targets specific mechanic names — you must list each one separately. The Helped condition should apply advantage to both attack_roll and skill_check, but there is no way to write 'modify any mechanic that uses a d20 roll'. Would want either a wildcard mechanic name or a mechanic trait/tag system so conditions can target categories of rolls.","status":"open","priority":4,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:22:58Z","created_by":"Theodore Gast","updated_at":"2026-02-23T17:22:58Z"}
{"id":"ttrpg_dsl-x0y","title":"Checker: has narrowing keyed by root var only","description":"extract_root_var collapses actor.friend and actor.target to actor, so 'if actor.friend has Spellcasting' incorrectly narrows actor.target.Spellcasting too. Need to key narrowings by full path, not just root variable.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:04Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-xh9","title":"Language: cost overrides and free/no-cost actions","description":"Two related issues with the action cost system:\n\n1. No 'free' or 'no cost' designation. Action Surge has no action cost — omitting the cost block works but is indistinguishable from forgetting to declare a cost (potential footgun).\n\n2. No way to override the cost of an existing action. In 5e, Rogue's Cunning Action lets you Dash/Disengage/Hide as a bonus action instead of an action. Currently requires duplicating the entire action with a different cost block (CunningDash, CunningDisengage). Would like:\n    condition CunningAction on bearer: Character {\n        modify Dash.cost(actor: bearer) { cost = bonus_action }\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:17Z","labels":["language-design"]}
{"id":"ttrpg_dsl-xyp","title":"Default lookup can silently use wrong entity's optional group definition","description":"Both interpreter and CLI default-fill helpers fall back to the first matching group name if entity type is unknown (eval.rs:1916, runner.rs:1051). This makes defaults declaration-order-dependent and can apply incorrect defaults without error. Fix: treat unknown entity type during default filling as an error instead of falling back.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:33Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:41:09Z","closed_at":"2026-02-23T04:41:09Z","close_reason":"Removed fallback in find_optional_group — returns None when entity type is unknown instead of using wrong entity's defaults"}
{"id":"ttrpg_dsl-yg0","title":"Update dnd5e_expanded to use map\u003cint, resource\u003e for spell slots","description":"Replace the 9 spell_slots_N fields with a single spell_slots: map\u003cint, resource(0..9)\u003e field. Replace the 9-branch match in CastSpell with spell_slots[level] -= 1. Update any derives or references that touch spell_slots_N. This validates the feature end-to-end against the motivating use case.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T17:37:59Z","created_by":"Theodore Gast","updated_at":"2026-02-23T18:40:51Z","closed_at":"2026-02-23T18:40:51Z","close_reason":"Migrated dnd5e_expanded to use map\u003cint, resource(0..9)\u003e for spell_slots. Replaced 9 spell_slots_N fields with single resource-valued map. Replaced 9-branch matches in CureWounds and Fireball with spell_slots[slot_level] -= 1. Updated pain point comments and summary. File loads and type-checks cleanly.","dependencies":[{"issue_id":"ttrpg_dsl-yg0","depends_on_id":"ttrpg_dsl-du9","type":"blocks","created_at":"2026-02-23T09:38:05Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-zq1","title":"Language: option\u003cT\u003e destructuring and unwrapping","description":"option\u003cT\u003e values cannot be destructured or unwrapped:\n- No `some(x)` pattern in match: `match val { some(x) =\u003e x.field, none =\u003e default }`\n- No `if let` syntax: `if let some(armor) = char.equipped_armor { ... }`\n- No `.unwrap()` or `.unwrap_or(default)` methods\n- Can't use option\u003cAbility\u003e as a map index without unwrapping first\n- `none` is not a valid pattern (separate parser bug ttrpg_dsl-efg)\n\nThis blocks any idiomatic use of option fields on entities (equipped_armor, spellcasting_ability, etc.).","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T19:04:18Z","closed_at":"2026-02-22T19:04:18Z","close_reason":"All destructuring/unwrapping items complete: none pattern (ttrpg_dsl-efg), some(x) match pattern, .unwrap()/.unwrap_or(), if let some(x). Option-as-index tracked separately in ttrpg_dsl-7ch.","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-zq1","depends_on_id":"ttrpg_dsl-efg","type":"blocks","created_at":"2026-02-22T08:04:54Z","created_by":"Theodore Gast","metadata":"{}"}]}
