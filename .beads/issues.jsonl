{"id":"ttrpg_dsl-34x","title":"Language: auto-succeed / auto-fail modifier for rolls","description":"The modify system only supports advantage/disadvantage as roll modifiers. In 5e, several conditions cause auto-failure on certain saves:\n- Stunned: auto-fail STR and DEX saves\n- Paralyzed: auto-fail STR and DEX saves\n- Petrified: auto-fail STR and DEX saves\n\nThe modify clause can set mode=disadvantage but cannot express 'the result is always failure'. Need either:\n- A new RollMode variant: `enum RollMode { normal, advantage, disadvantage, auto_fail, auto_succeed }`\n- Or the ability to override the result directly in a post-call modify:\n    `modify saving_throw(target: bearer) { result = SaveResult.failure }`","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-46i","title":"Language: no default/zero value for DiceExpr fields","description":"Can't write sneak_attack_dice: DiceExpr = 0d6 because 0d6 isn't a valid dice literal (0 count). There's no 'empty dice expression' value. This forces workarounds like option\u003cDiceExpr\u003e or separate boolean flags for features that may not have dice. See pain point #20 in examples/dnd5e_expanded.ttrpg.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:51:01Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:51:01Z"}
{"id":"ttrpg_dsl-586","title":"Language: position arithmetic and spatial queries","description":"Position is opaque — only `distance(a, b) -\u003e int` is available. Can't express:\n- 'Move target 5 feet away from shover' (Shove action)\n- 'Is attacker on the opposite side of target from ally?' (Flanking)\n- 'All creatures within 20 feet of a point' (AoE targeting)\n- Direction vectors, line-of-sight, adjacency\n\nWould need builtins like:\n    direction(from: Position, to: Position) -\u003e Direction\n    move_toward(pos: Position, target: Position, distance: int) -\u003e Position\n    move_away(pos: Position, source: Position, distance: int) -\u003e Position\n    creatures_within(center: Position, radius: int) -\u003e list\u003cCharacter\u003e","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:59Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:59Z","labels":["builtins","language-design"]}
{"id":"ttrpg_dsl-5yt","title":"Language: indexed resources / map of resources","description":"Spell slots in 5e are a resource indexed by level (1-9). The DSL forces 9 separate fields:\n    spell_slots_1: int = 0\n    spell_slots_2: int = 0\n    ...\n    spell_slots_9: int = 0\n\nIdeally: `spell_slots: map\u003cint, resource(0..max_slots)\u003e`\nBut resource types cannot be values in a map. There is also no way to use a runtime int to select a field (no computed field access like `entity.spell_slots[level]`).","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:02Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:02Z","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-7fv","title":"Language: dynamic dice construction","description":"DiceExpr literals are compile-time only. There is no way to construct a dice expression from runtime values. This means upcast spells need a match per slot level:\n    match slot_level { 1 =\u003e 1d8, 2 =\u003e 2d8, 3 =\u003e 3d8, ... }\n\nNeed something like:\n    dice(count: slot_level, sides: 8)  // -\u003e DiceExpr\nor a builtin:\n    make_dice(slot_level, 8) -\u003e DiceExpr\n\nAlso: there is no zero/empty DiceExpr value, so DiceExpr fields cannot have defaults.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:19Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:49:19Z","labels":["language-design"]}
{"id":"ttrpg_dsl-7r4","title":"Language: condition composition / inheritance","description":"Many 5e conditions include effects of other conditions:\n- Stunned includes Incapacitated (can't take actions/reactions)\n- Unconscious includes Prone + Incapacitated\n- Paralyzed includes Incapacitated + auto-fail STR/DEX saves\n\nCurrently all effects must be duplicated in each condition. Would like:\n    condition Stunned extends Incapacitated on bearer: Character { ... }\nor:\n    condition Stunned on bearer: Character {\n        include Incapacitated\n        ...additional effects...\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:32Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:32Z","labels":["language-design"]}
{"id":"ttrpg_dsl-9ng","title":"Parser: wildcard `_` not supported in modify bindings","description":"The spec (02_scoping.ttrpg:278) shows `modify attack_roll(attacker: _, target: _)` but the parser rejects _ in modify bindings because parse_modify_binding() calls parse_expr(), and Underscore is not a valid expression. Needed for option when-enabled blocks where there is no receiver to bind against.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:57Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:51Z","closed_at":"2026-02-22T17:28:51Z","close_reason":"Added wildcard _ support in parse_modify_binding(). Made ModifyBinding.value Option\u003cSpanned\u003cExprKind\u003e\u003e, updated checker and interpreter to skip type-check/match for None.","labels":["parser"]}
{"id":"ttrpg_dsl-c2y","title":"Parser: missing skip_newlines between cost and requires blocks","description":"In parse_action_decl (decl.rs:253-263), there is no skip_newlines() call between parsing the cost clause and checking for a requires clause. Comments or blank lines between cost {} and requires {} cause the requires to be silently skipped, and the parser then fails on 'expected resolve, found requires'. Fix: add self.skip_newlines() between the cost and requires parsing blocks.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:37Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:06:10Z","closed_at":"2026-02-22T17:06:10Z","close_reason":"Added skip_newlines() between cost and requires parsing in parse_action_decl. Added regression test.","labels":["parser"]}
{"id":"ttrpg_dsl-clo","title":"Language: automatic event emission from mutations","description":"When `target.HP -= amount` happens in an action, the runtime does not automatically emit a takes_damage event. The host must manually fire all events. Similarly for condition application.\n\nWould enable reactive patterns without host involvement:\n    entity Character {\n        HP: resource(0..max_HP) {\n            on_decrease =\u003e emit takes_damage(source: current_actor, amount: delta, damage_type: ...)\n        }\n    }\n\nThis would let concentration checks fire automatically when a concentrating caster takes damage.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ctc","title":"Language: typed prompts (return entity refs, not strings)","description":"Prompts always return string. For 'choose a target creature', the host must map the string back to an entity reference externally. Would be more type-safe to support:\n    prompt choose_target(chooser: Character, candidates: list\u003cCharacter\u003e) -\u003e Character\n    prompt choose_weapon(chooser: Character) -\u003e Weapon\n\nThis would let the interpreter validate the response type and eliminate string-to-entity mapping in the host.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:07Z","labels":["language-design"]}
{"id":"ttrpg_dsl-d3r","title":"Language: additional Duration variants","description":"The built-in Duration enum has: end_of_turn, start_of_next_turn, rounds(count), minutes(count), indefinite.\n\nMissing duration types needed for 5e:\n- 'until next use': Help action grants advantage on the target's NEXT attack/check, then the condition auto-removes. Many buff spells work this way.\n- 'until a save is made': Many spell effects (Hold Person, etc.) let the target repeat a save at end of each turn. The condition persists until they succeed.\n- 'until concentration ends': Spells like Bless last as long as the caster maintains concentration.\n\nThese could be additional Duration variants or a separate mechanism.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:59Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:59Z","labels":["language-design"]}
{"id":"ttrpg_dsl-dz3","title":"Language: bounded iteration / loops","description":"The DSL has no loop construct. This blocks modeling:\n- Extra Attack (make N attack rolls where N depends on level)\n- AoE spells (apply damage to N targets)\n- Multi-damage-type processing (iterate over list\u003cDamageSpec\u003e)\n- Spell slot deduction (9-branch match instead of indexed access)\n\nA bounded `for` loop would cover most cases:\n    for target in targets { ... }\n    for i in 1..attack_count(attacker) { ... }\n\nUnbounded while loops are probably not needed for TTRPG modeling.","status":"open","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:00Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:49:00Z","labels":["language-design"]}
{"id":"ttrpg_dsl-efg","title":"Parser: `none` is not a valid match pattern","description":"The pattern parser (pattern.rs) does not handle TokenKind::None. This means `match opt_val { none =\u003e ..., _ =\u003e ... }` fails with 'expected pattern, found None'. The spec implies option types should be matchable. Fix: add a None case to parse_pattern() that produces PatternKind::Literal with a None value.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:48Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:54Z","closed_at":"2026-02-22T17:28:54Z","close_reason":"Added PatternKind::NoneLit, handled in parser (parse_pattern), checker (check_pattern), and interpreter (match_pattern).","labels":["parser"]}
{"id":"ttrpg_dsl-fz0","title":"CLI: pipe/script mode exits on load failure, diagnostics unreachable","description":"In pipe mode (run_pipe, main.rs:38) and script mode (run_script, main.rs:64), any command error calls process::exit(1) immediately. This means if `load` fails with parse/check errors, the subsequent `errors` command never runs — the user cannot see what went wrong.\n\nThe diagnostics ARE stored on the Runner (runner.rs:280), but the process exits before the next line of stdin/script is read.\n\nOptions:\n- Don't exit on load failure in pipe/script mode — just print the error and continue\n- Auto-print diagnostics on load failure (first N errors)\n- Add a --keep-going flag for script mode\n- In pipe mode, treat load failure as non-fatal (the Runner is still usable, just with no program loaded)","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:08:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:58:36Z","closed_at":"2026-02-22T17:58:36Z","close_reason":"pipe/script mode now continues on error instead of exiting immediately, so diagnostics are reachable","labels":["cli"]}
{"id":"ttrpg_dsl-hpg","title":"Language: ordered enums / enum-to-int conversion","description":"Enums have no inherent ordering. In 5e, Size (tiny \u003c small \u003c medium \u003c large \u003c huge \u003c gargantuan) needs comparison:\n    requires { target.size \u003c= grappler.size + 1 }\nThis is impossible because Size is an enum without ordinal values. Workaround is != checks for specific variants, which doesn't generalize.\n\nOptions:\n- Ordered enums: `enum Size ordered { tiny, small, medium, large, huge, gargantuan }`\n- Enum-to-int builtin: `ordinal(Size.medium) -\u003e 2`\n- Comparable enums that support \u003c, \u003e, \u003c=, \u003e= based on declaration order","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:36Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:36Z","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-hwf","title":"Parser: newlines inside brace-delimited blocks not suppressed","description":"Newlines inside { } are NOT suppressed (unlike () and []). This means multiline expressions in requires/cost blocks fail: requires { a \u0026\u0026\\n b } breaks. Only the opening { suppresses the next NL, not all NLs inside braces. Workaround: put everything on one line, or wrap in parens. See pain point #18 in examples/dnd5e_expanded.ttrpg.","status":"open","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:50:44Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:50:44Z"}
{"id":"ttrpg_dsl-iuw","title":"Language: parameterized conditions","description":"Conditions are binary (present or absent) and take no parameters. In 5e:\n- Frightened needs a 'source' entity (can't willingly move closer to source)\n- Exhaustion has 6 levels with escalating effects\n- Grappled needs a reference to the grappler (grappler's speed is also 0)\n\nWould need: `condition Frightened(source: Character) on bearer: Character { ... }`\nor: `condition Exhaustion(level: int) on bearer: Character { ... }`\n\nWithout this, parameterized effects require separate conditions per case or external state tracking.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:11Z","labels":["language-design"]}
{"id":"ttrpg_dsl-kmy","title":"Language: struct update syntax","description":"Structs are immutable value types. To change one field, the entire struct must be reconstructed. There is no spread/update syntax like:\n    let upcast_spell = spell { damage: new_damage, ..spell }\n\nThis matters for spell upcasting (change damage dice based on slot level), buff modifications, and any case where a struct is 'almost the same' with one field changed.\n\nRust-style struct update syntax (`..base`) would be a natural fit.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:52:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:52:07Z","labels":["ergonomics","language-design"]}
{"id":"ttrpg_dsl-mcy","title":"Parser: only one requires block allowed per action","description":"Actions can only have a single requires {} block. Multiple preconditions must be combined with \u0026\u0026 on one long line. Multiline expressions inside requires {} also fail because newlines inside braces are not suppressed (unlike parens/brackets). Either support multiple requires blocks or suppress newlines inside requires {} braces.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:48:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:48:50Z","labels":["ergonomics","parser"]}
{"id":"ttrpg_dsl-pzy","title":"Language: turn phase hooks (on_turn_start, on_turn_end)","description":"No way to express automatic effects at the start or end of a turn:\n- Death saves happen at start of turn when at 0 HP\n- Regeneration happens at start of turn\n- Many conditions allow a repeat save at end of turn\n- Some effects trigger 'at the start of each of your turns'\n\nEvents/reactions are for OTHER entities reacting. Need a turn-phase hook system:\n    on_turn_start(actor: Character) {\n        if actor.HP == 0 \u0026\u0026 !(Stable in actor.conditions) {\n            do DeathSave on actor ()\n        }\n    }\n\nThis interacts with the Duration system (#9) — 'until a save is made' needs an end-of-turn hook to trigger the save.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:27Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:27Z","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-pzy","depends_on_id":"ttrpg_dsl-d3r","type":"related","created_at":"2026-02-22T07:51:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-q5l","title":"Language: union types for heterogeneous entity references","description":"No union or sum type beyond enum payloads. In 5e, a 'damage source' could be a Weapon, Spell, or environment. Actions that work on 'any character type' need a common base. Currently no way to write:\n    type DamageSource = Weapon | Spell | Environment\n    action Attack on attacker: Character | Monster (target: Character | Monster, ...) { ... }\n\nEnum payloads can approximate this but with significant boilerplate for wrapping/unwrapping. Entity trait system (ttrpg_dsl-s43) might subsume this need.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:47Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:47Z","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-q5l","depends_on_id":"ttrpg_dsl-s43","type":"related","created_at":"2026-02-22T08:01:47Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-s43","title":"Language: entity composition / traits / mixins","description":"Entities have no composition mechanism. In 5e, a Character entity grows to 40+ fields because spellcasting, class features, and equipment all live in one flat struct. There is no way to express:\n- trait Spellcaster { spellcasting_ability: Ability, spell_save_DC: int, ... }\n- entity Wizard: Character with Spellcaster { ... }\n- Optional field groups that only exist for certain character classes\n\nClass features end up as boolean flags (has_extra_attack, has_sneak_attack, etc.) with no type safety or associated behavior.","status":"open","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:49:11Z","labels":["language-design"]}
{"id":"ttrpg_dsl-xh9","title":"Language: cost overrides and free/no-cost actions","description":"Two related issues with the action cost system:\n\n1. No 'free' or 'no cost' designation. Action Surge has no action cost — omitting the cost block works but is indistinguishable from forgetting to declare a cost (potential footgun).\n\n2. No way to override the cost of an existing action. In 5e, Rogue's Cunning Action lets you Dash/Disengage/Hide as a bonus action instead of an action. Currently requires duplicating the entire action with a different cost block (CunningDash, CunningDisengage). Would like:\n    condition CunningAction on bearer: Character {\n        modify Dash.cost(actor: bearer) { cost = bonus_action }\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:17Z","labels":["language-design"]}
{"id":"ttrpg_dsl-zq1","title":"Language: option\u003cT\u003e destructuring and unwrapping","description":"option\u003cT\u003e values cannot be destructured or unwrapped:\n- No `some(x)` pattern in match: `match val { some(x) =\u003e x.field, none =\u003e default }`\n- No `if let` syntax: `if let some(armor) = char.equipped_armor { ... }`\n- No `.unwrap()` or `.unwrap_or(default)` methods\n- Can't use option\u003cAbility\u003e as a map index without unwrapping first\n- `none` is not a valid pattern (separate parser bug ttrpg_dsl-efg)\n\nThis blocks any idiomatic use of option fields on entities (equipped_armor, spellcasting_ability, etc.).","status":"open","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:49:50Z","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-zq1","depends_on_id":"ttrpg_dsl-efg","type":"blocks","created_at":"2026-02-22T08:04:54Z","created_by":"Theodore Gast","metadata":"{}"}]}
