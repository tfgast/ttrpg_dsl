{"id":"ttrpg_dsl-002","title":"Add .unwrap() / .unwrap_or(default) methods on option values","description":"Allow calling .unwrap() to extract the inner value (runtime error if none) and .unwrap_or(default) to provide a fallback. Useful for cases where match is too verbose.","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:51:26Z","closed_at":"2026-02-22T18:51:26Z","close_reason":"Implemented .unwrap() and .unwrap_or(default) methods on option values"}
{"id":"ttrpg_dsl-04h","title":"Add for-loop tests for side effects and error-path scope cleanup","description":"Existing for-loop tests mostly validate return values. Need tests for: loop body side effects, scope cleanup on body error.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:10Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-09t","title":"Field/group name collisions allowed in optional groups","description":"collect.rs tracks entity fields and optional groups in separate duplicate sets, so an entity can have both a field and an optional group with the same name (e.g. Spellcasting). The checker resolves entity.Spellcasting as an optional group before normal fields, while runtime has/field reads use raw field names — creating ambiguous/incorrect behavior. Fix: make field names and optional-group names disjoint per entity during collection.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:30Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:28:34Z","closed_at":"2026-02-23T04:28:34Z","close_reason":"Added cross-check in collect_entity() to detect field/group name collisions"}
{"id":"ttrpg_dsl-34x","title":"Language: auto-succeed / auto-fail modifier for rolls","description":"The modify system only supports advantage/disadvantage as roll modifiers. In 5e, several conditions cause auto-failure on certain saves:\n- Stunned: auto-fail STR and DEX saves\n- Paralyzed: auto-fail STR and DEX saves\n- Petrified: auto-fail STR and DEX saves\n\nThe modify clause can set mode=disadvantage but cannot express 'the result is always failure'. Need either:\n- A new RollMode variant: `enum RollMode { normal, advantage, disadvantage, auto_fail, auto_succeed }`\n- Or the ability to override the result directly in a post-call modify:\n    `modify saving_throw(target: bearer) { result = SaveResult.failure }`","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-46i","title":"Language: no default/zero value for DiceExpr fields","description":"Can't write sneak_attack_dice: DiceExpr = 0d6 because 0d6 isn't a valid dice literal (0 count). There's no 'empty dice expression' value. This forces workarounds like option\u003cDiceExpr\u003e or separate boolean flags for features that may not have dice. See pain point #20 in examples/dnd5e_expanded.ttrpg.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:51:01Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:51:01Z"}
{"id":"ttrpg_dsl-4qz","title":"Fix for-loop checker: only mark entity-typed bindings as non-local","description":"mark_current_scope_non_local() marks ALL for-loop pattern bindings as non-local, but only entity-typed ones should be non-local. Non-entity loop vars (struct, list elements) can currently bypass the immutable-local guard in action/reaction contexts.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:06Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-586","title":"Language: position arithmetic and spatial queries","description":"Position is opaque — only `distance(a, b) -\u003e int` is available. Can't express:\n- 'Move target 5 feet away from shover' (Shove action)\n- 'Is attacker on the opposite side of target from ally?' (Flanking)\n- 'All creatures within 20 feet of a point' (AoE targeting)\n- Direction vectors, line-of-sight, adjacency\n\nWould need builtins like:\n    direction(from: Position, to: Position) -\u003e Direction\n    move_toward(pos: Position, target: Position, distance: int) -\u003e Position\n    move_away(pos: Position, source: Position, distance: int) -\u003e Position\n    creatures_within(center: Position, radius: int) -\u003e list\u003cCharacter\u003e","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:59Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:59Z","labels":["builtins","language-design"]}
{"id":"ttrpg_dsl-5ho","title":"Interpreter: runtime optional group support","description":"Runtime support for optional groups:\n- Extend StateProvider trait: is_group_active(), read_group_field()\n- Extend WritableState trait: grant_group(), revoke_group()\n- Add active_groups: HashMap\u003cString, HashMap\u003cString, Value\u003e\u003e to EntityState in reference_state.rs\n- Implement grant_group: validate group not already active, store fields, return Result\n- Implement revoke_group: remove group and discard field values, return Result\n- Evaluate ExprKind::Has: call state.is_group_active()\n- Evaluate namespaced field access: actor.Group.field reads from active_groups\n- Execute grant/revoke statements: evaluate field exprs, call state methods\n- Add GrantGroup/RevokeGroup to Effect enum if using effect-based mutation path\n- Handle namespaced field writes in actions (actor.Group.field -= 1)\nDepends on checker changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:40Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:23:49Z","closed_at":"2026-02-23T01:23:49Z","close_reason":"Implemented runtime optional group support: Has expression (read_field-based), Grant/Revoke statements emitting GrantGroup/RevokeGroup effects, remove_field on WritableState, adapter + CLI handler support","dependencies":[{"issue_id":"ttrpg_dsl-5ho","depends_on_id":"ttrpg_dsl-8j9","type":"blocks","created_at":"2026-02-22T16:32:58Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-5yt","title":"Language: indexed resources / map of resources","description":"Spell slots in 5e are a resource indexed by level (1-9). The DSL forces 9 separate fields:\n    spell_slots_1: int = 0\n    spell_slots_2: int = 0\n    ...\n    spell_slots_9: int = 0\n\nIdeally: `spell_slots: map\u003cint, resource(0..max_slots)\u003e`\nBut resource types cannot be values in a map. There is also no way to use a runtime int to select a field (no computed field access like `entity.spell_slots[level]`).","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:02Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:02Z","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-5z0","title":"Spec: document hook declaration syntax and semantics","description":"Update spec/v0/ files to document the new hook declaration type. Add hook row to permission table in 02_scoping.ttrpg, add grammar rule in 03_canonical_grammar.ttrpg, add examples in 04_full_example.ttrpg. Hook is a mandatory triggered action (like reaction minus cost). Uses same trigger syntax as reactions, fires automatically on event match. See plan: .claude/plans/staged-rolling-raccoon.md Step 8.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:35Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:27:40Z","closed_at":"2026-02-23T06:27:40Z","close_reason":"Added hook documentation to all three spec files: permission table and description in 02_scoping, grammar rule in 03_canonical_grammar, worked example in 04_full_example"}
{"id":"ttrpg_dsl-671","title":"spawn is not atomic when inline optional groups are present","description":"runner.rs:444 creates the entity and binds the handle before inline-group validation/application at :449. Any later error (unknown group field, missing required field, default-eval error) returns Err but leaves partially created state behind. Fix: validate inline optional groups before mutating state, or roll back on error.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:33Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:34:10Z","closed_at":"2026-02-23T04:34:10Z","close_reason":"Reordered cmd_spawn to validate+prepare inline groups before mutating state"}
{"id":"ttrpg_dsl-6ee","title":"Parser: implement parse_hook_decl","description":"Add parse_hook_decl() to ttrpg_parser/src/decl.rs. Wire 'hook' soft keyword in dispatch. Reuse parse_trigger_param() and parse_with_groups(). Body is a bare block (no cost/resolve wrappers). See plan: .claude/plans/staged-rolling-raccoon.md Step 2.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:37Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:08:08Z","closed_at":"2026-02-23T06:08:08Z","close_reason":"Added parse_hook_decl() to decl.rs and wired 'hook' soft keyword in parse_decl dispatch. Reuses parse_trigger_param(), parse_with_groups(), and parse_block() for bare body.","dependencies":[{"issue_id":"ttrpg_dsl-6ee","depends_on_id":"ttrpg_dsl-jkl","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-6su","title":"Implement some(x) pattern matching for option\u003cT\u003e","description":"Add some(x) pattern to match expressions, fix none pattern bug (doesn't match Value::Option(None)), update dnd5e_expanded example","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:21:15Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:27:37Z","closed_at":"2026-02-22T18:27:37Z","close_reason":"Implemented some(x) pattern matching, fixed none bug, added tests, updated dnd5e example"}
{"id":"ttrpg_dsl-7ch","title":"Transparent option-as-index: use option\u003cAbility\u003e to index into abilities[]","description":"Allow option\u003cT\u003e to be used where T is expected for indexing operations, with a runtime error if none. E.g. abilities[spellcasting_ability] where spellcasting_ability: option\u003cAbility\u003e.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:20Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:26:20Z"}
{"id":"ttrpg_dsl-7fv","title":"Language: dynamic dice construction","description":"DiceExpr literals are compile-time only. There is no way to construct a dice expression from runtime values. This means upcast spells need a match per slot level:\n    match slot_level { 1 =\u003e 1d8, 2 =\u003e 2d8, 3 =\u003e 3d8, ... }\n\nNeed something like:\n    dice(count: slot_level, sides: 8)  // -\u003e DiceExpr\nor a builtin:\n    make_dice(slot_level, 8) -\u003e DiceExpr\n\nAlso: there is no zero/empty DiceExpr value, so DiceExpr fields cannot have defaults.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:19Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:49:19Z","labels":["language-design"]}
{"id":"ttrpg_dsl-7r4","title":"Language: condition composition / inheritance","description":"Many 5e conditions include effects of other conditions:\n- Stunned includes Incapacitated (can't take actions/reactions)\n- Unconscious includes Prone + Incapacitated\n- Paralyzed includes Incapacitated + auto-fail STR/DEX saves\n\nCurrently all effects must be duplicated in each condition. Would like:\n    condition Stunned extends Incapacitated on bearer: Character { ... }\nor:\n    condition Stunned on bearer: Character {\n        include Incapacitated\n        ...additional effects...\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:32Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:32Z","labels":["language-design"]}
{"id":"ttrpg_dsl-82h","title":"Implement eval handle.field access in REPL","description":"Currently `eval handle.field` does not work — handles are not in the interpreter's eval scope (confirmed by test at runner.rs:1697). This was explicitly deferred from ttrpg_dsl-avf.\n\nThe goal is to make expressions like `eval hero.HP`, `eval hero.Spellcasting.spell_slots`, and `eval hero.Spellcasting` work in the CLI by injecting handle bindings into the interpreter's evaluation context before calling evaluate_expr.\n\nThis likely requires either:\n1. Pre-processing the expression to substitute handle.field references with their values before eval, or\n2. Extending the interpreter to accept an environment of handle→entity bindings so that handle names resolve during expression evaluation\n\nApproach 2 is cleaner but requires interpreter changes. Approach 1 can be done entirely in the CLI crate.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-23T02:30:46Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:30:46Z"}
{"id":"ttrpg_dsl-8d6","title":"Tests: optional group end-to-end coverage","description":"Comprehensive test coverage for optional groups:\n- Parser tests: entity with optional groups, has expressions, grant/revoke stmts, with constraints\n- Checker tests: valid/invalid group access, narrowing through if-has, with constraints on actions/derives, grant/revoke only in actions, duplicate group names, nonexistent groups\n- Interpreter tests: grant/revoke lifecycle, has evaluation, namespaced field read/write, grant with defaults, revoke discards values, double-grant error, revoke-inactive error\n- Integration test: full 5e-style example with Character having optional Spellcasting and KiPowers, actions with 'with' constraints, guards in derives\n- CLI tests: spawn with inline groups, grant/revoke commands, eval namespaced paths\nDepends on all implementation tasks.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:50Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:41:15Z","closed_at":"2026-02-23T02:41:15Z","close_reason":"Added 12 end-to-end integration tests in optional_groups_integration.rs exercising the full pipeline (parse→lower→check→interpret) for optional groups: pipeline validation, has expression, grant/revoke via actions with StateAdapter, full lifecycle with multiple groups, with-constrained actions, derives with has-guards, per-entity independence, and effect emission verification. Existing unit tests in parser/checker/interp/CLI already cover syntax parsing, type checking, and CLI commands comprehensively.","dependencies":[{"issue_id":"ttrpg_dsl-8d6","depends_on_id":"ttrpg_dsl-avf","type":"blocks","created_at":"2026-02-22T16:32:59Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-8j9","title":"Checker: type check optional groups","description":"Type checking for optional groups:\n- Add OptionalGroupInfo to EntityInfo in env.rs, populate during collection (collect.rs)\n- Validate optional group declarations: unique names, valid field types, no nesting\n- Type check ExprKind::Has: entity type must have the named group, result is bool\n- Type check grant/revoke: only allowed in action/reaction resolve blocks, validate group exists and field types match\n- Validate 'with' constraints on params: entity type must declare the named group\n- Flow-sensitive type narrowing: track which groups are narrowed-as-active in scope (if entity has Group { ... }, early return after negative guard)\n- Reject access to entity.Group.field without a guard or 'with' constraint\n- Automatically narrow groups inside action/derive bodies when 'with' constraint is present\nDepends on parser changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:05:24Z","closed_at":"2026-02-23T01:05:24Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-8j9","depends_on_id":"ttrpg_dsl-o1b","type":"blocks","created_at":"2026-02-22T16:32:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-950","title":"AST: add optional group nodes","description":"Add AST types for optional groups:\n- OptionalGroup struct (name + fields) on EntityDecl\n- ExprKind::Has { entity, group_name } for guard expressions\n- StmtKind::Grant { entity, group_name, fields } and StmtKind::Revoke { entity, group_name }\n- with_groups: Vec\u003cString\u003e on Param and receiver_with_groups on ActionDecl/ReactionDecl/ConditionDecl/FnDecl\nFile: ttrpg_ast/src/ast.rs","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:23Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:45:29Z","closed_at":"2026-02-23T00:45:29Z","close_reason":"Added OptionalGroup on EntityDecl, ExprKind::Has, StmtKind::Grant/Revoke, with_groups on Param, receiver_with_groups on ActionDecl/ReactionDecl/ConditionDecl. All 844 tests pass."}
{"id":"ttrpg_dsl-9ng","title":"Parser: wildcard `_` not supported in modify bindings","description":"The spec (02_scoping.ttrpg:278) shows `modify attack_roll(attacker: _, target: _)` but the parser rejects _ in modify bindings because parse_modify_binding() calls parse_expr(), and Underscore is not a valid expression. Needed for option when-enabled blocks where there is no receiver to bind against.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:57Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:51Z","closed_at":"2026-02-22T17:28:51Z","close_reason":"Added wildcard _ support in parse_modify_binding(). Made ModifyBinding.value Option\u003cSpanned\u003cExprKind\u003e\u003e, updated checker and interpreter to skip type-check/match for None.","labels":["parser"]}
{"id":"ttrpg_dsl-avf","title":"CLI: grant/revoke commands and spawn integration","description":"CLI support for optional groups:\n- New 'grant handle.GroupName { field: val, ... }' command\n- New 'revoke handle.GroupName' command\n- Extend spawn to accept inline groups: spawn Type handle { field: val, Group { field: val } }\n- Extend parse_field_block to distinguish regular fields from group activations\n- Validate group names and field types against TypeEnv during grant and spawn\n- Extend eval to handle namespaced paths (eval hero.Spellcasting.spell_save_DC)\n- Extend set to handle namespaced paths\n- Update completer.rs for group name completion\n- Update accessor methods (entity_type_names, field_names) to include group info\nDepends on interpreter changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:45Z","created_by":"Theodore Gast","updated_at":"2026-02-23T02:17:01Z","closed_at":"2026-02-23T02:17:01Z","close_reason":"Implemented CLI grant/revoke commands, extended spawn/set/inspect/types/state for optional groups, updated completer and highlighter","dependencies":[{"issue_id":"ttrpg_dsl-avf","depends_on_id":"ttrpg_dsl-5ho","type":"blocks","created_at":"2026-02-22T16:32:58Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-beu","title":"Tests: hook declaration parser, checker, and interpreter tests","description":"Parser tests: basic parse, with_groups, soft keyword. Checker tests: undefined event, shadow trigger/turn, struct receiver rejected, direct call rejected, binding type mismatch. Interpreter tests (new hook_integration.rs): fires on matching event, skips non-matching entity, can mutate/roll, declaration order, not suppressed. See plan: .claude/plans/staged-rolling-raccoon.md Step 7.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:43Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:22:14Z","closed_at":"2026-02-23T06:22:14Z","close_reason":"Added 3 parser tests, 9 checker tests (including hook direct call rejection fix in check_expr.rs), and 11 interpreter integration tests in hook_integration.rs","dependencies":[{"issue_id":"ttrpg_dsl-beu","depends_on_id":"ttrpg_dsl-d83","type":"blocks","created_at":"2026-02-22T21:55:49Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-c2y","title":"Parser: missing skip_newlines between cost and requires blocks","description":"In parse_action_decl (decl.rs:253-263), there is no skip_newlines() call between parsing the cost clause and checking for a requires clause. Comments or blank lines between cost {} and requires {} cause the requires to be silently skipped, and the parser then fails on 'expected resolve, found requires'. Fix: add self.skip_newlines() between the cost and requires parsing blocks.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:37Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:06:10Z","closed_at":"2026-02-22T17:06:10Z","close_reason":"Added skip_newlines() between cost and requires parsing in parse_action_decl. Added regression test.","labels":["parser"]}
{"id":"ttrpg_dsl-ccr","title":"Add if-let some(x) = expr syntax","description":"Allow if let some(x) = optional_expr { ... } else { ... } as a more ergonomic alternative to match for single-pattern option destructuring","status":"closed","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T18:26:15Z","created_by":"Theodore Gast","updated_at":"2026-02-22T19:04:01Z","closed_at":"2026-02-22T19:04:01Z","close_reason":"Added ExprKind::IfLet to AST, parser, checker, and interpreter. Supports if let some(x) = expr { ... } else { ... } with else-if-let chaining and nested patterns."}
{"id":"ttrpg_dsl-clo","title":"Language: automatic event emission from mutations","description":"When `target.HP -= amount` happens in an action, the runtime does not automatically emit a takes_damage event. The host must manually fire all events. Similarly for condition application.\n\nWould enable reactive patterns without host involvement:\n    entity Character {\n        HP: resource(0..max_HP) {\n            on_decrease =\u003e emit takes_damage(source: current_actor, amount: delta, damage_type: ...)\n        }\n    }\n\nThis would let concentration checks fire automatically when a concentrating caster takes damage.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:49Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:49Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ctc","title":"Language: typed prompts (return entity refs, not strings)","description":"Prompts always return string. For 'choose a target creature', the host must map the string back to an entity reference externally. Would be more type-safe to support:\n    prompt choose_target(chooser: Character, candidates: list\u003cCharacter\u003e) -\u003e Character\n    prompt choose_weapon(chooser: Character) -\u003e Weapon\n\nThis would let the interpreter validate the response type and eliminate string-to-entity mapping in the host.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:07Z","labels":["language-design"]}
{"id":"ttrpg_dsl-d3r","title":"Language: additional Duration variants","description":"The built-in Duration enum has: end_of_turn, start_of_next_turn, rounds(count), minutes(count), indefinite.\n\nMissing duration types needed for 5e:\n- 'until next use': Help action grants advantage on the target's NEXT attack/check, then the condition auto-removes. Many buff spells work this way.\n- 'until a save is made': Many spell effects (Hold Person, etc.) let the target repeat a save at end of each turn. The condition persists until they succeed.\n- 'until concentration ends': Spells like Bless last as long as the caster maintains concentration.\n\nThese could be additional Duration variants or a separate mechanism.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:59Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:59Z","labels":["language-design"]}
{"id":"ttrpg_dsl-d83","title":"Interpreter: implement execute_hook and fire_hooks","description":"Add ActionKind::Hook to effect.rs. Add execute_hook() to action.rs (emit ActionStarted/Completed, bind receiver+trigger, execute body — no cost deduction). Add find_matching_hooks() to event.rs (reuse match_trigger_bindings, no suppression). Add fire_hooks() public API to lib.rs. See plan: .claude/plans/staged-rolling-raccoon.md Steps 5-6.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:41Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:17:26Z","closed_at":"2026-02-23T06:17:26Z","close_reason":"Implemented ActionKind::Hook variant, execute_hook in action.rs, find_matching_hooks+HookInfo in event.rs, and execute_hook/what_hooks/fire_hooks public API on Interpreter","dependencies":[{"issue_id":"ttrpg_dsl-d83","depends_on_id":"ttrpg_dsl-ixk","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3","title":"Language: bounded iteration / loops","description":"The DSL has no loop construct. This blocks modeling:\n- Extra Attack (make N attack rolls where N depends on level)\n- AoE spells (apply damage to N targets)\n- Multi-damage-type processing (iterate over list\u003cDamageSpec\u003e)\n- Spell slot deduction (9-branch match instead of indexed access)\n\nA bounded `for` loop would cover most cases:\n    for target in targets { ... }\n    for i in 1..attack_count(attacker) { ... }\n\nUnbounded while loops are probably not needed for TTRPG modeling.","design":"# Design: Bounded Iteration / For-Loops\n\n## Motivation\n\nThe DSL has no loop construct. This blocks modeling common TTRPG patterns:\n\n- **Extra Attack**: make N attack rolls where N depends on level\n- **AoE spells**: apply damage to each target in a list\n- **Multi-damage processing**: iterate over `list\u003cDamageSpec\u003e` to resolve each\n- **Buff/debuff application**: apply a condition to multiple entities\n\nAll motivating cases involve iterating over a bounded, known-size collection\nor a small integer range. Unbounded `while` loops are not needed.\n\n---\n\n## Syntax\n\n### For-each (collection iteration)\n\n    for PATTERN in EXPR { BODY }\n\n### For-range (numeric iteration)\n\n    for IDENT in EXPR..EXPR { BODY }\n\nThe `..` produces a half-open range: `0..3` iterates over `0, 1, 2`.\n\n`for` is an expression (consistent with `if` and `match`). It appears in\n`primary_expr` alongside `if_expr` and `match_expr`.\n\n### Examples\n\n```ttrpg\n// Iterate over a list of targets\nfor target in targets {\n    target.HP -= damage\n}\n\n// Range-based iteration (Extra Attack)\nfor i in 0..extra_attacks(attacker) {\n    let result = resolve_melee_attack(attacker, target, weapon)\n    match result {\n        hit(amount) =\u003e { target.HP -= amount },\n        miss =\u003e {}\n    }\n}\n\n// Pattern matching — filter + destructure\nfor hit(amount) in results {\n    total_damage += amount\n}\n\n// Option filtering\nfor some(value) in optional_items {\n    process(value)\n}\n\n// AoE with saving throws\nfor target in targets {\n    let save = roll(d20_expr(score: target.abilities[DEX]))\n    if save \u003c DC {\n        target.HP -= damage_roll.total\n    } else {\n        target.HP -= floor(damage_roll.total / 2)\n    }\n}\n```\n\n---\n\n## Semantics\n\n### Iterable types\n\n| Source          | Binding type | Iteration order          |\n|-----------------|--------------|--------------------------|\n| `list\u003cT\u003e`       | `T`          | Index order              |\n| `set\u003cT\u003e`        | `T`          | Sorted order (BTreeSet)  |\n| `a..b` (range)  | `int`        | Ascending, half-open     |\n\nMap iteration is **deferred** to a future issue. Users who need map\nkeys/values can use `keys(map)` / `values(map)` builtins (also deferred;\nmaps are not the motivating use case for loops).\n\n### Return value\n\n**For-loops return `unit`.**\n\nFor-loops exist for side-effectful iteration — the primary TTRPG use cases\nare all about mutating game state (dealing damage, applying conditions,\nrolling dice). Returning unit keeps the implementation simple and avoids\nintroducing `list\u003cunit\u003e` as a type.\n\nFuture enhancement: collection semantics (`for x in xs { f(x) }` returns\n`list\u003cT\u003e`) could be added later. The AST and parser design below are\nforward-compatible with this change, which would be non-breaking (it makes\npreviously-erroring code valid rather than changing existing behavior).\n\n### Scoping\n\nEach iteration gets a fresh lexical scope:\n1. Push scope\n2. Bind loop variable(s) from pattern\n3. Evaluate body\n4. Pop scope\n\nLoop variables are immutable (consistent with `let` bindings). Mutation\nhappens through entity field assignment (`target.HP -= amount`), not\nthrough loop variable rebinding.\n\n### Empty collection / empty range\n\n- Empty list/set: zero iterations, returns `unit`\n- `a..b` where `a \u003e= b`: zero iterations, returns `unit`\n\n### Pattern matching in loops\n\nFor-loops support the full pattern infrastructure (reusing `PatternKind`):\n\n| Pattern               | Effect                                  |\n|-----------------------|-----------------------------------------|\n| `x`                   | Irrefutable — binds every element        |\n| `hit(amount)`         | Destructure enum variant, skip non-match |\n| `some(value)`         | Unwrap option, skip `none` values        |\n| `_`                   | Wildcard — matches all, binds nothing    |\n| `MyStruct(a, b)`      | Destructure, skip non-match             |\n\nWhen a pattern does not match an element, that iteration is **silently\nskipped**. This provides built-in filtering without a separate construct.\n\n### No break / continue\n\nNot included in this design. Bounded TTRPG collections are small, and\nconditional logic within the loop body (`if`/`match`) covers skip and\nearly-exit patterns adequately. These can be added later if needed.\n\n---\n\n## Grammar changes\n\nNew production in `primary_expr`:\n\n    primary_expr    = ... | for_expr\n    for_expr        = \"for\" pattern \"in\" for_source block\n    for_source      = expr \"..\" expr       // range\n                    | expr                 // collection\n\nDisambiguation: parse the expression after `in`. Since `..` is not a\nbinary operator in expression context, the expression parser naturally\nstops before `..`. If the next token is `DotDot`, parse the range end;\notherwise treat the expression as a collection iterable.\n\n### Newline handling\n\n`for` starts an expression — no special NL suppression rules needed beyond\nwhat `{` already provides. The `in` keyword already suppresses NL after it\n(it is a binary operator in the existing grammar).\n\n---\n\n## Keyword changes\n\n- Add `for` as a **reserved keyword** (`TokenKind::For`)\n- `in` already reserved, `..` already a token (`DotDot`)\n\n`for` is not currently used as an identifier anywhere in the spec or\nexamples. Reserving it is non-breaking for existing programs.\n\n---\n\n## AST changes\n\nNew variant in `ExprKind`:\n\n```rust\nFor {\n    pattern: Box\u003cSpanned\u003cPatternKind\u003e\u003e,\n    iterable: ForIterable,\n    body: Block,\n},\n```\n\nNew enum:\n\n```rust\npub enum ForIterable {\n    Collection(Box\u003cSpanned\u003cExprKind\u003e\u003e),\n    Range {\n        start: Box\u003cSpanned\u003cExprKind\u003e\u003e,\n        end: Box\u003cSpanned\u003cExprKind\u003e\u003e,\n    },\n}\n```\n\nThis unified representation keeps type-checking and evaluation logic\nshared between collection and range iteration.\n\n---\n\n## Type checker changes\n\nNew rules in `check_expr`:\n\n1. **For-each**: `for P in E { B }`\n   - `E` must have type `list\u003cT\u003e` or `set\u003cT\u003e`\n   - Pattern `P` checked against element type `T` (reuse `check_pattern`)\n   - Body `B` type-checked in scope with pattern bindings\n   - Expression type: `unit`\n\n2. **For-range**: `for x in A..B { C }`\n   - `A` and `B` must have type `int`\n   - `x` binds as `int`\n   - Body `C` type-checked with `x: int` in scope\n   - Expression type: `unit`\n\nError cases:\n- `for x in 42 { ... }` → \"expected list or set, found int\"\n- `for x in some_map { ... }` → \"map iteration not supported; use keys() or values()\"\n- `for x in 1.5..10 { ... }` → \"range bounds must be int\"\n\n---\n\n## Interpreter changes\n\nNew function `eval_for`:\n\n```rust\nfn eval_for(env: \u0026mut Env, pattern: \u0026PatternKind,\n            iterable: \u0026ForIterable, body: \u0026Block)\n            -\u003e Result\u003cValue, RuntimeError\u003e\n{\n    let items: Vec\u003cValue\u003e = match iterable {\n        ForIterable::Collection(expr) =\u003e match eval_expr(env, expr)? {\n            Value::List(items) =\u003e items,\n            Value::Set(items) =\u003e items.into_iter().map(Value::from).collect(),\n            other =\u003e return Err(not_iterable(other)),\n        },\n        ForIterable::Range { start, end } =\u003e {\n            let s = eval_expr(env, start)?.as_int()?;\n            let e = eval_expr(env, end)?.as_int()?;\n            (s..e).map(Value::Int).collect()\n        }\n    };\n\n    for item in items {\n        let mut bindings = HashMap::new();\n        if match_pattern(env, pattern, \u0026item, \u0026mut bindings) {\n            env.push_scope();\n            for (name, val) in bindings {\n                env.bind(name, val);\n            }\n            eval_block(env, body)?;\n            env.pop_scope();\n        }\n    }\n\n    Ok(Value::None)\n}\n```\n\nKey properties:\n- Collects iterable into a Vec up front (no lazy iteration needed for\n  small TTRPG collections)\n- Reuses existing `match_pattern` + scope push/pop infrastructure\n- Non-matching patterns silently skip (no error)\n- Returns `Value::None` (unit)\n\n---\n\n## CLI / REPL changes\n\n- `TtrpgHighlighter`: highlight `for` as keyword\n- `TtrpgValidator`: `for` opens a block (add to delimiter counting)\n- `TtrpgCompleter`: `for` as keyword completion\n\n---\n\n## Implementation plan\n\n| Phase | Crate         | Work                                           |\n|-------|---------------|-------------------------------------------------|\n| 1     | ttrpg_lexer   | Add `TokenKind::For`, reserve `for`             |\n| 2     | ttrpg_ast     | Add `ExprKind::For`, `ForIterable` enum         |\n| 3     | ttrpg_parser  | Parse `for_expr` in `primary_expr`              |\n| 4     | ttrpg_checker | Type-check for-loops (collection + range)       |\n| 5     | ttrpg_interp  | `eval_for` implementation                       |\n| 6     | ttrpg_cli     | Highlighter, validator, completer updates        |\n| 7     | spec          | Update grammar spec, add examples               |\n\nPhases 1-3 can land as a parsing-only PR. Phase 4-5 adds semantics.\nPhase 6-7 are polish.\n\n---\n\n## Open questions\n\n1. **Collection semantics later?** The design is forward-compatible with\n   changing the return type to `list\u003cT\u003e` when the body is non-unit. Worth\n   doing now or defer?\n\n2. **Range inclusivity**: `1..4` means `[1, 2, 3]` (half-open, Rust-style).\n   Should we also support `1..=4` for `[1, 2, 3, 4]` (inclusive)? D\u0026D\n   spell slot levels are 1-9 inclusive, so `for level in 1..10` vs\n   `for level in 1..=9`.\n\n3. **Nested for-loops**: Should work naturally via scope stacking. Any\n   reason to restrict nesting depth?","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:00Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:39:36Z","closed_at":"2026-02-22T20:39:36Z","close_reason":"Closed","labels":["language-design"]}
{"id":"ttrpg_dsl-dz3.1","title":"For-loop: Lexer — Add TokenKind::For, reserve `for` keyword","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:16Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:22:41Z","closed_at":"2026-02-22T20:22:41Z","close_reason":"Added TokenKind::For to lexer, keyword match in lex_ident_or_keyword, highlighter keyword group, and completer DSL_KEYWORDS list. All tests pass."}
{"id":"ttrpg_dsl-dz3.2","title":"For-loop: AST — Add ExprKind::For variant and ForIterable enum","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:25:26Z","closed_at":"2026-02-22T20:25:26Z","close_reason":"Added ExprKind::For variant and ForIterable enum to AST. Added stub arms in checker (check_for -\u003e Ty::Unit) and interpreter (RuntimeError). All 815 tests pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.2","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:16Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.2","depends_on_id":"ttrpg_dsl-dz3.1","type":"blocks","created_at":"2026-02-22T11:50:31Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.3","title":"For-loop: Parser — Parse for_expr in primary_expr (collection + range forms)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:27:31Z","closed_at":"2026-02-22T20:27:31Z","close_reason":"Added parse_for_expr in primary_expr. Parses both collection (for x in expr {}) and range (for x in a..b {}) forms with full pattern support. 7 new parser tests, all 822 tests pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.3","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:17Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.3","depends_on_id":"ttrpg_dsl-dz3.2","type":"blocks","created_at":"2026-02-22T11:50:34Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.4","title":"For-loop: Type checker — Type-check for-loops (collection + range, pattern bindings)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:18Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:31:26Z","closed_at":"2026-02-22T20:31:26Z","close_reason":"Implemented check_for: validates collection (list/set) and range (int bounds) iterables, checks pattern bindings against element type, marks for-loop bindings as non-local for entity field mutation. Added mark_current_scope_non_local to ScopeStack. 9 new tests (valid + error cases), all 831 pass.","dependencies":[{"issue_id":"ttrpg_dsl-dz3.4","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:18Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.4","depends_on_id":"ttrpg_dsl-dz3.3","type":"blocks","created_at":"2026-02-22T11:50:34Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.5","title":"For-loop: Interpreter — eval_for implementation (collection iteration, range iteration, pattern matching)","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:19Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:36:55Z","closed_at":"2026-02-22T20:36:55Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-dz3.5","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:19Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.5","depends_on_id":"ttrpg_dsl-dz3.4","type":"blocks","created_at":"2026-02-22T11:50:35Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.6","title":"For-loop: CLI — Highlighter, validator, completer updates for `for` keyword","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:20Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:37:36Z","closed_at":"2026-02-22T20:37:36Z","close_reason":"All three CLI components (highlighter, completer, validator) already handled: highlighter and completer done in phase 1, validator is delimiter-based and needs no keyword changes","dependencies":[{"issue_id":"ttrpg_dsl-dz3.6","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:20Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.6","depends_on_id":"ttrpg_dsl-dz3.1","type":"blocks","created_at":"2026-02-22T11:50:35Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-dz3.7","title":"For-loop: Spec — Update canonical grammar, add for-loop examples","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-22T19:50:21Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:39:33Z","closed_at":"2026-02-22T20:39:33Z","close_reason":"Closed","dependencies":[{"issue_id":"ttrpg_dsl-dz3.7","depends_on_id":"ttrpg_dsl-dz3","type":"parent-child","created_at":"2026-02-22T11:50:21Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-dz3.7","depends_on_id":"ttrpg_dsl-dz3.5","type":"blocks","created_at":"2026-02-22T11:50:36Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-efg","title":"Parser: `none` is not a valid match pattern","description":"The pattern parser (pattern.rs) does not handle TokenKind::None. This means `match opt_val { none =\u003e ..., _ =\u003e ... }` fails with 'expected pattern, found None'. The spec implies option types should be matchable. Fix: add a None case to parse_pattern() that produces PatternKind::Literal with a None value.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:47:48Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:28:54Z","closed_at":"2026-02-22T17:28:54Z","close_reason":"Added PatternKind::NoneLit, handled in parser (parse_pattern), checker (check_pattern), and interpreter (match_pattern).","labels":["parser"]}
{"id":"ttrpg_dsl-fz0","title":"CLI: pipe/script mode exits on load failure, diagnostics unreachable","description":"In pipe mode (run_pipe, main.rs:38) and script mode (run_script, main.rs:64), any command error calls process::exit(1) immediately. This means if `load` fails with parse/check errors, the subsequent `errors` command never runs — the user cannot see what went wrong.\n\nThe diagnostics ARE stored on the Runner (runner.rs:280), but the process exits before the next line of stdin/script is read.\n\nOptions:\n- Don't exit on load failure in pipe/script mode — just print the error and continue\n- Auto-print diagnostics on load failure (first N errors)\n- Add a --keep-going flag for script mode\n- In pipe mode, treat load failure as non-fatal (the Runner is still usable, just with no program loaded)","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:08:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T17:58:36Z","closed_at":"2026-02-22T17:58:36Z","close_reason":"pipe/script mode now continues on error instead of exiting immediately, so diagnostics are reachable","labels":["cli"]}
{"id":"ttrpg_dsl-gpe","title":"Fix scope leak in eval_for on body error","description":"eval_for uses ? on eval_block which skips pop_scope() on error, violating scope-balance invariants.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T20:51:08Z","created_by":"Theodore Gast","updated_at":"2026-02-22T20:54:40Z","closed_at":"2026-02-22T20:54:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-gwr","title":"Checker: with constraints not enforced at call sites","description":"The with keyword on actions/reactions is only used for body-internal narrowing. Call sites never check that the receiver actually has the required group, leading to runtime field-access errors instead of type errors. Need to store with_groups in param metadata and validate at call sites.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:06Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-hpg","title":"Language: ordered enums / enum-to-int conversion","description":"Enums have no inherent ordering. In 5e, Size (tiny \u003c small \u003c medium \u003c large \u003c huge \u003c gargantuan) needs comparison:\n    requires { target.size \u003c= grappler.size + 1 }\nThis is impossible because Size is an enum without ordinal values. Workaround is != checks for specific variants, which doesn't generalize.\n\nOptions:\n- Ordered enums: `enum Size ordered { tiny, small, medium, large, huge, gargantuan }`\n- Enum-to-int builtin: `ordinal(Size.medium) -\u003e 2`\n- Comparable enums that support \u003c, \u003e, \u003c=, \u003e= based on declaration order","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:36Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:36Z","labels":["language-design","type-system"]}
{"id":"ttrpg_dsl-hwf","title":"Parser: newlines inside brace-delimited blocks not suppressed","description":"Newlines inside { } are NOT suppressed (unlike () and []). This means multiline expressions in requires/cost blocks fail: requires { a \u0026\u0026\\n b } breaks. Only the opening { suppresses the next NL, not all NLs inside braces. Workaround: put everything on one line, or wrap in parens. See pain point #18 in examples/dnd5e_expanded.ttrpg.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-22T17:50:44Z","created_by":"Theodore Gast","updated_at":"2026-02-22T18:07:24Z","closed_at":"2026-02-22T18:07:24Z","close_reason":"Added suppress_newlines_in_brace_block() to strip NL tokens in expression-brace contexts (requires, cost)"}
{"id":"ttrpg_dsl-iuw","title":"Language: parameterized conditions","description":"Conditions are binary (present or absent) and take no parameters. In 5e:\n- Frightened needs a 'source' entity (can't willingly move closer to source)\n- Exhaustion has 6 levels with escalating effects\n- Grappled needs a reference to the grappler (grappler's speed is also 0)\n\nWould need: `condition Frightened(source: Character) on bearer: Character { ... }`\nor: `condition Exhaustion(level: int) on bearer: Character { ... }`\n\nWithout this, parameterized effects require separate conditions per case or external state tracking.","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:50:11Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:50:11Z","labels":["language-design"]}
{"id":"ttrpg_dsl-ixk","title":"Checker: implement collect_hook and check_hook","description":"Add FnKind::Hook to env.rs. Add collect_hook() to collect.rs (validate entity receiver, reject trigger/turn shadows, register via collect_fn). Add check_hook() to check.rs (bind receiver, validate trigger event+bindings, bind trigger/turn, type-check body). Extract shared trigger-checking from check_reaction if needed. See plan: .claude/plans/staged-rolling-raccoon.md Steps 3-4.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:39Z","created_by":"Theodore Gast","updated_at":"2026-02-23T06:13:20Z","closed_at":"2026-02-23T06:13:20Z","close_reason":"Added FnKind::Hook, BlockKind::HookResolve, collect_hook(), check_hook(). Extracted shared check_trigger_and_body() from check_reaction. Hook context allows dice, mutation, turn, and action calls.","dependencies":[{"issue_id":"ttrpg_dsl-ixk","depends_on_id":"ttrpg_dsl-6ee","type":"blocks","created_at":"2026-02-22T21:55:48Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-jkl","title":"AST: add HookDecl and Program index","description":"Add HookDecl struct to ttrpg_ast/src/ast.rs (receiver, trigger, body — like ReactionDecl minus cost). Add DeclKind::Hook variant. Add hooks HashMap and hook_order Vec to Program. Wire into build_index(). See plan: .claude/plans/staged-rolling-raccoon.md Step 1.","status":"closed","priority":2,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T05:55:36Z","created_by":"Theodore Gast","updated_at":"2026-02-23T05:59:00Z","closed_at":"2026-02-23T05:59:00Z","close_reason":"Added HookDecl struct, DeclKind::Hook variant, hooks HashMap + hook_order Vec to Program, wired into build_index(), and added placeholder arms in checker collect/check"}
{"id":"ttrpg_dsl-kmy","title":"Language: struct update syntax","description":"Structs are immutable value types. To change one field, the entire struct must be reconstructed. There is no spread/update syntax like:\n    let upcast_spell = spell { damage: new_damage, ..spell }\n\nThis matters for spell upcasting (change damage dice based on slot level), buff modifications, and any case where a struct is 'almost the same' with one field changed.\n\nRust-style struct update syntax (`..base`) would be a natural fit.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:52:07Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:52:07Z","labels":["ergonomics","language-design"]}
{"id":"ttrpg_dsl-mcy","title":"Parser: only one requires block allowed per action","description":"Actions can only have a single requires {} block. Multiple preconditions must be combined with \u0026\u0026 on one long line. Multiline expressions inside requires {} also fail because newlines inside braces are not suppressed (unlike parens/brackets). Either support multiple requires blocks or suppress newlines inside requires {} braces.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:48:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:48:50Z","labels":["ergonomics","parser"]}
{"id":"ttrpg_dsl-o1b","title":"Parser: parse optional groups and related syntax","description":"Parse all optional group syntax:\n- optional { fields... } blocks inside entity declarations (decl.rs: parse_entity_decl)\n- 'with GroupName' constraints on action/derive/mechanic/condition receivers and parameters (decl.rs: parse_param, parse_action_decl, etc.)\n- 'has' expressions at comparison precedence level (expr.rs)\n- 'grant entity.Group { field: val, ... }' and 'revoke entity.Group' statements (stmt.rs)\nAll new keywords (optional, grant, revoke, has, with) are soft keywords — lexed as Ident, matched by name in the parser.\nDepends on AST changes.","status":"closed","priority":1,"issue_type":"task","owner":"tfgast@gmail.com","created_at":"2026-02-23T00:32:28Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:49:45Z","closed_at":"2026-02-23T00:49:45Z","close_reason":"Parser now handles: optional groups in entities, has expressions, with constraints on params/receivers, grant/revoke statements. 16 new tests, all 860 pass.","dependencies":[{"issue_id":"ttrpg_dsl-o1b","depends_on_id":"ttrpg_dsl-950","type":"blocks","created_at":"2026-02-22T16:32:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-pzy","title":"Language: turn phase hooks (on_turn_start, on_turn_end)","description":"No way to express automatic effects at the start or end of a turn:\n- Death saves happen at start of turn when at 0 HP\n- Regeneration happens at start of turn\n- Many conditions allow a repeat save at end of turn\n- Some effects trigger 'at the start of each of your turns'\n\nEvents/reactions are for OTHER entities reacting. Need a turn-phase hook system:\n    on_turn_start(actor: Character) {\n        if actor.HP == 0 \u0026\u0026 !(Stable in actor.conditions) {\n            do DeathSave on actor ()\n        }\n    }\n\nThis interacts with the Duration system (#9) — 'until a save is made' needs an end-of-turn hook to trigger the save.","notes":"Scoped down to hook declaration type (mandatory triggered action). Condition 'on' clauses deferred. No built-in events — game designers declare their own phase events. Implementation tracked in: ttrpg_dsl-5z0 (spec), ttrpg_dsl-jkl (AST), ttrpg_dsl-6ee (parser), ttrpg_dsl-ixk (checker), ttrpg_dsl-d83 (interp), ttrpg_dsl-beu (tests). Plan: .claude/plans/staged-rolling-raccoon.md","status":"open","priority":2,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:27Z","created_by":"Theodore Gast","updated_at":"2026-02-23T05:55:56Z","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-pzy","depends_on_id":"ttrpg_dsl-d3r","type":"related","created_at":"2026-02-22T07:51:26Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-q5l","title":"Language: union types for heterogeneous entity references","description":"No union or sum type beyond enum payloads. In 5e, a 'damage source' could be a Weapon, Spell, or environment. Actions that work on 'any character type' need a common base. Currently no way to write:\n    type DamageSource = Weapon | Spell | Environment\n    action Attack on attacker: Character | Monster (target: Character | Monster, ...) { ... }\n\nEnum payloads can approximate this but with significant boilerplate for wrapping/unwrapping. Entity trait system (ttrpg_dsl-s43) might subsume this need.","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T16:01:47Z","created_by":"Theodore Gast","updated_at":"2026-02-22T16:01:47Z","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-q5l","depends_on_id":"ttrpg_dsl-s43","type":"related","created_at":"2026-02-22T08:01:47Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-qv2","title":"Interp: grant default resolution picks first global match","description":"find_optional_group walks all entity decls and returns the first group with matching name. If two entity types define the same group name with different defaults, wrong defaults may be used. Need to resolve defaults based on the receiver's entity type.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:07Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-s43","title":"Language: entity composition / traits / mixins","description":"Entities have no composition mechanism. In 5e, a Character entity grows to 40+ fields because spellcasting, class features, and equipment all live in one flat struct. There is no way to express:\n- trait Spellcaster { spellcasting_ability: Ability, spell_save_DC: int, ... }\n- entity Wizard: Character with Spellcaster { ... }\n- Optional field groups that only exist for certain character classes\n\nClass features end up as boolean flags (has_extra_attack, has_sneak_attack, etc.) with no type safety or associated behavior.","design":"Settled on optional groups as the composition mechanism. Key decisions:\n\n- **Approach**: Optional field groups declared inside entities with `optional GroupName { fields... }`\n- **Access**: Namespaced — `actor.Spellcasting.spell_save_DC`\n- **Guards**: `has` keyword as composable boolean expression with flow-sensitive type narrowing (`if actor has Spellcasting { ... }`)\n- **Activation**: `grant`/`revoke` keywords for runtime enable/disable in action resolve blocks\n- **Deactivation**: Discard field values on revoke (groups model structural identity, not toggles)\n- **Constraints**: `with GroupName` on action/derive/mechanic/condition parameters for lightweight polymorphism\n- **Cross-entity reuse**: Deferred — manual repetition for now, door open for future mixins/traits\n\nDesign doc: spec/design/entity_composition.md\n\nSurveyed 6 TTRPG systems (D\u0026D 5e, PF2e, CoC 7e, Savage Worlds, CofD, PbtA, FATE) and evaluated traits, inheritance, mixins, and optional groups against each. Optional groups cover the highest-value use cases (class-conditional fields, multiclassing, edge-activated subsystems) with moderate complexity.","status":"in_progress","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:11Z","created_by":"Theodore Gast","updated_at":"2026-02-23T00:28:40Z","labels":["language-design"],"dependencies":[{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-5ho","type":"blocks","created_at":"2026-02-22T16:33:58Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-8d6","type":"blocks","created_at":"2026-02-22T16:33:59Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-8j9","type":"blocks","created_at":"2026-02-22T16:33:58Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-950","type":"blocks","created_at":"2026-02-22T16:33:57Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-avf","type":"blocks","created_at":"2026-02-22T16:33:59Z","created_by":"Theodore Gast","metadata":"{}"},{"issue_id":"ttrpg_dsl-s43","depends_on_id":"ttrpg_dsl-o1b","type":"blocks","created_at":"2026-02-22T16:33:57Z","created_by":"Theodore Gast","metadata":"{}"}]}
{"id":"ttrpg_dsl-x0y","title":"Checker: has narrowing keyed by root var only","description":"extract_root_var collapses actor.friend and actor.target to actor, so 'if actor.friend has Spellcasting' incorrectly narrows actor.target.Spellcasting too. Need to key narrowings by full path, not just root variable.","status":"closed","priority":1,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T01:37:04Z","created_by":"Theodore Gast","updated_at":"2026-02-23T01:51:40Z","closed_at":"2026-02-23T01:51:40Z","close_reason":"Closed"}
{"id":"ttrpg_dsl-xh9","title":"Language: cost overrides and free/no-cost actions","description":"Two related issues with the action cost system:\n\n1. No 'free' or 'no cost' designation. Action Surge has no action cost — omitting the cost block works but is indistinguishable from forgetting to declare a cost (potential footgun).\n\n2. No way to override the cost of an existing action. In 5e, Rogue's Cunning Action lets you Dash/Disengage/Hide as a bonus action instead of an action. Currently requires duplicating the entire action with a different cost block (CunningDash, CunningDisengage). Would like:\n    condition CunningAction on bearer: Character {\n        modify Dash.cost(actor: bearer) { cost = bonus_action }\n    }","status":"open","priority":3,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:51:17Z","created_by":"Theodore Gast","updated_at":"2026-02-22T15:51:17Z","labels":["language-design"]}
{"id":"ttrpg_dsl-xyp","title":"Default lookup can silently use wrong entity's optional group definition","description":"Both interpreter and CLI default-fill helpers fall back to the first matching group name if entity type is unknown (eval.rs:1916, runner.rs:1051). This makes defaults declaration-order-dependent and can apply incorrect defaults without error. Fix: treat unknown entity type during default filling as an error instead of falling back.","status":"closed","priority":2,"issue_type":"bug","owner":"tfgast@gmail.com","created_at":"2026-02-23T04:23:33Z","created_by":"Theodore Gast","updated_at":"2026-02-23T04:41:09Z","closed_at":"2026-02-23T04:41:09Z","close_reason":"Removed fallback in find_optional_group — returns None when entity type is unknown instead of using wrong entity's defaults"}
{"id":"ttrpg_dsl-zq1","title":"Language: option\u003cT\u003e destructuring and unwrapping","description":"option\u003cT\u003e values cannot be destructured or unwrapped:\n- No `some(x)` pattern in match: `match val { some(x) =\u003e x.field, none =\u003e default }`\n- No `if let` syntax: `if let some(armor) = char.equipped_armor { ... }`\n- No `.unwrap()` or `.unwrap_or(default)` methods\n- Can't use option\u003cAbility\u003e as a map index without unwrapping first\n- `none` is not a valid pattern (separate parser bug ttrpg_dsl-efg)\n\nThis blocks any idiomatic use of option fields on entities (equipped_armor, spellcasting_ability, etc.).","status":"closed","priority":1,"issue_type":"feature","owner":"tfgast@gmail.com","created_at":"2026-02-22T15:49:50Z","created_by":"Theodore Gast","updated_at":"2026-02-22T19:04:18Z","closed_at":"2026-02-22T19:04:18Z","close_reason":"All destructuring/unwrapping items complete: none pattern (ttrpg_dsl-efg), some(x) match pattern, .unwrap()/.unwrap_or(), if let some(x). Option-as-index tracked separately in ttrpg_dsl-7ch.","labels":["language-design","type-system"],"dependencies":[{"issue_id":"ttrpg_dsl-zq1","depends_on_id":"ttrpg_dsl-efg","type":"blocks","created_at":"2026-02-22T08:04:54Z","created_by":"Theodore Gast","metadata":"{}"}]}
