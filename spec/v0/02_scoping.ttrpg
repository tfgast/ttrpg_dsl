// ============================================================
// v0 Spec — Part 2: Scoping, Mutation, and Modules
//
// Who is "self"? What can mutate? How do files compose?
// ============================================================


// --- Block categories ---
//
// Category     Dice?   Mutate?   Receiver?   Returns?   Purpose
// --------     -----   -------   ---------   --------   -------
// derive       no      no        no          value      pure computation
// mechanic     yes     no        no          value      dice + logic, returns a value
// action       yes     yes       yes         unit       game action, changes state
// reaction     yes     yes       yes         unit       triggered action, changes state
// hook         yes     yes       yes         unit       mandatory triggered action, always fires
// condition    no      no        yes         n/a        declarative modifier overlay
// prompt       no      no        no          value      human decision point
//
// "Returns?" indicates whether the block is value-returning.
// derive/mechanic: last stmt MUST be expr_stmt (its value is the return).
// action/reaction resolve: no constraint (any block value is discarded).
// See 03_canonical_grammar.ttrpg "Block value semantics" for details.
//
// Key: "Mutate?" means can the block assign to entity fields
//      (e.g., target.HP -= 5).
//
// action, reaction, and hook are the ONLY blocks that can mutate entity state.
// mechanic can call roll() but CANNOT assign to entity fields.
// condition does NOT mutate — its modify clauses are declarative overlays
//   that alter computed results, not imperative assignments (see below).


// --- Receivers: the `on` keyword ---
//
// Blocks that operate on behalf of an entity declare a receiver
// with the `on` keyword. This replaces implicit `self`.
//
// Syntax: `action Name on receiver_name: ReceiverType (params) { ... }`
//
// The receiver is just a named parameter with special status:
// - It's the entity performing the action
// - It's used for cost deduction (action economy)
// - condition uses it for the entity bearing the condition
//
// Actions can be invoked in two equivalent ways:
//   Attack(attacker_entity, target, weapon)   // function-call form
//   attacker_entity.Attack(target, weapon)    // method-call form
//
// The method form desugars to the function form — the receiver
// becomes the first argument. See 03_canonical_grammar.ttrpg for
// the full resolution rules.

// EXAMPLE: explicit receiver, all field access names its source
action Attack on attacker: Character (target: Character, weapon: Weapon) {
    cost { action }
    requires { distance(attacker.position, target.position) <= weapon.range }
    resolve {
        // attacker.abilities, target.AC — always explicit
    }
}

// EXAMPLE: derive — no receiver, pure function of its arguments
derive modifier(score: int) -> int {
    floor((score - 10) / 2)
}

// EXAMPLE: mechanic — no receiver, can roll but cannot mutate
mechanic attack_roll(
    attacker: Character,
    target: Character,
    weapon: Weapon,
    mode: RollMode = normal
) -> RollResult {
    // Can call roll(), but CANNOT write `target.HP -= ...`
    let ability = choose_attack_ability(attacker, weapon)
    let expr = d20_expr(
        score: attacker.abilities[ability],
        proficiency: proficiency_bonus(attacker.level),
        mode: mode
    )
    roll(expr)
}


// --- Group aliases (`as`) ---
//
// When accessing optional group fields, the full path can be verbose:
//   caster.Spellcasting.spell_dc + caster.Spellcasting.spell_slots
//
// The `as` keyword on `with` constraints and `has` guards creates a
// locally-scoped alias that shortens these paths.
//
// On `with` constraints (scoped to the function/action body):

action CastSpell on caster: Character with Spellcasting as sc (cost: int) {
    resolve {
        // `sc` is an alias for `Spellcasting` on `caster`
        caster.sc.spell_slots -= cost
    }
}

// On `has` guards (scoped to the then-block):

derive effective_dc(c: Character) -> int {
    if c has Spellcasting as sc {
        c.sc.spell_dc + c.level     // alias visible here
    } else {
        0                            // alias NOT visible here
    }
}

// Multiple aliases can coexist:

derive total_resources(c: Character) -> int {
    let spells = if c has Spellcasting as sc { c.sc.spell_slots } else { 0 }
    let ki = if c has KiPowers as kp { c.kp.ki_points } else { 0 }
    spells + ki
}

// Aliases work for both reads and writes (in mutation contexts).
// They are purely syntactic — the checker resolves them at check time
// and no runtime name is created.
//
// Restrictions:
//   - An alias must not shadow an existing field or group name on the
//     same entity type. This prevents ambiguity in field resolution.
//   - The alias is not visible outside its scope (function body or
//     then-block).


// --- Conditions and `modify` ---
//
// condition blocks declare modifier overlays. A modify clause says:
//   "When function X is called and these bindings match,
//    apply these transformations."
//
// This is NOT mutation. The condition doesn't execute imperative code.
// It declares transformation rules that the runtime applies.
//
// Modify operates in two phases:
//
//   Phase 1 — Pre-call (parameter rewrite):
//     Statements of the form `param_name = expr` override input
//     parameters of the target function BEFORE it executes.
//     Example: `mode = disadvantage` rewrites the mode parameter
//     of attack_roll before the roll happens.
//
//   Phase 2 — Post-call (result rewrite):
//     Statements of the form `result.field = expr` modify fields
//     of the target function's return value AFTER it executes.
//     Example: `result.movement = result.movement - 15` adjusts
//     the movement field of initial_budget's returned TurnBudget.
//
// Both phases are declarative. Neither phase assigns to entity fields.
//
// The modify clause targets a specific mechanic/derive by name and
// binds its parameters to condition context.

condition Prone on bearer: Character {
    // When attack_roll is called with attacker == bearer: set mode to disadvantage
    modify attack_roll(attacker: bearer) {
        mode = disadvantage
    }

    // When attack_roll is called with target == bearer: mode depends on distance
    modify attack_roll(target: bearer) {
        mode = if distance(attacker.position, bearer.position) <= 5 {
            advantage
        } else {
            disadvantage
        }
    }

    // When initial_budget is computed for bearer: halve movement
    modify initial_budget(actor: bearer) {
        result.movement = result.movement - floor(bearer.speed / 2)
    }
}

// The modify clause binds `attacker: bearer` meaning "this modifier fires
// when the `attacker` parameter equals the entity bearing Prone."
// Inside the modify body, other parameters of the target function
// (e.g., `attacker`, `target`) are in scope as read-only bindings.
// `result` refers to the output of the target function, for post-modification.
//
// `let` statements are allowed in modify bodies for intermediate values:
//   modify attack_roll(target: bearer) {
//       let dist = distance(attacker.position, bearer.position)
//       mode = if dist <= 5 { advantage } else { disadvantage }
//   }


// --- Modify conflict resolution ---
//
// When multiple active conditions modify the same parameter of the
// same function call, modifiers are applied in the order the conditions
// were gained by the entity (oldest first). Within a single condition,
// clauses are applied in declaration order.
//
// Each modifier sees the parameter value left by the previous modifier
// (pipeline model, not independent evaluation). Last writer wins.
//
// Example: entity has both Prone and Dodging, attacking a target.
//   1. Prone.modify attack_roll(attacker: bearer) sets mode = disadvantage
//   2. No other condition modifies this call
//   Result: mode = disadvantage
//
// Game-specific interactions (e.g., D&D 5e "advantage and disadvantage
// cancel out") are NOT built into the runtime. They should be modeled
// as a mechanic or derive that checks for conflicting conditions:
//
//   derive resolve_roll_mode(actor: Character, base_mode: RollMode) -> RollMode {
//       let has_adv = /* check conditions granting advantage */
//       let has_dis = /* check conditions granting disadvantage */
//       match { has_adv && has_dis => normal, has_adv => advantage,
//               has_dis => disadvantage, _ => base_mode }
//   }
//
// This keeps the modify system simple (last-writer-wins pipeline)
// and pushes game-specific cancellation logic into explicit DSL code.


// --- Cost free ---
//
// An action or reaction may declare `cost free` to explicitly signal
// that it consumes no turn resources. This is distinct from omitting
// the cost clause: omission is ambiguous (intentional? forgotten?),
// while `cost free` is an unambiguous declaration.
//
//   action Cantrip on caster: Character () {
//       cost free
//       resolve { ... }
//   }
//
// Semantics:
//   - No DeductCost effects are emitted at runtime.
//   - Cost modifiers (modify Action.cost) can still apply to change
//     a free action's cost, or to make a costed action free.
//   - `cost free` is valid on both actions and reactions.


// --- Cost modification (modify Action.cost) ---
//
// Conditions can override an action's cost using the `.cost` suffix
// on modify clauses. This enables features like D&D 5e's Cunning
// Action (Dash/Disengage/Hide as a bonus action) without duplicating
// the entire action definition.
//
// Syntax:
//   condition CunningAction on bearer: Character {
//       modify Dash.cost(actor: bearer) { cost = bonus_action }
//   }
//
// The `.cost` suffix distinguishes cost modification from parameter/
// result modification. The target must be an action or reaction (not
// a derive or mechanic, which have no cost).
//
// Bindings work the same as regular modify clauses: the action's
// receiver and declared parameters are bindable. In the example above,
// `actor` is Dash's receiver name, bound to the condition's `bearer`.
//
// Cost modify bodies support:
//   - `cost = token1, token2` — replace the cost with new tokens
//   - `cost = free` — waive the cost entirely
//   - `let` bindings for intermediate values
//   - `if`/`else` for conditional cost changes
//
// Cost modify bodies reject parameter overrides (`param = expr`) and
// result rewrites (`result.field = expr`) — those belong in regular
// modify clauses.
//
// Cost modifiers are collected from active conditions on the acting
// entity, applied in condition-gained order (oldest first), last
// writer wins. This follows the same pipeline model as parameter
// modification (see "Modify conflict resolution" above).
//
// EXAMPLE: Rogue's Cunning Action — Dash, Disengage, Hide as bonus action
//
//   condition CunningAction on bearer: Character {
//       modify Dash.cost(actor: bearer) { cost = bonus_action }
//       modify Disengage.cost(actor: bearer) { cost = bonus_action }
//       modify Hide.cost(actor: bearer) { cost = bonus_action }
//   }
//
// EXAMPLE: Conditional cost change (free if a resource is available)
//
//   condition Metamagic on bearer: Character {
//       modify Fireball.cost(caster: bearer) {
//           if bearer.sorcery_points >= 2 {
//               cost = free
//           }
//       }
//   }
//
// EXAMPLE: Cost modification emits a ModifyApplied effect showing
// the old and new cost, allowing the host to log the change.


// --- Turn state ---
//
// The action economy is managed by the runtime. The DSL declares:
//   1. initial_budget(actor) — derive returning the starting TurnBudget
//   2. cost { ... } on each action — what the action consumes
//   3. `turn` keyword in resolve blocks — access to mutable turn state
//
// `turn` is a keyword available ONLY inside action/reaction resolve blocks.
// It refers to the current turn's mutable TurnBudget.

struct TurnBudget {
    actions: int
    bonus_actions: int
    reactions: int
    movement: int
    free_interactions: int
}

derive initial_budget(actor: Character) -> TurnBudget {
    TurnBudget {
        actions: 1,
        bonus_actions: 1,
        reactions: 1,
        movement: actor.speed,
        free_interactions: 1
    }
}

// Example: Dash adds movement via the turn keyword
action Dash on actor: Character () {
    cost { action }
    resolve {
        turn.movement += actor.speed
    }
}


// --- Events ---
//
// Events declare the shape of trigger occurrences. The runtime emits
// events; reactions and hooks listen for them; conditions can suppress
// reactions (but not hooks).
//
// Syntax:
//   event entity_leaves_reach(reactor: Character) {
//       entity: Character
//       from_position: Position
//       to_position: Position
//   }
//
// The parameter list defines the matching context (which entity's
// reach is relevant). The body fields are the event payload.
// Inside a reaction's resolve block, `trigger` is bound to the
// event instance, and `trigger.entity`, `trigger.from_position`,
// etc. are accessible.


// --- Hooks (mandatory triggered actions) ---
//
// A hook is like a reaction that always fires and never costs resources.
// Where a reaction is an optional response (the player may choose to use
// their reaction), a hook is automatic — if the trigger matches, it runs.
//
// Hooks use the same trigger syntax as reactions. They have a receiver
// (the entity the hook acts on behalf of) and a trigger expression
// (the event to listen for). They have a resolve block that can roll
// dice, mutate entity fields, and access the turn budget.
//
// Key differences from reactions:
//   - No cost clause: hooks never consume action economy resources.
//   - Not suppressible: conditions cannot suppress hook triggers.
//   - Automatic: the host fires all matching hooks without player choice.
//
// Use hooks for mechanics that must happen whenever an event occurs:
//   - Death saves at start of turn when at 0 HP
//   - Regeneration at start of turn
//   - Condition saves at end of turn
//   - Auras that trigger when an entity enters range
//
// Syntax: `hook Name on receiver: Type (trigger: event(bindings)) { ... }`
//
// Inside the resolve block, `trigger` is bound to the event instance
// (same as reactions), and `turn` refers to the mutable turn budget.

// EXAMPLE: death save hook — fires at start of every turn for downed characters
hook DeathSaveCheck on actor: Character (
    trigger: turn_start(actor: actor)
) {
    if actor.HP == 0 {
        let save: RollResult = roll(1d20)
        if save.unmodified == 20 {
            actor.HP += 1
        }
    }
}

// EXAMPLE: regeneration — fires at start of turn
hook Regenerate on creature: Character (
    trigger: turn_start(actor: creature)
) {
    if creature.HP > 0 {
        creature.HP += 10
    }
}


// --- Emit (firing events from DSL code) ---
//
// The `emit` statement fires a named event from within an action's
// resolve block. When emit executes:
//
//   1. Argument expressions are evaluated and matched to event params.
//   2. Missing params with defaults are filled in.
//   3. Derived fields (event body fields with defaults) are evaluated.
//   4. The runtime finds all hooks whose trigger matches this event.
//   5. Each matching hook executes inline (in declaration order).
//   6. Control returns to the statement after emit.
//
// Reactions are NOT auto-fired by emit — they remain host-driven.
// The host receives the event payload and decides which reactions
// to offer to the player.
//
// Emit is only allowed in action resolve blocks. It is a statement
// (fire-and-forget), not an expression — it always returns unit.
//
// All arguments must be named:
//   emit Damaged(target: target, amount: damage)   // correct
//   emit Damaged(target, damage)                   // error: positional args not allowed
//
// Parameters with defaults can be omitted:
//   event Damaged(target: Character, amount: int = 0) {}
//   emit Damaged(target: victim)                   // amount defaults to 0

// EXAMPLE: action emits an event, triggering a hook
// action Attack on attacker: Character (target: Character) {
//     cost { action }
//     resolve {
//         target.HP -= 5
//         emit Damaged(target: target, amount: 5)
//         // If there is a hook like DeathCheck listening for Damaged,
//         // it fires here before the next statement executes.
//     }
// }


// --- Builtins ---
//
// Functions provided by the runtime, usable based on block permissions:
//
// Available everywhere:
//   floor(x: float) -> int          // round toward negative infinity
//   ceil(x: float) -> int           // round toward positive infinity
//   max(a: int, b: int) -> int
//   min(a: int, b: int) -> int
//   distance(a: Position, b: Position) -> int   // see Position in 01_type_system.ttrpg
//   dice(count: int, sides: int) -> DiceExpr
//   multiply_dice(expr: DiceExpr, factor: int) -> DiceExpr
//       // multiplies dice count only, constants unchanged
//       // multiply_dice(1d8 + 3, 2) => 2d8 + 3
//   ordinal(v: E) -> int
//       // E must be an enum value (returns its declaration order index)
//   from_ordinal(E, index: int) -> E
//       // E must be an ordered enum type; errors if out of range or payload variant
//   try_from_ordinal(E, index: int) -> option<E>
//       // E must be an ordered enum type; returns none for out-of-range/payload variant
//   len(xs: list<T> | set<T> | map<K, V>) -> int
//   keys(m: map<K, V>) -> list<K>
//   values(m: map<K, V>) -> list<V>
//   first(xs: list<T>) -> option<T>
//   last(xs: list<T>) -> option<T>
//   append(xs: list<T>, item: T) -> list<T>
//   concat(a: list<T>, b: list<T>) -> list<T>
//   reverse(xs: list<T>) -> list<T>
//
// Option methods (receiver syntax):
//   x.unwrap() -> T
//   x.unwrap_or(default: T) -> T
// These are methods, not free functions.
//
// Available in mechanic, action, reaction, hook (blocks that can roll):
//   roll(expr: DiceExpr) -> RollResult
//
// Available in action, reaction, hook (blocks that can mutate):
//   apply_condition(target: Character, cond: Condition, duration: Duration)
//   remove_condition(target: Character, cond: Condition)
//
// The `turn` keyword (available in action/reaction/hook resolve blocks):
//   Refers to the current turn's mutable TurnBudget.
//   turn.movement, turn.actions, etc. are assignable.


// --- Modules and imports ---
//
// Each file can contain `use` declarations and `system` blocks.
// `use` imports all public names from another system by name.
// All top-level declarations in a system block are public.
// No private/public distinction in v0.
//
// Grammar:
//   use_decl    = "use" STRING ("as" IDENT)? TERM
//   top_level   = use_decl | system_decl
//
// `as` is a soft keyword — it is recognized as a keyword after the
// `use` string literal, after group names in `with` constraints, and
// after group names in `has` expressions. Identifiers named `as` are
// valid elsewhere in the language.
//
// Multiple files are loaded via the CLI:
//   load core.ttrpg combat.ttrpg
//   load systems/*.ttrpg          // glob expansion
//
// Files are parsed independently, then spans are rebased into a
// single unified offset space (with 1-byte sentinel gaps between
// files). Programs are merged into a single Program and checked
// with module-aware visibility.
//
// --- Global name uniqueness (v0) ---
//
// In v0, no two loaded systems may define the same declaration
// name in the same namespace. This is enforced at module resolution
// time (before the checker runs).
//
// Namespaces checked:
//   - Types (enums, structs, entities)
//   - Functions (derives, mechanics, actions, reactions, hooks, prompts)
//   - Conditions
//   - Events
//   - Options
//   - Enum variants (two enums with overlapping variant names collide)
//
// Same name in different namespaces is fine (e.g., type Foo and
// function Foo coexist).
//
// --- System merging ---
//
// Multiple blocks with the same system name are merged additively:
//
//   // file: core_types.ttrpg
//   system "Core" { entity Character { HP: int } }
//
//   // file: core_functions.ttrpg
//   system "Core" { derive modifier(score: int) -> int { (score - 10) / 2 } }
//
// After loading both files, system "Core" contains both Character
// and modifier(). Duplicate declarations within a merged system
// are an error.
//
// --- Import semantics ---
//
// `use` is a top-level declaration, not inside a system block.
// All `use` declarations in a file apply to all system blocks
// in that same file.
//
// Imports are NOT transitive: if A uses B and B uses C, A cannot
// see C's declarations without an explicit `use "C"`.

// file: dnd5e/core.ttrpg
system "D&D 5e Core" {
    // Ability, modifier(), proficiency_bonus(), ...
}

// file: dnd5e/combat.ttrpg
use "D&D 5e Core"

system "D&D 5e Combat" {
    // Can reference Ability, modifier(), etc. from Core
}

// --- Qualified access via aliases ---
//
// The `as` clause creates an alias for disambiguation:
//
//   use "D&D 5e Core" as Core
//
// Qualified type position (desugared before checking):
//   entity Foo { ability: Core.Ability }
//   // TypeExpr::Qualified { qualifier: "Core", name: "Ability" }
//   // desugared to TypeExpr::Named("Ability") after validation
//
// Qualified expression position:
//   Core.Ability       → Ty::EnumType (namespace access)
//   Core.Ability.STR   → enum variant through alias
//   Core.modifier(10)  → function call through alias
//   Core.Prone         → condition reference through alias
//
// Alias rules:
//   - Same alias for same target in different files: idempotent (ok)
//   - Same alias for different targets: error
//   - Alias collides with own declaration name: error
//   - Alias collides with builtin function name: error

// file: homebrew/flanking.ttrpg
use "D&D 5e Combat"

option flanking extends "D&D 5e Combat" {
    description: "Melee attackers on opposite sides gain advantage"
    default: off
    when enabled {
        modify attack_roll(attacker: _, target: _) {
            if flanking_position(attacker, target) {
                mode = advantage
            }
        }
    }
}
