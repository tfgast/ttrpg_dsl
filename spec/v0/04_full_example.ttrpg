// ============================================================
// v0 Spec — Part 4: Full Worked Example
//
// Parseable by the grammar in 03_canonical_grammar.ttrpg.
// Every type annotated. Every scope declared. Every field
// traced to its source. No undefined references.
//
// This file is self-contained — all types and functions are
// defined locally. A real project would split these across
// modules (see 02_scoping.ttrpg for the import model).
// ============================================================

system "D&D 5e Combat" {

    // --- Enums ---

    enum Ability { STR, DEX, CON, INT, WIS, CHA }
    enum RollMode { normal, advantage, disadvantage, auto_fail, auto_succeed }

    enum DamageType {
        slashing, piercing, bludgeoning,
        fire, cold, lightning, thunder, poison,
        acid, necrotic, radiant, psychic, force
    }

    enum WeaponProperty { light, heavy, finesse, thrown, versatile, reach }

    enum Duration {
        end_of_turn,
        start_of_next_turn,
        rounds(count: int),
        minutes(count: int),
        indefinite
    }

    enum SaveResult { success, failure }

    enum ResolvedDamage {
        miss,
        hit(amount: int)
    }


    // --- Structs ---

    struct DamageSpec {
        dice: DiceExpr
        type: DamageType
    }

    struct TurnBudget {
        actions: int = 0
        bonus_actions: int = 0
        reactions: int = 0
        movement: int = 0
        free_interactions: int = 0
    }


    // --- Entities ---

    entity Weapon {
        name: string
        damage: DamageSpec
        ability: Ability
        properties: set<WeaponProperty>
        range: int
        long_range: option<int>
    }

    entity Character {
        name: string
        level: int = 1
        abilities: map<Ability, int>
        proficient_saves: set<Ability>
        AC: int
        HP: resource(0..=max_HP)
        max_HP: int
        speed: int = 30
        resistances: set<DamageType>
        immunities: set<DamageType>
        vulnerabilities: set<DamageType>
        conditions: set<Condition>
        position: Position
        equipped_weapon: Weapon
        concentrating_on: option<Invocation>
    }


    // --- Derives (pure, no dice, no mutation) ---

    derive modifier(score: int) -> int {
        floor((score - 10) / 2)
    }

    derive proficiency_bonus(level: int) -> int {
        floor((level - 1) / 4) + 2
    }

    derive initial_budget(actor: Character) -> TurnBudget {
        TurnBudget {
            actions: 1,
            bonus_actions: 1,
            reactions: 1,
            movement: actor.speed,
            free_interactions: 1
        }
        // With defaults, a partial literal also works:
        //   TurnBudget { actions: 1, movement: actor.speed }
        // Omitted fields use their declared defaults (0).
    }

    derive apply_resistances(
        target: Character,
        raw_damage: int,
        damage_type: DamageType
    ) -> int {
        match {
            damage_type in target.immunities      => 0,
            damage_type in target.resistances     => floor(raw_damage / 2),
            damage_type in target.vulnerabilities => raw_damage * 2,
            _ => raw_damage
        }
    }


    // --- Mechanics (can roll, no mutation) ---

    mechanic choose_attack_ability(
        attacker: Character,
        weapon: Weapon
    ) -> Ability {
        if finesse in weapon.properties {
            let str_mod = modifier(attacker.abilities[STR])
            let dex_mod = modifier(attacker.abilities[DEX])
            if dex_mod > str_mod { DEX } else { weapon.ability }
        } else {
            weapon.ability
        }
    }

    mechanic d20_expr(
        score: int,
        proficiency: int = 0,
        bonus: int = 0,
        mode: RollMode = normal
    ) -> DiceExpr {
        let base: DiceExpr = match mode {
            normal       => 1d20,
            advantage    => 2d20kh1,
            disadvantage => 2d20kl1
        }
        base + modifier(score) + proficiency + bonus
    }

    mechanic attack_roll(
        attacker: Character,
        target: Character,
        weapon: Weapon,
        mode: RollMode = normal,
        bonus_dice: DiceExpr = 0d1
    ) -> RollResult {
        let ability = choose_attack_ability(attacker, weapon)
        let expr = d20_expr(
            score: attacker.abilities[ability],
            proficiency: proficiency_bonus(attacker.level),
            mode: mode
        )
        roll(expr + bonus_dice)
    }

    mechanic saving_throw(
        target: Character,
        ability: Ability,
        DC: int,
        mode: RollMode = normal,
        bonus: int = 0
    ) -> SaveResult {
        match mode {
            auto_fail    => SaveResult.failure,
            auto_succeed => SaveResult.success,
            _ => {
                let prof = if ability in target.proficient_saves {
                    proficiency_bonus(target.level)
                } else {
                    0
                }
                let expr = d20_expr(
                    score: target.abilities[ability],
                    proficiency: prof,
                    bonus: bonus,
                    mode: mode
                )
                let save: RollResult = roll(expr)
                if save.total >= DC { SaveResult.success } else { SaveResult.failure }
            }
        }
    }

    mechanic damage_expr(
        attacker: Character,
        weapon: Weapon,
        critical: bool = false
    ) -> DiceExpr {
        let ability = choose_attack_ability(attacker, weapon)
        let dice: DiceExpr = if critical {
            multiply_dice(weapon.damage.dice, 2)
        } else {
            weapon.damage.dice
        }
        dice + modifier(attacker.abilities[ability])
    }

    // Shared attack resolution logic. Returns a value (ResolvedDamage)
    // but does NOT mutate state — the calling action applies the result.
    mechanic resolve_melee_attack(
        attacker: Character,
        target: Character,
        weapon: Weapon,
        mode: RollMode = normal
    ) -> ResolvedDamage {
        let atk: RollResult = attack_roll(attacker, target, weapon, mode)
        match {
            atk.unmodified == 1 => ResolvedDamage.miss,
            atk.unmodified == 20 => {
                let dmg: RollResult = roll(damage_expr(attacker, weapon, critical: true))
                let final_dmg = apply_resistances(target, dmg.total, weapon.damage.type)
                ResolvedDamage.hit(final_dmg)
            },
            atk >= target.AC => {
                let dmg: RollResult = roll(damage_expr(attacker, weapon, critical: false))
                let final_dmg = apply_resistances(target, dmg.total, weapon.damage.type)
                ResolvedDamage.hit(final_dmg)
            },
            _ => ResolvedDamage.miss
        }
    }

    // Initiative roll for a single character.
    // Sorting combatants by result is a runtime/VTT responsibility —
    // the DSL provides the per-character roll, not list operations.
    mechanic initiative_roll(combatant: Character) -> RollResult {
        let expr = d20_expr(score: combatant.abilities[DEX], proficiency: 0)
        roll(expr)
    }


    // --- Prompts (human decision points) ---

    prompt choose(chooser: Character, options: list<string>) -> string {
        hint: "The player or GM selects one option from the list"
    }

    prompt gm_decides(context: string) -> string {
        hint: "The GM determines the outcome based on the fiction"
    }


    // --- Actions (can roll AND mutate, have receiver) ---

    action Attack on attacker: Character (target: Character, weapon: Weapon) {
        cost { action }
        requires { distance(attacker.position, target.position) <= weapon.range }

        resolve {
            let result = resolve_melee_attack(attacker, target, weapon)
            match result {
                hit(amount) => {
                    target.HP -= amount
                    // Fire the Damaged event — matching hooks execute inline
                    emit Damaged(target: target, attacker: attacker, amount: amount)
                },
                miss => {}
            }
        }
    }

    // AoE damage — iterates over a list of targets
    action BurningHands on caster: Character (targets: list<Character>) {
        cost { action }

        resolve {
            let damage: RollResult = roll(3d6)
            for target in targets {
                let save: RollResult = roll(d20_expr(score: target.abilities[DEX]))
                if save.total >= 13 {
                    target.HP -= floor(damage.total / 2)
                } else {
                    target.HP -= damage.total
                }
            }
        }
    }

    // Extra Attack — range-based iteration for multiple attacks
    action ExtraAttack on attacker: Character (
        target: Character,
        weapon: Weapon,
        num_attacks: int
    ) {
        cost { action }
        requires { distance(attacker.position, target.position) <= weapon.range }

        resolve {
            for i in 0..num_attacks {
                let result = resolve_melee_attack(attacker, target, weapon)
                match result {
                    hit(amount) => { target.HP -= amount },
                    miss => {}
                }
            }
        }
    }

    action Dash on actor: Character () {
        cost { action }

        resolve {
            turn.movement += actor.speed
        }
    }

    action Dodge on actor: Character () {
        cost { action }

        resolve {
            apply_condition(actor, Dodging, Duration.start_of_next_turn)
        }
    }

    action Disengage on actor: Character () {
        cost { action }

        resolve {
            apply_condition(actor, Disengaging, Duration.end_of_turn)
        }
    }

    action Hide on actor: Character () {
        cost { action }

        resolve {
            apply_condition(actor, Hidden, Duration.indefinite)
        }
    }

    // --- Free actions (cost free) ---
    //
    // `cost free` explicitly declares that an action costs nothing.
    // This is distinct from omitting cost — it signals intentional no-cost.

    action Perceive on actor: Character (target: Character) {
        cost free

        resolve {
            // A free action to observe a target — no turn resources consumed
            let dc = 10 + modifier(target.abilities[DEX])
            let check: RollResult = roll(d20_expr(score: actor.abilities[WIS]))
            if check.total >= dc {
                remove_condition(target, Hidden)
            }
        }
    }


    // --- Events (trigger event shapes) ---
    //
    // Events declare the shape of things that happen during play.
    // Reactions listen for them. Conditions can suppress them.

    event entity_leaves_reach(reactor: Character) {
        entity: Character       // the entity that is leaving
        from_position: Position
        to_position: Position
    }

    // Damage event — emitted by actions that deal damage.
    // Hooks can listen for this to implement concentration checks,
    // death triggers, damage logging, etc.
    event Damaged(target: Character, attacker: Character, amount: int) {}


    // --- Reactions (can roll AND mutate, trigger-driven) ---

    reaction OpportunityAttack on reactor: Character (
        trigger: entity_leaves_reach(reactor: reactor)
    ) {
        cost { reaction }

        resolve {
            // Calls the shared mechanic — no cost/requires bypass
            let result = resolve_melee_attack(
                reactor, trigger.entity, reactor.equipped_weapon
            )
            match result {
                hit(amount) => { trigger.entity.HP -= amount },
                miss => {}
            }
        }
    }


    // --- Hooks (mandatory triggered actions, no cost) ---
    //
    // Hooks fire automatically when their trigger event matches.
    // Unlike reactions, they have no cost and cannot be suppressed.

    // Turn phase events — declared by the game system, fired by the host.
    // These are not built-in; the game designer defines them like any event.
    event turn_start(actor: Character) {}
    event turn_end(actor: Character) {}

    // Death save at start of turn: mandatory when at 0 HP
    hook DeathSaveCheck on actor: Character (
        trigger: turn_start(actor: actor)
    ) {
        if actor.HP == 0 {
            let save: RollResult = roll(1d20)
            match {
                save.unmodified == 20 => { actor.HP += 1 },
                save.unmodified == 1 => {
                    // Critical fail on death save — game-specific handling
                },
                save.total >= 10 => {
                    // Success — tracking save counts is left to the host
                },
                _ => {
                    // Failure
                }
            }
        }
    }


    // Damage hook — auto-fires when Damaged is emitted.
    // Checks if the target has dropped to 0 HP and applies Prone if so.
    hook DeathDrop on target: Character (trigger: Damaged(target: target)) {
        if target.HP <= 0 {
            apply_condition(target, Prone, Duration.indefinite)
        }
    }


    // --- Conditions (declarative modifiers, no mutation) ---

    condition Prone on bearer: Character {
        modify attack_roll(attacker: bearer) {
            mode = disadvantage
        }
        modify attack_roll(target: bearer) {
            mode = if distance(attacker.position, bearer.position) <= 5 {
                advantage
            } else {
                disadvantage
            }
        }
        modify initial_budget(actor: bearer) {
            result.movement = result.movement - floor(bearer.speed / 2)
        }
    }

    condition Dodging on bearer: Character {
        modify attack_roll(target: bearer) {
            mode = disadvantage
        }
        modify saving_throw(target: bearer, ability: DEX) {
            mode = advantage
        }
    }

    condition Disengaging on bearer: Character {
        // Suppresses opportunity attacks against bearer.
        // The runtime checks: if target has Disengaging, skip the
        // entity_leaves_reach trigger. This is a built-in interaction
        // between conditions and triggers, not custom logic.
        suppress entity_leaves_reach(entity: bearer)
    }

    condition Hidden on bearer: Character {
        // Hidden grants advantage on attack rolls made by the bearer
        modify attack_roll(attacker: bearer) {
            mode = advantage
        }
    }

    // Stunned: auto-fail STR/DEX saves via RollMode.auto_fail.
    // The saving_throw mechanic checks for auto modes before rolling,
    // so no dice are rolled at all.
    condition Stunned on bearer: Character {
        modify attack_roll(target: bearer) {
            mode = advantage
        }
        modify saving_throw(target: bearer, ability: STR) {
            mode = auto_fail
        }
        modify saving_throw(target: bearer, ability: DEX) {
            mode = auto_fail
        }
    }

    // Petrified: auto-fail STR/DEX saves via whole-result override.
    // The mechanic body runs normally (the roll happens), but the
    // result is replaced in Phase 2.
    condition Petrified on bearer: Character {
        modify attack_roll(target: bearer) {
            mode = advantage
        }
        modify saving_throw(target: bearer, ability: STR) {
            result = SaveResult.failure
        }
        modify saving_throw(target: bearer, ability: DEX) {
            result = SaveResult.failure
        }
    }


    // --- Cost modification (modify Action.cost) ---
    //
    // Conditions can override an action's cost using `.cost` modify
    // clauses. This avoids duplicating entire action definitions just
    // to change their cost.

    // Rogue's Cunning Action: Dash, Disengage, Hide as bonus action
    condition CunningAction on bearer: Character {
        modify Dash.cost(actor: bearer) {
            cost = bonus_action
        }
        modify Disengage.cost(actor: bearer) {
            cost = bonus_action
        }
        modify Hide.cost(actor: bearer) {
            cost = bonus_action
        }
    }


    // --- Invocation tracking (concentration) ---
    //
    // Tags, events, and hooks combine with `invocation()` and `revoke()`
    // to implement D&D 5e concentration entirely in the DSL.

    tag #concentration

    event ConcentrationStarted(caster: Character, inv: Invocation)

    // A concentration spell: apply conditions, then register concentration.
    // Conditions are applied BEFORE the concentration event — if application
    // fails, the event is never emitted and old concentration is preserved.
    action CastBless on caster: Character (targets: list<Character>) #concentration {
        cost { action }

        resolve {
            let inv = invocation()
            for target in targets {
                apply_condition(target, Blessed, Duration.rounds(10))
            }
            emit ConcentrationStarted(caster: caster, inv: inv)
        }
    }

    // When any concentration spell starts, clean up the previous one.
    // The action passes its invocation through the event because the hook
    // has its own invocation scope — each hook gets its own invocation ID.
    hook on_conc on caster: Character (
        trigger: ConcentrationStarted(caster: caster)
    ) {
        revoke(caster.concentrating_on)
        caster.concentrating_on = some(trigger.inv)
    }

    // Concentration save on damage (5e-specific rule)
    reaction ConcentrationSave on caster: Character (
        trigger: Damaged(target: caster)
    ) {
        cost free

        resolve {
            if caster.concentrating_on != none {
                let dc = max(10, floor(trigger.amount / 2))
                let save: RollResult = roll(d20_expr(
                    score: caster.abilities[CON]
                ))
                if save.total < dc {
                    revoke(caster.concentrating_on)
                    caster.concentrating_on = none
                }
            }
        }
    }

    condition Blessed on bearer: Character {
        modify attack_roll(attacker: bearer) {
            bonus_dice = 1d4
        }
    }
}
