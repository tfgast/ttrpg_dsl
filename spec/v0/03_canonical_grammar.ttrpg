// ============================================================
// v0 Spec — Part 3: Canonical Grammar
//
// Complete EBNF. Every nonterminal defined. The full example
// in 04_full_example.ttrpg is parseable by this grammar.
// ============================================================

// Notation:
//   X*             zero or more X
//   X+             one or more X
//   X?             optional X
//   X ("," X)*     comma-separated list (one or more)
//   "keyword"      literal keyword or punctuation
//   IDENT          [a-zA-Z_][a-zA-Z0-9_]*
//   INT            [0-9]+
//   STRING         double-quoted string literal (with standard escapes)
//   NL             newline
//   EOF            end of input
//   COMMENT        "//" to end of line (lexer discards, not in grammar)
//   &X             lookahead: succeeds when X is next, does NOT consume
//                  (PEG syntactic predicate; see implementation note below)
//
// --- Lexer: comments ---
//
// Line comments: // to end of line. Discarded by the lexer.
// Block comments: not supported in v0.
//
// --- Lexer: newline handling ---
//
// NL is a real token. The lexer suppresses it in these contexts:
//
//   1. Inside ( ) and [ ]: all NL tokens are discarded.
//   2. After binary/assignment operators and arrows:
//      +  -  *  /  ||  &&  ==  !=  >=  <=  in  =>  ->  =  +=  -=
//      NL is suppressed (line continuation).
//
//      Note: bare `>` and `<` are deliberately excluded. They are
//      ambiguous with generic type brackets (`set<T>`, `map<K,V>`).
//      Suppressing NL after `>` would merge a field like
//      `properties: set<WeaponProperty>` with the next line.
//      The multi-character forms `>=` and `<=` still suppress.
//   3. After {  ,  and  : — NL is suppressed.
//
// That's it — three rules, all suppression, no insertion.
// The lexer never injects tokens.
//
// --- Lexer: keyword handling ---
//
// Keywords fall into two categories:
//
//   Reserved (always keyword tokens, never IDENT):
//     let  if  else  match  true  false  none  in  for
//
//   Contextual / soft (lexed as IDENT, recognized by parser in position):
//     system  use  group  enum  struct  entity  derive  mechanic  action
//     reaction  hook  condition  prompt  option  event  move  cost  tag
//     requires  resolve  modify  suppress  trigger  roll  on
//     when  enabled  hint  suggest  description  default  result
//     with  has  include  as  grant  revoke  emit  free  ordered
//
// Soft keywords CAN be used as field names, variable names, and
// enum variants. The parser distinguishes based on position:
//   `action Attack on ...`   — `action` starts a declaration
//   `cost { action }`        — `action` is an IDENT (cost token)
//   `actor.action`           — `action` is an IDENT (field access)
//
// This avoids reserving common TTRPG terms. An implementation may
// choose to reserve all keywords (simpler lexer, fewer field names
// available) — the grammar is compatible with either approach.
//
// --- Parser: the `term` production ---
//
// Statements, field definitions, and clause-level productions are
// terminated by `term`, defined as:
//
//   term = NL | &"}" | EOF
//
// `&"}"` is a lookahead (PEG syntactic predicate): it succeeds when
// the next token is `}` but does NOT consume it. This means:
//
//   - In multi-line blocks, each stmt/field ends with a real NL.
//   - The LAST stmt/field before `}` can omit NL because `&"}"` matches.
//   - Empty blocks `{}` work: stmt* matches zero times, then `}`.
//   - One-line blocks `{ DEX }` work: DEX has no NL, but `&"}"` matches.
//   - Non-block braces `cost { action }` work: the `}` is consumed
//     by the enclosing cost_clause production, not by term.
//
// EOF handles top-level declarations (like `use`) at end of file
// without requiring a trailing newline.
//
// In the grammar below, `term` replaces all previous uses of `NL`
// as a statement/field terminator.
//
// --- Implementation note: lookahead ---
//
// `&X` is a PEG syntactic predicate (zero-width assertion). It does
// not exist in standard EBNF or in most LR grammar formalisms.
// Implementation strategies by parser family:
//
//   PEG / packrat / recursive descent:
//     Native support. `&"}"` is just peek-at-next-token.
//
//   ANTLR (LL):
//     Use a semantic predicate: `{getCurrentToken().getType() == RBRACE}?`
//     Or rewrite `term` as an inline check at each use site.
//
//   LALR / LR (yacc, bison):
//     Eliminate `term` entirely. Use the standard trick: make NL
//     optional before `}` by having `}` reduce any open statement.
//     Concretely: define `opt_term = NL | /* empty */` and use it
//     only for the last item in a block. Or, emit a synthetic NL
//     before every `}` in the lexer (simpler but less precise).
//
// The grammar uses `&X` for spec clarity. An implementation may
// inline the equivalent logic at the parser or lexer level.


// =========================
// 1. Program structure
// =========================

program         = top_level* EOF
top_level       = use_decl | system_block
use_decl        = "use" STRING term
system_block    = "system" STRING "{" decl* "}"


// =========================
// 2. Declarations
// =========================

decl            = enum_decl
                | group_decl
                | struct_decl
                | entity_decl
                | derive_decl
                | mechanic_decl
                | action_decl
                | reaction_decl
                | hook_decl
                | condition_decl
                | prompt_decl
                | option_decl
                | event_decl
                | tag_decl
                | move_decl          // PbtA sugar (desugars to mechanic + action)

// --- Tag declaration ---
tag_decl        = "tag" "#" IDENT term

// Tags are metadata labels attached to derives, mechanics, and actions.
// A tag must be declared before it can be used on a declaration.
// See 02_scoping.ttrpg for usage details.

// --- Enum ---
enum_decl       = "enum" IDENT "{" enum_variants "}"
enum_variants   = enum_variant (("," | NL) enum_variant)* ","?
enum_variant    = IDENT                             // no data:  STR, miss
                | IDENT "(" field_list ")"          // with data: hit(amount: int)

// --- Struct ---
struct_decl     = "struct" IDENT "{" field_defs "}"

// --- Group (reusable optional-group schema) ---
group_decl      = "group" IDENT "{" field_defs "}"

// --- Entity ---
entity_decl     = "entity" IDENT "{" entity_members? "}"

entity_members  = entity_member (("," | NL) entity_member)* ","?
entity_member   = field_def | optional_group_decl | include_group_decl

optional_group_decl = "optional" IDENT ("{" field_defs "}")?
include_group_decl  = "include" IDENT
// Two forms:
//   optional Spellcasting { ... }   inline group schema
//   optional Spellcasting           attach top-level `group Spellcasting`
//   include CombatStats             attach top-level required group

// --- Field definitions ---
field_list      = field_entry ("," field_entry)* ","?
field_entry     = IDENT ":" type

field_defs      = (field_def (("," | NL) field_def)* ","?)?
field_def       = IDENT ":" type ("=" expr)?

// --- Derive (pure, no dice, no mutation, no receiver) ---
derive_decl     = "derive" IDENT "(" params ")" "->" type tag_list? block

// --- Mechanic (can roll, no mutation, no receiver) ---
mechanic_decl   = "mechanic" IDENT "(" params ")" "->" type tag_list? block

// --- Action (can roll, can mutate, has receiver) ---
action_decl     = "action" IDENT "on" IDENT ":" constrained_type
                      "(" params ")" tag_list? "{"
                      cost_clause?
                      requires_clause*
                      resolve_block
                  "}"

tag_list        = ("#" IDENT)+
// Tags appear after the closing ")" of the parameter list and before "{".
// Each tag must have been declared via `tag #name`. Same syntax as on
// derive_decl and mechanic_decl (which already support tags via fn_body).

cost_clause     = "cost" "free" term                  // explicit no-cost
                | "cost" "{" cost_entry ("," cost_entry)* "}" term
cost_entry      = IDENT                              // a cost token (see mapping below)
requires_clause = "requires" "{" expr "}" term       // multiple blocks are combined with &&
resolve_block   = "resolve" block

// --- Cost token → budget field mapping ---
//
// Cost tokens are singular names used in cost clauses. The runtime
// maps each token to a TurnBudget field and decrements it by 1:
//
//   Cost token       Budget field         Effect
//   ----------       ------------         ------
//   action           turn.actions         turn.actions -= 1
//   bonus_action     turn.bonus_actions   turn.bonus_actions -= 1
//   reaction         turn.reactions       turn.reactions -= 1
//
// The singular token is the DSL-facing name (matches D&D terminology:
// "costs an action"). The plural field is the counter in TurnBudget
// ("you have 1 actions remaining").
//
// --- `cost free` ---
//
// An action or reaction may explicitly declare `cost free` to signal
// that it intentionally consumes no resources. This is distinct from
// OMITTING the cost clause entirely: omission is ambiguous (forgot to
// declare? intentionally free?), while `cost free` is a clear signal.
//
//   action Cantrip on caster: Character () {
//       cost free
//       resolve { ... }
//   }
//
// When `cost free` is declared, no DeductCost effects are emitted
// at runtime. Cost modifiers (modify Action.cost) can still apply
// to change a free action's cost, or make a costed action free.
//
// STATIC CHECK: The compiler validates cost tokens during semantic
// analysis (not during parsing). The grammar accepts any IDENT in
// cost_entry, but the compiler rejects tokens not in the mapping
// table above. This is a static semantic error, reported as:
//
//   error: unknown cost token `foo`
//     --> file.ttrpg:12:14
//     | cost { foo }
//     |        ^^^ expected one of: action, bonus_action, reaction
//
// User-defined cost tokens are not supported in v0. A future version
// may allow systems to extend the cost vocabulary.

// --- Reaction (can roll, can mutate, has receiver + trigger) ---
reaction_decl   = "reaction" IDENT "on" IDENT ":" constrained_type
                      "(" "trigger" ":" trigger_expr ")" "{"
                      cost_clause?
                      resolve_block
                  "}"

trigger_expr    = IDENT "(" trigger_bindings ")"
trigger_bindings = trigger_binding ("," trigger_binding)* ","?
trigger_binding  = IDENT ":" expr                   // e.g., reactor: reactor
                 | IDENT                             // positional

// --- Hook (mandatory triggered action, no cost, not suppressible) ---
hook_decl       = "hook" IDENT "on" IDENT ":" constrained_type
                      "(" "trigger" ":" trigger_expr ")" "{"
                      resolve_block
                  "}"

// Hooks share the trigger_expr syntax with reactions.
// Unlike reactions, hooks have NO cost clause and cannot be
// suppressed by conditions. When the trigger event fires and
// the trigger bindings match, the hook always executes.

// --- Event (declares the shape of a trigger event) ---
event_decl      = "event" IDENT "(" params ")" "{" field_def* "}"

// --- Condition (declarative modifiers, has receiver, no mutation) ---
condition_decl  = "condition" IDENT params? extends_clause?
                      "on" IDENT ":" constrained_type "{" condition_clause* "}"
extends_clause  = "extends" IDENT ("," IDENT)*

condition_clause = modify_clause | suppress_clause

modify_clause   = "modify" mechanic_ref "(" modify_bindings ")" modify_body
                | "modify" IDENT "." "cost" "(" modify_bindings ")" cost_modify_body
mechanic_ref    = IDENT                             // name of target mechanic/derive
modify_bindings = modify_binding ("," modify_binding)* ","?
modify_binding  = IDENT ":" expr                    // e.g., attacker: bearer
modify_body     = "{" modify_stmt* "}"
modify_stmt     = "let" IDENT (":" type)? "=" expr term   // local binding (either phase)
                | IDENT "=" expr term                // Phase 1: override input parameter
                | "result" "." IDENT "=" expr term   // Phase 2: rewrite output field
                | "if" expr modify_body
                      ("else" modify_body)? term     // conditional (either phase)

// Phase 1 stmts (IDENT = expr) execute before the target function.
// Phase 2 stmts (result.IDENT = expr) execute after.
// A single modify body can contain both phases; the runtime
// partitions them. `if` blocks can contain either kind.

// --- Cost modification ---
//
// The second form of modify_clause targets an action or reaction's
// cost instead of its parameters/result. The `.cost` suffix after
// the action name selects this mode:
//
//   modify Dash.cost(actor: bearer) { cost = bonus_action }
//
// The target name must refer to an action or reaction (not a derive
// or mechanic — those have no cost). Bindings work the same way:
// the receiver and declared parameters are bindable.
//
// Cost modify bodies use a restricted statement set — only `cost =`
// assignments, `let` bindings, and `if`/`else` are allowed. Parameter
// overrides (`param = expr`) and result rewrites (`result.field = expr`)
// are rejected with a diagnostic.
//
// `cost = free` waives the action's cost entirely.
// `cost = token1, token2` replaces the cost with the given tokens.
//
// Multiple cost modifiers follow the same conflict resolution as
// parameter modifiers: applied in condition-gained order, last writer
// wins (see 02_scoping.ttrpg "Modify conflict resolution").

cost_modify_body = "{" cost_modify_stmt* "}"
cost_modify_stmt = "cost" "=" "free" term                              // waive cost
                 | "cost" "=" cost_entry ("," cost_entry)* term        // replace cost tokens
                 | "let" IDENT (":" type)? "=" expr term               // local binding
                 | "if" expr cost_modify_body
                       ("else" cost_modify_body)? term                 // conditional

suppress_clause = "suppress" IDENT "(" modify_bindings ")" term
// Declares that this condition prevents the named trigger event
// from firing when bindings match. e.g.:
//   suppress entity_leaves_reach(entity: bearer)
// means "while this condition is active, entity_leaves_reach
// does not fire when target == bearer"

// --- Prompt (human decision point) ---
prompt_decl     = "prompt" IDENT "(" params ")" "->" type "{"
                      hint_clause?
                      suggest_clause?
                  "}"

hint_clause     = "hint" ":" STRING term
suggest_clause  = "suggest" ":" expr term

// Prompts are DECLARED as above but INVOKED like function calls:
//   let choice = choose(target, options: ["Comply", "Suffer"])
// The call syntax is the same as any function call (see expr grammar).
// The runtime suspends execution and waits for human input.

// --- Option (variant/homebrew rules) ---
option_decl     = "option" IDENT ("extends" STRING)? "{"
                      option_body
                  "}"

option_body     = description_clause?
                  default_clause?
                  when_clause?

description_clause = "description" ":" STRING term
default_clause     = "default" ":" ("on" | "off") term
when_clause        = "when" "enabled" "{" modify_clause* "}"


// =========================
// 3. Parameters
// =========================

params          = (param ("," param)* ","?)?
param           = IDENT ":" constrained_type ("=" expr)?
constrained_type = type with_clause?
with_clause     = "with" group_constraint ("," group_constraint)*   // conjunctive (AND)
                | "with" group_constraint ("|" group_constraint)*   // disjunctive (OR)
group_constraint = IDENT ("as" IDENT)?

// --- Conjunctive `with` (AND) ---
//
// Comma-separated groups require ALL groups to be present. The function
// body can access group fields directly (the checker narrows scope).
// Call sites must prove the entity has all listed groups.
//
// Example:
//   target: Character with Spellcasting
//   x: entity with Spellcasting
//   caster: Character with Spellcasting as sc
//   caster: Character with Spellcasting as sc, KiPowers as kp
//
// --- Disjunctive `with` (OR) ---
//
// Pipe-separated groups require AT LEAST ONE group to be present.
// The function body CANNOT access group fields directly — the author
// must use `has` guards to narrow to a specific group before accessing
// its fields. Call sites do NOT require proof of any specific group.
//
// Example:
//   combatant: Combatant with MeleeCapable | MissileCapable
//
// In the body, use `has` to narrow:
//   if combatant has MeleeCapable as m {
//       combatant.m.str_mod   // ok — narrowed by `has` guard
//   }
//
// --- Mixing is an error ---
//
// A with clause must be purely conjunctive (commas) or purely
// disjunctive (pipes). Mixing separators is a parse error:
//   with A, B | C   // ERROR: cannot mix `,` and `|`
//
// --- Aliases ---
//
// The optional `as` clause creates a locally-scoped alias for the group
// name. Inside the function body, the alias can be used in place of the
// full group name in field access paths:
//   caster.sc.spell_slots    is equivalent to    caster.Spellcasting.spell_slots
//
// Aliases work with both conjunctive and disjunctive constraints.
// For disjunctive constraints, the alias is only usable inside a `has`
// guard that narrows to that group.
//
// Alias scope: the alias is visible only within the function/action body
// where the `with` constraint appears. It does not escape to callers.
//
// Alias shadowing: an alias must not shadow an existing field or group
// name on the same entity type. The compiler reports an error if it does.


// =========================
// 4. Types
// =========================

type            = "int" | "bool" | "string" | "float"
                | "DiceExpr" | "RollResult"
                | "TurnBudget" | "Duration" | "Position"
                | "Condition" | "ActiveCondition" | "Invocation"
                | "entity"                           // polymorphic any-entity type alias
                | IDENT                              // user-defined type
                | "map" "<" type "," type ">"
                | "list" "<" type ">"
                | "set" "<" type ">"
                | "option" "<" type ">"
                | "resource" "(" expr "..=" expr ")"

// `entity` is a checker-resolved alias for "any entity type" (Ty::AnyEntity).
// It is useful for polymorphic parameters/receivers and can be combined with
// with-constraints to require optional groups.


// =========================
// 5. Statements and blocks
// =========================

term            = NL | &"}" | EOF
// `term` terminates statements and clauses.
// NL is a real newline. &"}" is a lookahead that succeeds when
// the next token is "}" but does NOT consume it. EOF handles
// top-level productions (use_decl, the last decl in a system
// block) at end of input without a trailing newline.

block           = "{" stmt* "}"

// --- Block value semantics ---
//
// A block's value is determined SEMANTICALLY from its last stmt:
//
//   - If the last stmt is an expr_stmt: the block's value is that
//     expression's value.
//   - If the last stmt is let_stmt or assign_stmt: block value is unit.
//   - If the block is empty: block value is unit.
//
// All control flow (if, match) is expression-level (see section 6).
// When `if` or `match` appears as the last thing in a block, it
// is an expr_stmt and the block value is the expression's value.
// There is no ambiguity: there is only ONE stmt kind that can
// contain an expression, and that is expr_stmt.
//
// Examples:
//   { let x = 5             => let_stmt
//     x + 1                 => expr_stmt → block value = x + 1
//   }
//
//   { target.HP -= amount   => assign_stmt → block value = unit
//   }
//
//   { floor((score - 10) / 2)   => expr_stmt → block value = result
//   }
//
//   { DEX }                 => expr_stmt (term matches &"}")
//                              block value = DEX
//
//   { match { ... } }       => expr_stmt (match_expr) → block value = match result
//
// Type checking (semantic analysis, not parsing):
//   - derive/mechanic: block type must match declared return type.
//   - action/reaction resolve: block value is discarded (no constraint).

stmt            = let_stmt | assign_stmt | grant_stmt | revoke_stmt
                | emit_stmt | expr_stmt

let_stmt        = "let" IDENT (":" type)? "=" expr term
assign_stmt     = lvalue assign_op expr term
assign_op       = "=" | "+=" | "-="
lvalue          = IDENT ("." IDENT | "[" expr "]")*
expr_stmt       = expr term

// --- Grant and revoke (optional group management) ---
//
// `grant` activates an optional group on an entity with initial field values.
// `revoke` deactivates an optional group, discarding its field values.
// Both are only allowed in action, reaction, or hook resolve blocks.
//
//   grant wizard.Spellcasting { spell_slots: 3, spell_dc: 15 }
//   revoke wizard.Spellcasting
//
// DISAMBIGUATION: `revoke` as a statement (group management) vs `revoke()`
// as a function call (invocation revocation) are distinguished by lookahead.
// When the parser sees `revoke` followed by `(`, it falls through to
// expression statement parsing (function call). When followed by an lvalue,
// it enters the revoke_stmt path. No ambiguity.
//
grant_stmt      = "grant" lvalue "{" struct_body? "}" term
revoke_stmt     = "revoke" lvalue term
// Parser disambiguates: if the token after "revoke" is "(", fall through
// to expr_stmt (function call). Otherwise, parse as revoke_stmt.

// --- Emit (fire an event, auto-execute matching hooks) ---
//
// `emit` fires a named event with the given arguments. All matching
// hooks execute inline before the emit statement returns. Reactions
// are NOT auto-fired — they remain host-driven.
//
// All arguments must be named (matches event parameter names).
// Parameters with defaults can be omitted. The emit statement
// returns unit (fire-and-forget).
//
// Only allowed in action resolve blocks. (Future: may be relaxed
// to hook and reaction resolve blocks with a cascading depth guard.)
//
//   emit Damaged(target: target, amount: damage)
//   emit TurnStarted(actor: actor)
//
emit_stmt       = "emit" IDENT "(" arg_list? ")" term


// =========================
// 6. Expressions
// =========================

// Precedence (low to high):
//   ||
//   &&
//   ==  !=  >=  <=  >  <
//   in
//   +  -
//   *  /
//   unary (! -)
//   postfix (. [] ())

expr            = or_expr
or_expr         = and_expr ("||" and_expr)*
and_expr        = cmp_expr ("&&" cmp_expr)*
cmp_expr        = in_expr (cmp_op in_expr)?
cmp_op          = "==" | "!=" | ">=" | "<=" | ">" | "<"
in_expr         = add_expr ("in" add_expr | "has" IDENT ("as" IDENT)?)?
add_expr        = mul_expr (("+" | "-") mul_expr)*
mul_expr        = unary_expr (("*" | "/") unary_expr)*
unary_expr      = "!" unary_expr
                | "-" unary_expr
                | postfix_expr
postfix_expr    = primary_expr postfix_op*
postfix_op      = "." IDENT                          // field access
                | "[" expr "]"                        // index
                | "(" arg_list? ")"                   // call
primary_expr    = INT | STRING
                | "true" | "false" | "none"
                | dice_lit
                | IDENT
                | struct_lit
                | list_lit
                | map_lit
                | "(" expr ")"
                | if_expr
                | match_expr
                | for_expr

// Method-call chaining is represented by postfix composition:
//   obj.method(args)  parses as:
//     primary_expr `obj`
//     postfix_op   "." IDENT      (field access: `method`)
//     postfix_op   "(" arg_list ")" (call)
//
// Semantic dispatch for this form is type-driven (not grammar-driven):
// enum constructors and module-qualified calls are resolved first;
// otherwise it is treated as a receiver-style method call.
//
// --- Method-call syntax for actions ---
//
// Actions declared with `on receiver: Type` can be invoked using
// method-call syntax on the receiver entity:
//
//   entity.ActionName(remaining_args)
//
// This is syntactic sugar for the function-call form:
//
//   ActionName(entity, remaining_args)
//
// Both forms are equivalent. The method form desugars to the function
// form during type checking — the receiver expression becomes the
// first (implicit) argument in the effective parameter list.
//
// RESOLUTION ORDER for `obj.Name(args)`:
//   1. Enum constructor:  if obj resolves to Ty::EnumType
//   2. Module-qualified:  if obj resolves to Ty::ModuleAlias
//   3. Action dispatch:   if Name matches an action whose receiver
//                         type is compatible with typeof(obj)
//   4. Builtin method:    type-specific methods (len, append, etc.)
//   5. Error:             "type T has no method Name"
//
// Action methods are checked BEFORE builtin methods because:
//   - Builtin method names are lowercase (len, append, first, ...)
//   - Action names are PascalCase by convention (Attack, Dash, ...)
//   - Name collision is unlikely, but actions take priority since
//     they are user-defined and more specific
//
// TYPE CHECKING:
//   - The receiver expression must have an entity type (struct with
//     entity semantics) that matches the action's declared receiver
//     type. Entity subtype/group constraints are checked normally.
//   - Remaining args are checked against the action's params (not
//     including the receiver) — same as the function-call path.
//   - Context restrictions still apply: action method calls are only
//     valid in action, reaction, or hook resolve blocks.
//
// EXAMPLE:
//
//   action Attack on attacker: Character (target: Character, weapon: Weapon) {
//       cost { action }
//       resolve { ... }
//   }
//
//   // In an action/reaction resolve block:
//   let hero = ...   // some Character entity
//   let foe  = ...   // some Character entity
//   let sword = ...  // some Weapon entity
//
//   // These two calls are identical:
//   Attack(hero, foe, sword)
//   hero.Attack(foe, sword)
//
//   // Named arguments work in both forms:
//   Attack(attacker: hero, target: foe, weapon: sword)
//   hero.Attack(target: foe, weapon: sword)
//
// NOTE: This syntax extends naturally to reactions and hooks, which
// also have receivers. However, reactions and hooks are typically
// system-invoked (via triggers), not called directly by user code.
// If direct invocation of reactions/hooks is added in a future
// version, the same method syntax would apply.

// --- Dice literals ---
dice_lit        = INT "d" INT filter?
filter          = ("kh" | "kl" | "dh" | "dl") INT

// Note: dice_lit produces a value of type DiceExpr.
// Operators +, -, * applied to DiceExpr values use dice algebra
// (defined in 01_type_system.ttrpg). No special grammar needed —
// the type checker handles it.

// --- Struct construction ---
struct_lit      = IDENT "{" struct_body? "}"
struct_body     = struct_field ("," struct_field)* ("," ".." expr)? ","?
                | ".." expr ","?
struct_field    = IDENT ":" expr

// --- List literal / list comprehension ---
list_lit            = "[" (list_comprehension | list_elements)? "]"
list_elements       = expr ("," expr)* ","?
list_comprehension  = expr "for" pattern "in" for_source ("if" expr)?

// --- Map literal ---
map_lit             = "{" (map_entry ("," map_entry)* ","?)? "}"
map_entry           = expr ":" expr

// --- If expression ---
//
// `if` is always an expression. Its type depends on structure:
//   - With else:    type is the common type of both branches.
//   - Without else: type is unit. Can appear as expr_stmt but not
//                   in value-returning positions (type checker enforces).
if_expr         = "if" expr block ("else" (block | if_expr))?

// --- Has expression (optional group presence check) ---
//
// `expr has GroupName` tests whether an entity currently has the named
// optional group granted. Returns bool. Commonly used as an `if` guard
// to narrow access to optional group fields:
//
//   if caster has Spellcasting { caster.Spellcasting.spell_dc }
//
// The optional `as` clause creates a locally-scoped alias:
//
//   if caster has Spellcasting as sc {
//       caster.sc.spell_dc      // sc is an alias for Spellcasting
//   }
//
// Alias scope: the alias is visible only within the then-block of the
// `if` expression (NOT in the else-block). It does not escape.
//
// Alias shadowing: same rules as `with` aliases — the alias must not
// shadow an existing field or group name on the entity type.
//
// The `has` operator sits at the same precedence level as `in`.
// Grammar: see `in_expr` above.

// --- Match expressions ---
//
// Two forms: pattern match (with scrutinee) and guard match (without).

// Pattern match: `match expr { pattern => body, ... }`
// Arms are patterns tested against the scrutinee value.
match_expr      = pattern_match | guard_match

pattern_match   = "match" expr "{" pattern_arm (("," | NL) pattern_arm)* ","? "}"
pattern_arm     = pattern "=>" (expr | block)
pattern         = "_"                                             // wildcard
                | INT | STRING | "true" | "false"                 // literal
                | IDENT "." IDENT                                 // qualified variant
                | IDENT "." IDENT "(" (pattern ("," pattern)* ","?)? ")" // qualified destructure
                | IDENT "(" (pattern ("," pattern)* ","?)? ")"         // bare destructure
                | IDENT                                           // binding or bare variant

// --- Pattern IDENT disambiguation (static semantic rule) ---
//
// A bare IDENT in pattern position is ambiguous between:
//   (a) an enum variant (matches that specific value)
//   (b) a variable binding (captures the matched value)
//
// Resolution (checked during semantic analysis, not parsing):
//   - If IDENT matches an enum variant in scope: it is a variant pattern.
//   - Otherwise: it is a binding.
//   - "_" is always a wildcard (matches anything, binds nothing).
//
// To avoid ambiguity, use qualified syntax (always a variant):
//   ResolvedDamage.miss => {}
//   ResolvedDamage.hit(amount) => {}
//
// Bare names work when unambiguous (standard ML/Rust/Swift rule):
//   miss => {}               // variant (if `miss` is in scope)
//   hit(amount) => {}        // variant with binding
//
// Compiler warning if a bare IDENT shadows a variant name.

// Guard match: `match { bool_expr => body, ... }`
// No scrutinee. Each arm is a boolean expression, tested top-to-bottom.
// First truthy arm wins. `_` is always-true (like `else`).
guard_match     = "match" "{" guard_arm (("," | NL) guard_arm)* ","? "}"
guard_arm       = guard "=>" (expr | block)
guard           = "_"                                // always matches (must be last)
                | expr                               // boolean expression

// --- For expression ---
//
// `for` is always an expression. Its type is always unit — for-loops
// exist for side-effectful iteration (dealing damage, applying
// conditions). Supports collection iteration and integer ranges.
//
// Pattern matching reuses the pattern infrastructure from match
// expressions. Non-matching patterns silently skip the iteration
// (built-in filtering without a separate construct).
//
// Two range operators:
//   `..`  produces a half-open range: `0..3` iterates over `0, 1, 2`.
//   `..=` produces an inclusive range: `0..=3` iterates over `0, 1, 2, 3`.
//
// Since `..` and `..=` are not binary expression operators, the
// expression parser naturally stops before them, disambiguating
// range from collection forms without lookahead.
for_expr        = "for" pattern "in" for_source block
for_source      = expr "..=" expr                       // range (inclusive)
                | expr ".." expr                        // range (half-open)
                | expr                                  // collection (list or set)

// --- Call arguments ---
arg_list        = arg ("," arg)* ","?
arg             = (IDENT ":")? expr                   // optional named arg


// =========================
// 7. PbtA move sugar (desugaring)
// =========================
//
// `move` is syntactic sugar that desugars into mechanic + action.
// Parseable as a declaration (included in `decl`), but the compiler
// lowers it to canonical forms before type checking.

move_decl       = "move" IDENT "on" IDENT ":" type
                      "(" params ")" "{"
                      trigger_clause
                      roll_clause
                      outcome_block+
                  "}"

trigger_clause  = "trigger" ":" STRING term
roll_clause     = "roll" ":" expr term
outcome_block   = "on" IDENT block

// The roll clause takes an arbitrary expression that evaluates to
// DiceExpr. The receiver parameter is in scope. Typical usage:
//   roll: 2d6 + actor.stats[Hard]       // PbtA standard
//   roll: 2d10 + actor.stats[Sharp]     // custom dice
//   roll: 1d20 + modifier(actor.abilities[CHA])  // d20-based move
//
// Desugaring rule:
//
//   move GoAggro on actor: Character (target: Character) {
//       trigger: "threaten with force"
//       roll: 2d6 + actor.stats[Hard]
//       on strong_hit { ... }
//       on weak_hit   { ... }
//       on miss       { ... }
//   }
//
// =>
//
//   mechanic go_aggro_roll(actor: Character) -> RollResult {
//       roll(2d6 + actor.stats[Hard])
//   }
//
//   action GoAggro on actor: Character (target: Character) {
//       cost { action }
//       resolve {
//           let result = go_aggro_roll(actor)
//           match {
//               result >= 10 => { /* strong_hit body */ },
//               result >= 7  => { /* weak_hit body */ },
//               _            => { /* miss body */ }
//           }
//       }
//   }
//
// The outcome thresholds (10/7) are the standard PbtA breakpoints
// (strong hit / weak hit / miss). The move sugar assumes this
// three-tier structure. Games with different outcome tiers should
// use mechanic + action directly for full control.
//
// The trigger string is preserved as metadata on the action for
// documentation/UI purposes but has no runtime semantics in v0.
