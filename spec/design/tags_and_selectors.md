# Design: Tags and Signature Selectors for Modify Targets

**Issue:** tdsl-1p69
**Status:** Draft
**Last updated:** 2026-02-27

---

## Problem

Condition `modify` clauses target functions by exact name. A condition like
Prone must enumerate every mechanic it affects:

```
condition Prone on bearer: Character {
    modify attack_roll(attacker: bearer) { mode = disadvantage }
    modify spell_attack(attacker: bearer) { mode = disadvantage }
    // ... every new attack mechanic must be listed here
}
```

When a new attack mechanic is added, existing conditions silently miss it.
There is no way to say "modify all attack-resolution mechanics."

## Goals

- Allow modify clauses to target *classes* of functions, not just individual names
- Provide both an intentional grouping mechanism (tags) and a structural one (signature selectors)
- Preserve existing name-based targeting unchanged
- Ensure the checker catches mismatches at compile time — no silent partial application

## Non-Goals

- Tag contracts (enforcing that tagged functions conform to a signature) — deferred to a future iteration
- OR-composition in selectors — emulate with multiple modify clauses
- Tags on non-modifiable function kinds (actions, reactions, hooks, prompts)

---

## Syntax

### Tag Declaration

A new top-level declaration introducing a tag name:

```
tag attack
tag saving_throw
```

Tags are declared in a `system` block like any other declaration. They participate
in the module system (visibility, imports, duplicate detection).

### Tag Annotation

Tags are applied to `derive` and `mechanic` declarations, placed after the return
type and before the body:

```
mechanic attack_roll(attacker: Character, target: Character, ...) -> AttackResult #attack #ranged {
    ...
}
```

Multiple tags are allowed. Each must reference a declared tag name; an undeclared
tag is a compile error.

Only `derive` and `mechanic` functions may carry tags — these are the only kinds
that modify clauses can target. Tagging an action, reaction, hook, or prompt is
a compile error.

### Selector-Targeted Modify

A modify clause may use a bracketed selector instead of a function name:

```
modify [#attack](attacker: bearer) {
    mode = disadvantage
}
```

The selector is a comma-separated list of predicates inside `[...]`. All
predicates must match (AND semantics). No OR — use separate modify clauses.

### Selector Predicates

| Predicate | Meaning |
|---|---|
| `#tag_name` | Function carries the given tag |
| `returns Type` | Function return type equals `Type` |
| `has param_name: Type` | Function has a parameter with that name and type |
| `has param_name` | Function has a parameter with that name (any type) |

Combined example:

```
modify [#attack, has attacker: Character](attacker: bearer) {
    mode = disadvantage
}
```

Reads: "for every derive/mechanic tagged `#attack` that has an `attacker: Character`
parameter, when `attacker` is the bearer..."

### Selector Grammar

```ebnf
selector       = "[" predicate ("," predicate)* "]"
predicate      = tag_pred | returns_pred | has_pred
tag_pred       = "#" IDENT
returns_pred   = "returns" type_expr
has_pred       = "has" IDENT (":" type_expr)?
```

Within the `[...]` context, `returns` and `has` are recognized as keywords rather
than identifiers. No valid predicate starts with a bare identifier (each starts
with `#`, `returns`, or `has`), so there is no ambiguity with user-defined names
outside selector context.

### Name-Based Targeting (Unchanged)

```
modify attack_roll(attacker: bearer) { mode = disadvantage }
```

This continues to work exactly as it does today.

---

## Semantics

### Selector Resolution

When the checker encounters a selector-targeted modify clause, it resolves the
*match set* M:

1. Iterate all functions registered in the type environment
2. Keep only `Derive` and `Mechanic` kinds
3. **Exclude synthetic functions** (those generated by `lower_moves`). Synthetic
   functions have compiler-generated signatures that may incidentally match
   structural predicates. Use name-based targeting to modify specific lowered
   functions when needed.
4. For each remaining function, test every predicate in the selector:
   - `#tag`: the function's tag set contains the tag
   - `returns T`: the function's resolved return type equals the resolved T
   - `has p: T`: the function has a parameter named `p` with resolved type equal to T
   - `has p`: the function has a parameter named `p` (any type)
5. A function is in M if and only if all predicates pass

**Diagnostic:** The checker emits an informational note listing the resolved match
set for each selector-targeted modify clause (e.g., "selector matches: `attack_roll`,
`spell_attack`"). This can be suppressed with a verbosity flag.

### Universal Validation

The modify clause body is checked against **every** function in M. This is the
key invariant: no partial application, no silent skips.

**Bindings** — for each binding in the modify header (e.g. `attacker: bearer`):
- Every function in M must have a parameter named `attacker`
- That parameter's type must be identical across all functions in M
- If any function lacks the parameter, or types disagree: compile error with
  per-function diagnostics

**Return type rule** — whether return types must agree depends on whether the
body references `result`:
- If the body contains **any** `result` reference (field override, full override,
  or read), all functions in M must have **identical** return types. If types
  disagree, the checker emits a compile error listing the conflicting types and
  which functions produce them.
- If the body does **not** reference `result` at all (parameter-only modifiers),
  return types may differ freely across M.

**Body statements** — validated against the synthetic function built from M (see
Checker Algorithm):
- `ParamOverride(name, value)`: every function in M must have parameter `name`
  with the same type
- `ResultOverride(field, value)`: the common return type (guaranteed identical by
  the return type rule above) must have field `field` with the expected type
- `result = value`: the common return type must be compatible with the value

If M is empty, the checker emits a warning: "selector matches no functions."
This is likely unintentional but not unsound — a library condition may define
selectors that only match in consuming games. Lint configuration may promote this
to an error for stricter builds.

### Runtime Dispatch

At runtime, when a derive or mechanic is called, the modifier pipeline collects
applicable modifiers. For selector-targeted clauses, the checker has already
pre-computed the match set M, stored as a set of function names keyed by the
clause's `ModifyClauseId`. The interpreter checks membership:

```
pseudocode:
for each modify clause on a condition:
    if clause.target is Named(name):
        skip if name != current_fn_name
    if clause.target is Selector:
        lookup precomputed match set by clause.id
        skip if current_fn_name not in match set
    ... proceed with binding checks and phase execution ...
```

`ModifyClauseId` is a stable numeric identifier assigned during `build_index()`,
avoiding dependence on source spans for runtime dispatch. This decouples the
interpreter from source layout.

### Ordering

Selector-targeted modifiers follow the same ordering rules as name-targeted ones:
- Condition modifiers sorted by `gained_at` timestamp
- Declaration order within a condition preserved
- Option modifiers after all condition modifiers, in declaration order

A single condition may mix name-targeted and selector-targeted modify clauses:

```
condition Prone on bearer: Character {
    modify [#attack](attacker: bearer) { mode = disadvantage }
    modify initial_budget(actor: bearer) { result.movement = result.movement - 10 }
}
```

---

## Representation

### AST Layer (`ttrpg_ast`)

**New types:**

```
TagDecl { name: Name }

ModifyClauseId(u32)   -- stable clause identity, assigned during build_index()

ModifyTarget:
    Named(Name)                           -- existing behavior
    Selector(Vec<SelectorPredicate>)      -- new

SelectorPredicate:
    Tag(Name)                             -- #attack
    Returns(Spanned<TypeExpr>)            -- returns AttackResult
    HasParam { name: Name, ty: Option<Spanned<TypeExpr>> }  -- has attacker: Character
```

**New enum variant** — `DeclKind::Tag(TagDecl)`

**Modified structs:**

- `FnDecl` gains `tags: Vec<Name>` field
- `ModifyClause.target` changes from `Name` to `ModifyTarget`
- `ModifyClause` gains `id: ModifyClauseId`, assigned during `build_index()`

**Program index** — `Program` gains:
- `tags: HashSet<Name>`, populated by `build_index()`
- `next_modify_clause_id: u32`, counter for generating clause IDs

### Lexer Layer (`ttrpg_lexer`)

New token: `Hash` (`#`). Added to `TokenKind` enum and `next_token()` match.

`tag`, `returns`, `has` are soft keywords (lexed as `Ident`, recognized as
keywords only in selector context `[...]`).

### Type Environment (`ttrpg_checker`)

- `FnInfo` gains:
  - `tags: HashSet<Name>`
  - `synthetic: bool` — propagated from `FnDecl.synthetic` during collection
- `TypeEnv` gains:
  - `tags: HashSet<Name>` — declared tag names
  - `tag_owner: HashMap<Name, Name>` — tag name to owning system
  - `selector_matches: HashMap<ModifyClauseId, HashSet<Name>>` — precomputed match
    sets keyed by clause ID, values are matched function names
- `VisibleNames` gains `tags: HashSet<Name>`

**Note on function identity:** The match set stores `Name` values, which is the
same identifier type used by the existing modifier pipeline (`clause.target` is a
`Name`, dispatch uses `clause.target != fn_name`). Function names are unique
within `TypeEnv.functions`. If the module system evolves to allow qualified or
shadowed function names, the match set representation must evolve correspondingly.

### Module System

- `SystemInfo` (`module.rs`) gains `tags: HashSet<Name>`
- `Namespace` enum (in both `resolve.rs` and `check.rs`) gains `Tag` variant
- Module resolution populates tag ownership and visibility like other namespaces

---

## Checker Algorithm (Detail)

### Pass 1a: Tag Collection

Tag declarations are collected in pass 1a alongside user type registrations.
This ensures all tags are registered before pass 1b, where function signatures
(including tag annotations) are validated.

`collect_tag()` — register tag name in `env.tags`, detect duplicates, record
owning system in `env.tag_owner`.

### Pass 1b: Function Collection

`collect_fn()` — accept `tags: &[Name]`, validate each tag exists in `env.tags`
(guaranteed to be complete since all tags were registered in pass 1a), store in
`FnInfo.tags`. Also propagate `FnDecl.synthetic` into `FnInfo.synthetic`.

### Pass 2: Validation of Selector-Targeted Modify

When `check_modify_clause` encounters `ModifyTarget::Selector(preds)`:

```
pseudocode:
resolve each predicate:
    Tag(t)        → validate t is a declared, visible tag
                    if t exists but is not visible, check whether any
                    visible functions carry t and emit warning if so:
                    "function `foo` carries tag `attack` which is not
                    visible in this scope — consider importing system `bar`"
    Returns(te)   → resolve te to Ty
    HasParam{n,t} → if t is Some, resolve to Ty

M = []
for fn_info in env.functions.values():
    if fn_info.kind not in {Derive, Mechanic}: skip
    if fn_info.synthetic: skip
    if not all predicates match fn_info: skip
    append fn_info to M

emit info "selector matches: {M.names}" (suppressible)

if M is empty:
    warn "selector matches no functions"
    return  // nothing to check, but not an error

// validate bindings against all functions in M
for binding in clause.bindings:
    types_seen = {}
    for fn in M:
        param = fn.params.find(binding.name)
        if param is None:
            error "`{fn.name}` has no parameter `{binding.name}`"
        else:
            types_seen.insert(param.ty)
    if types_seen.len() > 1:
        error "parameter `{binding.name}` has inconsistent types across matched functions: ..."

// determine whether body references `result`
body_uses_result = scan clause.body for result references

// validate return type consistency only if body uses result
if body_uses_result:
    return_types = M.map(|f| f.return_ty).unique()
    if return_types.len() > 1:
        error "matched functions have different return types but body references `result`: ..."

// build synthetic FnInfo for scope construction
// params: intersection (present in all M with identical types)
// return type: common return type if body uses result, else unit
synthetic = build_synthetic_fn_info(M, body_uses_result)

// validate body using synthetic — same as name-targeted path
push scope
bind receiver, condition params
bring synthetic params into scope (read-only)
if body_uses_result:
    bind result with synthetic return type (mutable)
check modify stmts against synthetic
pop scope

// store precomputed match set for interpreter
env.selector_matches.insert(clause.id, M.map(|f| f.name).to_set())
```

The synthetic `FnInfo` is only used for scope construction during checking. It
contains the intersection of parameters (those present in all functions in M with
identical types) and — when the body uses `result` — the common return type
(guaranteed identical by the check above).

**Implementation note:** The naive full scan of `env.functions` per selector is
acceptable for typical system sizes. If performance becomes a concern, pre-index
candidate functions by kind, tag set, and parameter names to reduce matching to
set intersections rather than full environment scans.

---

## Edge Cases

### Selector matches functions with different return types

If the modify body references `result` (field override, full replacement, or
read), this is a compile error listing the conflicting types and which functions
produce them.

If the body does **not** reference `result` (parameter-only modifiers), different
return types are allowed.

### Tag declared but never used

Warning: "tag `foo` is declared but not applied to any function."

### Tag applied but not referenced in any selector

Not an error or warning — tags exist as metadata; not every tag must appear
in a modify clause.

### Selector with only structural predicates (no tag)

Valid. `modify [returns AttackResult, has attacker: Character](...)` matches any
user-authored (non-synthetic) derive/mechanic with that signature shape, regardless
of tags.

### Selector with only a tag predicate

Valid. `modify [#attack](...)` matches all functions tagged `#attack`.

### Binding references a parameter not in all matched functions

Compile error: "`spell_attack` has no parameter `weapon`" (listing the specific
function that fails the check).

### Empty selector `modify [](...)`

Parse error. At least one predicate is required.

### Synthetic functions (`lower_moves` output)

Lowered move functions (`synthetic: true`) are **excluded** from selector matching
by default. Their compiler-generated signatures may incidentally match structural
predicates, and including them would make modifier scope unpredictable. Use
name-based targeting (`modify lowered_fn_name(...)`) to modify specific lowered
functions when needed.

**Implementation note:** `FnInfo` does not currently carry a `synthetic` field;
it must be propagated from `FnDecl.synthetic` during pass 1b collection.

### Module visibility

Tags follow the same visibility rules as other declarations. A selector predicate
`#attack` requires that the `attack` tag is visible in the current system. The
matched functions must also be visible.

**Visibility gap warning:** If a selector references tag `#foo`, and a visible
function carries tag `foo` but the tag itself is not visible (because its declaring
system was not imported), the checker emits a warning: "function `bar` carries tag
`foo` which is not visible in this scope — consider importing system `baz`." This
helps catch missing imports that would cause silent misses without making the
visibility system overly rigid.

If no visible functions carry the inaccessible tag, no warning is emitted.

---

## Future Extensions

### Tag Contracts

```
tag attack requires [has attacker: Character, returns AttackResult]
```

The checker would verify that every function tagged `#attack` conforms to the
contract. This prevents drift where a tagged function's signature changes and
silently breaks selector assumptions. Implementation: the `requires` clause is
parsed as a list of `SelectorPredicate`s and validated at collection time
(`collect_fn` checks the function against its tags' contracts).

### OR Composition

If multiple selectors need to be combined with OR, a future syntax could be:

```
modify [#attack | #spell_attack](...) { ... }
```

For v1, use separate modify clauses instead.

### Tag Hierarchies

Tags could form hierarchies (`tag ranged_attack : attack`) where matching
`#attack` also matches `#ranged_attack`. Deferred — adds complexity to
resolution and the flat model is sufficient for known use cases.

### Relaxed Return Type Matching

The v1 rule requires identical return types when `result` is referenced. A future
version could relax this to per-field structural compatibility: as long as every
function in M has the accessed field with the same type, different return type
names would be allowed. This adds checker complexity but enables broader
selector matching for modify clauses that only touch shared fields.